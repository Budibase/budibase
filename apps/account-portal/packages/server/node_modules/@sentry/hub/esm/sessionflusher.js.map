{"version":3,"file":"sessionflusher.js","sourceRoot":"","sources":["../../src/sessionflusher.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  AggregationCounts,\n  RequestSessionStatus,\n  SessionAggregates,\n  SessionFlusherLike,\n  Transport,\n} from '@sentry/types';\nimport { dropUndefinedKeys, logger } from '@sentry/utils';\n\nimport { IS_DEBUG_BUILD } from './flags';\nimport { getCurrentHub } from './hub';\n\ntype ReleaseHealthAttributes = {\n  environment?: string;\n  release: string;\n};\n\n/**\n * @inheritdoc\n */\nexport class SessionFlusher implements SessionFlusherLike {\n  public readonly flushTimeout: number = 60;\n  private _pendingAggregates: Record<number, AggregationCounts> = {};\n  private _sessionAttrs: ReleaseHealthAttributes;\n  private _intervalId: ReturnType<typeof setInterval>;\n  private _isEnabled: boolean = true;\n  private _transport: Transport;\n\n  public constructor(transport: Transport, attrs: ReleaseHealthAttributes) {\n    this._transport = transport;\n    // Call to setInterval, so that flush is called every 60 seconds\n    this._intervalId = setInterval(() => this.flush(), this.flushTimeout * 1000);\n    this._sessionAttrs = attrs;\n  }\n\n  /** Sends session aggregates to Transport */\n  public sendSessionAggregates(sessionAggregates: SessionAggregates): void {\n    if (!this._transport.sendSession) {\n      IS_DEBUG_BUILD && logger.warn(\"Dropping session because custom transport doesn't implement sendSession\");\n      return;\n    }\n    void this._transport.sendSession(sessionAggregates).then(null, reason => {\n      IS_DEBUG_BUILD && logger.error('Error while sending session:', reason);\n    });\n  }\n\n  /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSessions` */\n  public flush(): void {\n    const sessionAggregates = this.getSessionAggregates();\n    if (sessionAggregates.aggregates.length === 0) {\n      return;\n    }\n    this._pendingAggregates = {};\n    this.sendSessionAggregates(sessionAggregates);\n  }\n\n  /** Massages the entries in `pendingAggregates` and returns aggregated sessions */\n  public getSessionAggregates(): SessionAggregates {\n    const aggregates: AggregationCounts[] = Object.keys(this._pendingAggregates).map((key: string) => {\n      return this._pendingAggregates[parseInt(key)];\n    });\n\n    const sessionAggregates: SessionAggregates = {\n      attrs: this._sessionAttrs,\n      aggregates,\n    };\n    return dropUndefinedKeys(sessionAggregates);\n  }\n\n  /** JSDoc */\n  public close(): void {\n    clearInterval(this._intervalId);\n    this._isEnabled = false;\n    this.flush();\n  }\n\n  /**\n   * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then\n   * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to\n   * `_incrementSessionStatusCount` along with the start date\n   */\n  public incrementSessionStatusCount(): void {\n    if (!this._isEnabled) {\n      return;\n    }\n    const scope = getCurrentHub().getScope();\n    const requestSession = scope && scope.getRequestSession();\n\n    if (requestSession && requestSession.status) {\n      this._incrementSessionStatusCount(requestSession.status, new Date());\n      // This is not entirely necessarily but is added as a safe guard to indicate the bounds of a request and so in\n      // case captureRequestSession is called more than once to prevent double count\n      if (scope) {\n        scope.setRequestSession(undefined);\n      }\n      /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n    }\n  }\n\n  /**\n   * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of\n   * the session received\n   */\n  private _incrementSessionStatusCount(status: RequestSessionStatus, date: Date): number {\n    // Truncate minutes and seconds on Session Started attribute to have one minute bucket keys\n    const sessionStartedTrunc = new Date(date).setSeconds(0, 0);\n    this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};\n\n    // corresponds to aggregated sessions in one specific minute bucket\n    // for example, {\"started\":\"2021-03-16T08:00:00.000Z\",\"exited\":4, \"errored\": 1}\n    const aggregationCounts: AggregationCounts = this._pendingAggregates[sessionStartedTrunc];\n    if (!aggregationCounts.started) {\n      aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();\n    }\n\n    switch (status) {\n      case 'errored':\n        aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;\n        return aggregationCounts.errored;\n      case 'ok':\n        aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;\n        return aggregationCounts.exited;\n      default:\n        aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;\n        return aggregationCounts.crashed;\n    }\n  }\n}\n"]}