{"version":3,"file":"base.js","sourceRoot":"","sources":["../../../src/transports/base.ts"],"names":[],"mappings":"AACA,OAAO,EACL,aAAa,EACb,uBAAuB,EACvB,eAAe,EACf,aAAa,EACb,iBAAiB,EAGjB,mBAAmB,EACnB,mBAAmB,EACnB,iBAAiB,EACjB,gBAAgB,GACjB,MAAM,eAAe,CAAC;AAEvB,MAAM,CAAC,IAAM,wBAAwB,GAAG,OAAO,CAAC;AAEhD,MAAM,CAAC,IAAM,8BAA8B,GAAG,aAAa,CAAC;AAE5D,MAAM,CAAC,IAAM,6BAA6B,GAAG,YAAY,CAAC;AAE1D,MAAM,CAAC,IAAM,0BAA0B,GAAG,SAAS,CAAC;AAuDpD,MAAM,CAAC,IAAM,6BAA6B,GAAG,EAAE,CAAC;AAEhD;;;;;GAKG;AACH,MAAM,UAAU,eAAe,CAC7B,OAAqC,EACrC,WAAqC,EACrC,MAAiH;IAAjH,uBAAA,EAAA,SAA2C,iBAAiB,CAAC,OAAO,CAAC,UAAU,IAAI,6BAA6B,CAAC;IAEjH,IAAI,UAAU,GAAe,EAAE,CAAC;IAEhC,IAAM,KAAK,GAAG,UAAC,OAAgB,IAA2B,OAAA,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,EAArB,CAAqB,CAAC;IAEhF,SAAS,IAAI,CAAC,QAAkB;QAC9B,IAAM,WAAW,GAAG,eAAe,CAAC,QAAQ,CAAC,CAAC;QAC9C,IAAM,QAAQ,GAAG,WAAW,KAAK,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAE,WAAiC,CAAC;QACxF,IAAM,OAAO,GAAqB;YAChC,QAAQ,UAAA;YACR,IAAI,EAAE,iBAAiB,CAAC,QAAQ,CAAC;SAClC,CAAC;QAEF,2DAA2D;QAC3D,IAAI,aAAa,CAAC,UAAU,EAAE,QAAQ,CAAC,EAAE;YACvC,OAAO,mBAAmB,CAAC;gBACzB,MAAM,EAAE,YAAY;gBACpB,MAAM,EAAE,kBAAkB,CAAC,UAAU,EAAE,QAAQ,CAAC;aACjD,CAAC,CAAC;SACJ;QAED,IAAM,WAAW,GAAG;YAClB,OAAA,WAAW,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,UAAC,EAAqC;oBAAnC,cAAI,EAAE,oBAAO,EAAE,kBAAM,EAAE,0BAAU;gBAC5D,IAAM,MAAM,GAAG,uBAAuB,CAAC,UAAU,CAAC,CAAC;gBACnD,IAAI,OAAO,EAAE;oBACX,UAAU,GAAG,gBAAgB,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;iBACpD;gBACD,IAAI,MAAM,KAAK,SAAS,EAAE;oBACxB,OAAO,mBAAmB,CAAC,EAAE,MAAM,QAAA,EAAE,MAAM,QAAA,EAAE,CAAC,CAAC;iBAChD;gBACD,OAAO,mBAAmB,CAAC;oBACzB,MAAM,QAAA;oBACN,MAAM,EACJ,MAAM;wBACN,IAAI;wBACJ,CAAC,MAAM,KAAK,YAAY,CAAC,CAAC,CAAC,kBAAkB,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,yBAAyB,CAAC;iBACnG,CAAC,CAAC;YACL,CAAC,CAAC;QAfF,CAeE,CAAC;QAEL,OAAO,MAAM,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;IACjC,CAAC;IAED,OAAO;QACL,IAAI,MAAA;QACJ,KAAK,OAAA;KACN,CAAC;AACJ,CAAC;AAED,SAAS,kBAAkB,CAAC,UAAsB,EAAE,QAA2B;IAC7E,OAAO,cAAY,QAAQ,sCAAiC,IAAI,IAAI,CAClE,aAAa,CAAC,UAAU,EAAE,QAAQ,CAAC,CACpC,CAAC,WAAW,EAAI,CAAC;AACpB,CAAC","sourcesContent":["import { Envelope, EventStatus } from '@sentry/types';\nimport {\n  disabledUntil,\n  eventStatusFromHttpCode,\n  getEnvelopeType,\n  isRateLimited,\n  makePromiseBuffer,\n  PromiseBuffer,\n  RateLimits,\n  rejectedSyncPromise,\n  resolvedSyncPromise,\n  serializeEnvelope,\n  updateRateLimits,\n} from '@sentry/utils';\n\nexport const ERROR_TRANSPORT_CATEGORY = 'error';\n\nexport const TRANSACTION_TRANSPORT_CATEGORY = 'transaction';\n\nexport const ATTACHMENT_TRANSPORT_CATEGORY = 'attachment';\n\nexport const SESSION_TRANSPORT_CATEGORY = 'session';\n\ntype TransportCategory =\n  | typeof ERROR_TRANSPORT_CATEGORY\n  | typeof TRANSACTION_TRANSPORT_CATEGORY\n  | typeof ATTACHMENT_TRANSPORT_CATEGORY\n  | typeof SESSION_TRANSPORT_CATEGORY;\n\nexport type TransportRequest = {\n  body: string;\n  category: TransportCategory;\n};\n\nexport type TransportMakeRequestResponse = {\n  body?: string;\n  headers?: {\n    [key: string]: string | null;\n    'x-sentry-rate-limits': string | null;\n    'retry-after': string | null;\n  };\n  reason?: string;\n  statusCode: number;\n};\n\nexport type TransportResponse = {\n  status: EventStatus;\n  reason?: string;\n};\n\ninterface InternalBaseTransportOptions {\n  bufferSize?: number;\n}\n\nexport interface BaseTransportOptions extends InternalBaseTransportOptions {\n  // url to send the event\n  // transport does not care about dsn specific - client should take care of\n  // parsing and figuring that out\n  url: string;\n}\n\n// TODO: Move into Browser Transport\nexport interface BrowserTransportOptions extends BaseTransportOptions {\n  // options to pass into fetch request\n  fetchParams: Record<string, string>;\n  headers?: Record<string, string>;\n  sendClientReports?: boolean;\n}\n\nexport interface NewTransport {\n  send(request: Envelope): PromiseLike<TransportResponse>;\n  flush(timeout?: number): PromiseLike<boolean>;\n}\n\nexport type TransportRequestExecutor = (request: TransportRequest) => PromiseLike<TransportMakeRequestResponse>;\n\nexport const DEFAULT_TRANSPORT_BUFFER_SIZE = 30;\n\n/**\n * Creates a `NewTransport`\n *\n * @param options\n * @param makeRequest\n */\nexport function createTransport(\n  options: InternalBaseTransportOptions,\n  makeRequest: TransportRequestExecutor,\n  buffer: PromiseBuffer<TransportResponse> = makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE),\n): NewTransport {\n  let rateLimits: RateLimits = {};\n\n  const flush = (timeout?: number): PromiseLike<boolean> => buffer.drain(timeout);\n\n  function send(envelope: Envelope): PromiseLike<TransportResponse> {\n    const envCategory = getEnvelopeType(envelope);\n    const category = envCategory === 'event' ? 'error' : (envCategory as TransportCategory);\n    const request: TransportRequest = {\n      category,\n      body: serializeEnvelope(envelope),\n    };\n\n    // Don't add to buffer if transport is already rate-limited\n    if (isRateLimited(rateLimits, category)) {\n      return rejectedSyncPromise({\n        status: 'rate_limit',\n        reason: getRateLimitReason(rateLimits, category),\n      });\n    }\n\n    const requestTask = (): PromiseLike<TransportResponse> =>\n      makeRequest(request).then(({ body, headers, reason, statusCode }): PromiseLike<TransportResponse> => {\n        const status = eventStatusFromHttpCode(statusCode);\n        if (headers) {\n          rateLimits = updateRateLimits(rateLimits, headers);\n        }\n        if (status === 'success') {\n          return resolvedSyncPromise({ status, reason });\n        }\n        return rejectedSyncPromise({\n          status,\n          reason:\n            reason ||\n            body ||\n            (status === 'rate_limit' ? getRateLimitReason(rateLimits, category) : 'Unknown transport error'),\n        });\n      });\n\n    return buffer.add(requestTask);\n  }\n\n  return {\n    send,\n    flush,\n  };\n}\n\nfunction getRateLimitReason(rateLimits: RateLimits, category: TransportCategory): string {\n  return `Too many ${category} requests, backing off until: ${new Date(\n    disabledUntil(rateLimits, category),\n  ).toISOString()}`;\n}\n"]}