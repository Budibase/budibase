import {
  __commonJS
} from "./chunk-OROXOI2D.js";

// ../../../../node_modules/shortid/lib/random/random-from-seed.js
var require_random_from_seed = __commonJS({
  "../../../../node_modules/shortid/lib/random/random-from-seed.js"(exports, module) {
    "use strict";
    var seed = 1;
    function getNextValue() {
      seed = (seed * 9301 + 49297) % 233280;
      return seed / 233280;
    }
    function setSeed(_seed_) {
      seed = _seed_;
    }
    module.exports = {
      nextValue: getNextValue,
      seed: setSeed
    };
  }
});

// ../../../../node_modules/shortid/lib/alphabet.js
var require_alphabet = __commonJS({
  "../../../../node_modules/shortid/lib/alphabet.js"(exports, module) {
    "use strict";
    var randomFromSeed = require_random_from_seed();
    var ORIGINAL = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-";
    var alphabet;
    var previousSeed;
    var shuffled;
    function reset() {
      shuffled = false;
    }
    function setCharacters(_alphabet_) {
      if (!_alphabet_) {
        if (alphabet !== ORIGINAL) {
          alphabet = ORIGINAL;
          reset();
        }
        return;
      }
      if (_alphabet_ === alphabet) {
        return;
      }
      if (_alphabet_.length !== ORIGINAL.length) {
        throw new Error("Custom alphabet for shortid must be " + ORIGINAL.length + " unique characters. You submitted " + _alphabet_.length + " characters: " + _alphabet_);
      }
      var unique = _alphabet_.split("").filter(function(item, ind, arr) {
        return ind !== arr.lastIndexOf(item);
      });
      if (unique.length) {
        throw new Error("Custom alphabet for shortid must be " + ORIGINAL.length + " unique characters. These characters were not unique: " + unique.join(", "));
      }
      alphabet = _alphabet_;
      reset();
    }
    function characters(_alphabet_) {
      setCharacters(_alphabet_);
      return alphabet;
    }
    function setSeed(seed) {
      randomFromSeed.seed(seed);
      if (previousSeed !== seed) {
        reset();
        previousSeed = seed;
      }
    }
    function shuffle() {
      if (!alphabet) {
        setCharacters(ORIGINAL);
      }
      var sourceArray = alphabet.split("");
      var targetArray = [];
      var r = randomFromSeed.nextValue();
      var characterIndex;
      while (sourceArray.length > 0) {
        r = randomFromSeed.nextValue();
        characterIndex = Math.floor(r * sourceArray.length);
        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
      }
      return targetArray.join("");
    }
    function getShuffled() {
      if (shuffled) {
        return shuffled;
      }
      shuffled = shuffle();
      return shuffled;
    }
    function lookup(index) {
      var alphabetShuffled = getShuffled();
      return alphabetShuffled[index];
    }
    function get() {
      return alphabet || ORIGINAL;
    }
    module.exports = {
      get,
      characters,
      seed: setSeed,
      lookup,
      shuffled: getShuffled
    };
  }
});

// ../../../../node_modules/shortid/lib/random/random-byte-browser.js
var require_random_byte_browser = __commonJS({
  "../../../../node_modules/shortid/lib/random/random-byte-browser.js"(exports, module) {
    "use strict";
    var crypto = typeof window === "object" && (window.crypto || window.msCrypto);
    var randomByte;
    if (!crypto || !crypto.getRandomValues) {
      randomByte = function(size) {
        var bytes = [];
        for (var i = 0; i < size; i++) {
          bytes.push(Math.floor(Math.random() * 256));
        }
        return bytes;
      };
    } else {
      randomByte = function(size) {
        return crypto.getRandomValues(new Uint8Array(size));
      };
    }
    module.exports = randomByte;
  }
});

// ../../../../node_modules/nanoid/format.browser.js
var require_format_browser = __commonJS({
  "../../../../node_modules/nanoid/format.browser.js"(exports, module) {
    module.exports = function(random, alphabet, size) {
      var mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
      var step = -~(1.6 * mask * size / alphabet.length);
      var id = "";
      while (true) {
        var bytes = random(step);
        var i = step;
        while (i--) {
          id += alphabet[bytes[i] & mask] || "";
          if (id.length === +size)
            return id;
        }
      }
    };
  }
});

// ../../../../node_modules/shortid/lib/generate.js
var require_generate = __commonJS({
  "../../../../node_modules/shortid/lib/generate.js"(exports, module) {
    "use strict";
    var alphabet = require_alphabet();
    var random = require_random_byte_browser();
    var format = require_format_browser();
    function generate(number) {
      var loopCounter = 0;
      var done;
      var str = "";
      while (!done) {
        str = str + format(random, alphabet.get(), 1);
        done = number < Math.pow(16, loopCounter + 1);
        loopCounter++;
      }
      return str;
    }
    module.exports = generate;
  }
});

// ../../../../node_modules/shortid/lib/build.js
var require_build = __commonJS({
  "../../../../node_modules/shortid/lib/build.js"(exports, module) {
    "use strict";
    var generate = require_generate();
    var alphabet = require_alphabet();
    var REDUCE_TIME = 1567752802062;
    var version = 7;
    var counter;
    var previousSeconds;
    function build(clusterWorkerId) {
      var str = "";
      var seconds = Math.floor((Date.now() - REDUCE_TIME) * 1e-3);
      if (seconds === previousSeconds) {
        counter++;
      } else {
        counter = 0;
        previousSeconds = seconds;
      }
      str = str + generate(version);
      str = str + generate(clusterWorkerId);
      if (counter > 0) {
        str = str + generate(counter);
      }
      str = str + generate(seconds);
      return str;
    }
    module.exports = build;
  }
});

// ../../../../node_modules/shortid/lib/is-valid.js
var require_is_valid = __commonJS({
  "../../../../node_modules/shortid/lib/is-valid.js"(exports, module) {
    "use strict";
    var alphabet = require_alphabet();
    function isShortId(id) {
      if (!id || typeof id !== "string" || id.length < 6) {
        return false;
      }
      var nonAlphabetic = new RegExp("[^" + alphabet.get().replace(/[|\\{}()[\]^$+*?.-]/g, "\\$&") + "]");
      return !nonAlphabetic.test(id);
    }
    module.exports = isShortId;
  }
});

// ../../../../node_modules/shortid/lib/util/cluster-worker-id-browser.js
var require_cluster_worker_id_browser = __commonJS({
  "../../../../node_modules/shortid/lib/util/cluster-worker-id-browser.js"(exports, module) {
    "use strict";
    module.exports = 0;
  }
});

// ../../../../node_modules/shortid/lib/index.js
var require_lib = __commonJS({
  "../../../../node_modules/shortid/lib/index.js"(exports, module) {
    "use strict";
    var alphabet = require_alphabet();
    var build = require_build();
    var isValid = require_is_valid();
    var clusterWorkerId = require_cluster_worker_id_browser() || 0;
    function seed(seedValue) {
      alphabet.seed(seedValue);
      return module.exports;
    }
    function worker(workerId) {
      clusterWorkerId = workerId;
      return module.exports;
    }
    function characters(newCharacters) {
      if (newCharacters !== void 0) {
        alphabet.characters(newCharacters);
      }
      return alphabet.shuffled();
    }
    function generate() {
      return build(clusterWorkerId);
    }
    module.exports = generate;
    module.exports.generate = generate;
    module.exports.seed = seed;
    module.exports.worker = worker;
    module.exports.characters = characters;
    module.exports.isValid = isValid;
  }
});

// ../../../../node_modules/shortid/index.js
var require_shortid = __commonJS({
  "../../../../node_modules/shortid/index.js"(exports, module) {
    module.exports = require_lib();
  }
});
export default require_shortid();
//# sourceMappingURL=shortid.js.map
