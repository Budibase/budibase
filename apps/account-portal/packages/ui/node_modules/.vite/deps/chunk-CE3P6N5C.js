import {
  __commonJS
} from "./chunk-OROXOI2D.js";

// ../../../../packages/shared-core/dist/index.js
var require_dist = __commonJS({
  "../../../../packages/shared-core/dist/index.js"(exports, module) {
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      BuilderSocketEvent: () => BuilderSocketEvent,
      GridSocketEvent: () => GridSocketEvent,
      OperatorOptions: () => OperatorOptions,
      SocketEvent: () => SocketEvent,
      SocketSessionTTL: () => SocketSessionTTL,
      SqlNumberTypeRangeMap: () => SqlNumberTypeRangeMap,
      ValidColumnNameRegex: () => ValidColumnNameRegex,
      ValidQueryNameRegex: () => ValidQueryNameRegex,
      canBeDisplayColumn: () => canBeDisplayColumn,
      dataFilters: () => filters_exports,
      helpers: () => helpers_exports,
      sdk: () => sdk_exports,
      utils: () => utils_exports
    });
    module.exports = __toCommonJS(src_exports);
    var OperatorOptions = {
      Equals: {
        value: "equal",
        label: "Equals"
      },
      NotEquals: {
        value: "notEqual",
        label: "Not equals"
      },
      Empty: {
        value: "empty",
        label: "Is empty"
      },
      NotEmpty: {
        value: "notEmpty",
        label: "Is not empty"
      },
      StartsWith: {
        value: "string",
        label: "Starts with"
      },
      Like: {
        value: "fuzzy",
        label: "Like"
      },
      MoreThan: {
        value: "rangeLow",
        label: "More than or equal to"
      },
      LessThan: {
        value: "rangeHigh",
        label: "Less than or equal to"
      },
      Contains: {
        value: "contains",
        label: "Contains"
      },
      NotContains: {
        value: "notContains",
        label: "Does not contain"
      },
      In: {
        value: "oneOf",
        label: "Is in"
      },
      ContainsAny: {
        value: "containsAny",
        label: "Has any"
      }
    };
    var SqlNumberTypeRangeMap = {
      integer: {
        max: 2147483647,
        min: -2147483648
      },
      int: {
        max: 2147483647,
        min: -2147483648
      },
      smallint: {
        max: 32767,
        min: -32768
      },
      mediumint: {
        max: 8388607,
        min: -8388608
      }
    };
    var SocketEvent = ((SocketEvent2) => {
      SocketEvent2["UserUpdate"] = "UserUpdate";
      SocketEvent2["UserDisconnect"] = "UserDisconnect";
      SocketEvent2["Heartbeat"] = "Heartbeat";
      return SocketEvent2;
    })(SocketEvent || {});
    var GridSocketEvent = ((GridSocketEvent2) => {
      GridSocketEvent2["RowChange"] = "RowChange";
      GridSocketEvent2["DatasourceChange"] = "DatasourceChange";
      GridSocketEvent2["SelectDatasource"] = "SelectDatasource";
      GridSocketEvent2["SelectCell"] = "SelectCell";
      return GridSocketEvent2;
    })(GridSocketEvent || {});
    var BuilderSocketEvent = ((BuilderSocketEvent2) => {
      BuilderSocketEvent2["SelectApp"] = "SelectApp";
      BuilderSocketEvent2["TableChange"] = "TableChange";
      BuilderSocketEvent2["DatasourceChange"] = "DatasourceChange";
      BuilderSocketEvent2["LockTransfer"] = "LockTransfer";
      BuilderSocketEvent2["ScreenChange"] = "ScreenChange";
      BuilderSocketEvent2["AppMetadataChange"] = "AppMetadataChange";
      BuilderSocketEvent2["SelectResource"] = "SelectResource";
      BuilderSocketEvent2["AppPublishChange"] = "AppPublishChange";
      BuilderSocketEvent2["AutomationChange"] = "AutomationChange";
      return BuilderSocketEvent2;
    })(BuilderSocketEvent || {});
    var SocketSessionTTL = 60;
    var ValidQueryNameRegex = /^[^()]*$/;
    var ValidColumnNameRegex = /^[_a-zA-Z0-9\s]*$/g;
    var filters_exports = {};
    __export(filters_exports, {
      NoEmptyFilterStrings: () => NoEmptyFilterStrings,
      buildLuceneQuery: () => buildLuceneQuery,
      getValidOperatorsForType: () => getValidOperatorsForType,
      hasFilters: () => hasFilters,
      luceneLimit: () => luceneLimit,
      luceneSort: () => luceneSort,
      runLuceneQuery: () => runLuceneQuery
    });
    var UserGroupSyncEvents = [
      "user:created",
      "user:updated",
      "user:deleted",
      "user:admin:assigned",
      "user:admin:removed",
      "user:builder:assigned",
      "user:builder:removed",
      "user_group:created",
      "user_group:updated",
      "user_group:deleted",
      "user_group:user_added",
      "user_group:users_deleted",
      "user_group:permissions_edited"
    ];
    var AsyncEvents = [...UserGroupSyncEvents];
    var AutomationTriggerStepId = ((AutomationTriggerStepId2) => {
      AutomationTriggerStepId2["ROW_SAVED"] = "ROW_SAVED";
      AutomationTriggerStepId2["ROW_UPDATED"] = "ROW_UPDATED";
      AutomationTriggerStepId2["ROW_DELETED"] = "ROW_DELETED";
      AutomationTriggerStepId2["WEBHOOK"] = "WEBHOOK";
      AutomationTriggerStepId2["APP"] = "APP";
      AutomationTriggerStepId2["CRON"] = "CRON";
      return AutomationTriggerStepId2;
    })(AutomationTriggerStepId || {});
    var AutomationActionStepId = ((AutomationActionStepId2) => {
      AutomationActionStepId2["SEND_EMAIL_SMTP"] = "SEND_EMAIL_SMTP";
      AutomationActionStepId2["CREATE_ROW"] = "CREATE_ROW";
      AutomationActionStepId2["UPDATE_ROW"] = "UPDATE_ROW";
      AutomationActionStepId2["DELETE_ROW"] = "DELETE_ROW";
      AutomationActionStepId2["EXECUTE_BASH"] = "EXECUTE_BASH";
      AutomationActionStepId2["OUTGOING_WEBHOOK"] = "OUTGOING_WEBHOOK";
      AutomationActionStepId2["EXECUTE_SCRIPT"] = "EXECUTE_SCRIPT";
      AutomationActionStepId2["EXECUTE_QUERY"] = "EXECUTE_QUERY";
      AutomationActionStepId2["SERVER_LOG"] = "SERVER_LOG";
      AutomationActionStepId2["DELAY"] = "DELAY";
      AutomationActionStepId2["FILTER"] = "FILTER";
      AutomationActionStepId2["QUERY_ROWS"] = "QUERY_ROWS";
      AutomationActionStepId2["LOOP"] = "LOOP";
      AutomationActionStepId2["COLLECT"] = "COLLECT";
      AutomationActionStepId2["OPENAI"] = "OPENAI";
      AutomationActionStepId2["discord"] = "discord";
      AutomationActionStepId2["slack"] = "slack";
      AutomationActionStepId2["zapier"] = "zapier";
      AutomationActionStepId2["integromat"] = "integromat";
      return AutomationActionStepId2;
    })(AutomationActionStepId || {});
    var AutomationStepIdArray = [
      ...Object.values(AutomationActionStepId),
      ...Object.values(AutomationTriggerStepId)
    ];
    var SEPARATOR = "_";
    var prefixed = (type) => `${type}${SEPARATOR}`;
    var PluginType = ((PluginType2) => {
      PluginType2["DATASOURCE"] = "datasource";
      PluginType2["COMPONENT"] = "component";
      PluginType2["AUTOMATION"] = "automation";
      return PluginType2;
    })(PluginType || {});
    var PLUGIN_TYPE_ARR = Object.values(PluginType);
    var helpers_exports = {};
    __export(helpers_exports, {
      deepGet: () => deepGet,
      getUserColor: () => getUserColor,
      getUserInitials: () => getUserInitials,
      getUserLabel: () => getUserLabel,
      isGoogleSheets: () => isGoogleSheets,
      isSQL: () => isSQL
    });
    var deepGet = (obj, key) => {
      if (!obj || !key) {
        return null;
      }
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        return obj[key];
      }
      const split = key.split(".");
      for (let i = 0; i < split.length; i++) {
        obj = obj == null ? void 0 : obj[split[i]];
      }
      return obj;
    };
    var getUserInitials = (user) => {
      var _a;
      if (!user) {
        return "?";
      }
      let initials = "";
      initials += user.firstName ? user.firstName[0] : "";
      initials += user.lastName ? user.lastName[0] : "";
      if (initials !== "") {
        return initials;
      }
      return ((_a = user.email) == null ? void 0 : _a[0]) || "U";
    };
    var getUserColor = (user) => {
      let id = user == null ? void 0 : user._id;
      if (!id) {
        return "var(--spectrum-global-color-blue-400)";
      }
      id = id.replace("ro_ta_users_", "");
      let hue = 1;
      for (let i = 0; i < id.length; i++) {
        hue += id.charCodeAt(i);
        hue = hue % 36;
      }
      return `hsl(${hue * 10}, 50%, 40%)`;
    };
    var getUserLabel = (user) => {
      if (!user) {
        return "";
      }
      const { firstName, lastName, email } = user;
      if (firstName && lastName) {
        return `${firstName} ${lastName}`;
      } else if (firstName) {
        return firstName;
      } else if (lastName) {
        return lastName;
      } else {
        return email;
      }
    };
    function isGoogleSheets(type) {
      return type === "GOOGLE_SHEETS";
    }
    function isSQL(datasource) {
      if (!datasource || !datasource.source) {
        return false;
      }
      const SQL = [
        "POSTGRES",
        "SQL_SERVER",
        "MYSQL",
        "ORACLE"
      ];
      return SQL.indexOf(datasource.source) !== -1 || datasource.isSQL === true;
    }
    var HBS_REGEX = /{{([^{].*?)}}/g;
    var getValidOperatorsForType = (fieldType, field, datasource) => {
      var _a;
      const Op = OperatorOptions;
      const stringOps = [
        Op.Equals,
        Op.NotEquals,
        Op.StartsWith,
        Op.Like,
        Op.Empty,
        Op.NotEmpty,
        Op.In
      ];
      const numOps = [
        Op.Equals,
        Op.NotEquals,
        Op.MoreThan,
        Op.LessThan,
        Op.Empty,
        Op.NotEmpty,
        Op.In
      ];
      let ops = [];
      const { type, subtype } = fieldType;
      if (type === "string") {
        ops = stringOps;
      } else if (type === "number" || type === "bigint") {
        ops = numOps;
      } else if (type === "options") {
        ops = [Op.Equals, Op.NotEquals, Op.Empty, Op.NotEmpty, Op.In];
      } else if (type === "array") {
        ops = [Op.Contains, Op.NotContains, Op.Empty, Op.NotEmpty, Op.ContainsAny];
      } else if (type === "boolean") {
        ops = [Op.Equals, Op.NotEquals, Op.Empty, Op.NotEmpty];
      } else if (type === "longform") {
        ops = stringOps;
      } else if (type === "datetime") {
        ops = numOps;
      } else if (type === "formula") {
        ops = stringOps.concat([Op.MoreThan, Op.LessThan]);
      } else if (type === "bb_reference" && subtype == "user") {
        ops = [Op.Equals, Op.NotEquals, Op.Empty, Op.NotEmpty, Op.In];
      } else if (type === "bb_reference" && subtype == "users") {
        ops = [Op.Contains, Op.NotContains, Op.ContainsAny, Op.Empty, Op.NotEmpty];
      }
      const externalTable = (_a = datasource == null ? void 0 : datasource.tableId) == null ? void 0 : _a.includes("datasource_plus");
      if (field === "_id" && externalTable) {
        ops = [Op.Equals, Op.NotEquals, Op.In];
      }
      return ops;
    };
    var NoEmptyFilterStrings = [
      OperatorOptions.StartsWith.value,
      OperatorOptions.Like.value,
      OperatorOptions.Equals.value,
      OperatorOptions.NotEquals.value,
      OperatorOptions.Contains.value,
      OperatorOptions.NotContains.value
    ];
    var cleanupQuery = (query) => {
      if (!query) {
        return query;
      }
      for (let filterField of NoEmptyFilterStrings) {
        if (!query[filterField]) {
          continue;
        }
        for (let [key, value] of Object.entries(query[filterField])) {
          if (value == null || value === "") {
            delete query[filterField][key];
          }
        }
      }
      return query;
    };
    var removeKeyNumbering = (key) => {
      if (typeof key === "string" && key.match(/\d[0-9]*:/g) != null) {
        const parts = key.split(":");
        parts.shift();
        return parts.join(":");
      } else {
        return key;
      }
    };
    var buildLuceneQuery = (filter) => {
      let query = {
        string: {},
        fuzzy: {},
        range: {},
        equal: {},
        notEqual: {},
        empty: {},
        notEmpty: {},
        contains: {},
        notContains: {},
        oneOf: {},
        containsAny: {}
      };
      if (Array.isArray(filter)) {
        filter.forEach((expression) => {
          var _a, _b, _c;
          let { operator, field, type, value, externalType, onEmptyFilter } = expression;
          const isHbs = typeof value === "string" && (value.match(HBS_REGEX) || []).length > 0;
          if (operator === "allOr") {
            query.allOr = true;
            return;
          }
          if (onEmptyFilter) {
            query.onEmptyFilter = onEmptyFilter;
            return;
          }
          if (type === "datetime" && !isHbs && operator !== "empty" && operator !== "notEmpty") {
            if (!value) {
              return;
            }
            try {
              value = new Date(value).toISOString();
            } catch (error) {
              return;
            }
          }
          if (type === "number" && typeof value === "string") {
            if (operator === "oneOf") {
              value = value.split(",").map((item) => parseFloat(item));
            } else if (!isHbs) {
              value = parseFloat(value);
            }
          }
          if (type === "boolean") {
            value = ((_a = `${value}`) == null ? void 0 : _a.toLowerCase()) === "true";
          }
          if (["contains", "notContains", "containsAny"].includes(operator) && type === "array" && typeof value === "string") {
            value = value.split(",");
          }
          if (operator.startsWith("range") && query.range) {
            const minint = ((_b = SqlNumberTypeRangeMap[externalType]) == null ? void 0 : _b.min) || Number.MIN_SAFE_INTEGER;
            const maxint = ((_c = SqlNumberTypeRangeMap[externalType]) == null ? void 0 : _c.max) || Number.MAX_SAFE_INTEGER;
            if (!query.range[field]) {
              query.range[field] = {
                low: type === "number" ? minint : "0000-00-00T00:00:00.000Z",
                high: type === "number" ? maxint : "9999-00-00T00:00:00.000Z"
              };
            }
            if (operator === "rangeLow" && value != null && value !== "") {
              query.range[field].low = value;
            } else if (operator === "rangeHigh" && value != null && value !== "") {
              query.range[field].high = value;
            }
          } else if (query[operator] && operator !== "onEmptyFilter") {
            if (type === "boolean") {
              if (operator === "equal" && value === false) {
                query.notEqual = query.notEqual || {};
                query.notEqual[field] = true;
              } else if (operator === "notEqual" && value === false) {
                query.equal = query.equal || {};
                query.equal[field] = true;
              } else {
                query[operator] = query[operator] || {};
                query[operator][field] = value;
              }
            } else {
              query[operator] = query[operator] || {};
              query[operator][field] = value;
            }
          }
        });
      }
      return query;
    };
    var runLuceneQuery = (docs, query) => {
      if (!docs || !Array.isArray(docs)) {
        return [];
      }
      if (!query) {
        return docs;
      }
      query = cleanupQuery(query);
      const match = (type, failFn) => (doc) => {
        const filters = Object.entries(query[type] || {});
        for (let i = 0; i < filters.length; i++) {
          const [key, testValue] = filters[i];
          const docValue = deepGet(doc, removeKeyNumbering(key));
          if (failFn(docValue, testValue)) {
            return false;
          }
        }
        return true;
      };
      const stringMatch = match(
        "string",
        (docValue, testValue) => {
          return !docValue || !(docValue == null ? void 0 : docValue.toLowerCase().startsWith(testValue == null ? void 0 : testValue.toLowerCase()));
        }
      );
      const fuzzyMatch = match(
        "fuzzy",
        (docValue, testValue) => {
          return !docValue || !(docValue == null ? void 0 : docValue.toLowerCase().startsWith(testValue == null ? void 0 : testValue.toLowerCase()));
        }
      );
      const rangeMatch = match(
        "range",
        (docValue, testValue) => {
          return docValue == null || docValue === "" || +docValue < testValue.low || +docValue > testValue.high;
        }
      );
      const equalMatch = match(
        "equal",
        (docValue, testValue) => {
          return testValue != null && testValue !== "" && docValue !== testValue;
        }
      );
      const notEqualMatch = match(
        "notEqual",
        (docValue, testValue) => {
          return testValue != null && testValue !== "" && docValue === testValue;
        }
      );
      const emptyMatch = match(
        "empty",
        (docValue) => {
          return docValue != null && docValue !== "";
        }
      );
      const notEmptyMatch = match(
        "notEmpty",
        (docValue) => {
          return docValue == null || docValue === "";
        }
      );
      const oneOf = match(
        "oneOf",
        (docValue, testValue) => {
          if (typeof testValue === "string") {
            testValue = testValue.split(",");
            if (typeof docValue === "number") {
              testValue = testValue.map((item) => parseFloat(item));
            }
          }
          return !(testValue == null ? void 0 : testValue.includes(docValue));
        }
      );
      const containsAny = match(
        "containsAny",
        (docValue, testValue) => {
          return !(docValue == null ? void 0 : docValue.includes(...testValue));
        }
      );
      const contains = match(
        "contains",
        (docValue, testValue) => {
          return !(testValue == null ? void 0 : testValue.every((item) => docValue == null ? void 0 : docValue.includes(item)));
        }
      );
      const notContains = match(
        "notContains",
        (docValue, testValue) => {
          return testValue == null ? void 0 : testValue.every((item) => docValue == null ? void 0 : docValue.includes(item));
        }
      );
      const docMatch = (doc) => {
        return stringMatch(doc) && fuzzyMatch(doc) && rangeMatch(doc) && equalMatch(doc) && notEqualMatch(doc) && emptyMatch(doc) && notEmptyMatch(doc) && oneOf(doc) && contains(doc) && containsAny(doc) && notContains(doc);
      };
      return docs.filter(docMatch);
    };
    var luceneSort = (docs, sort, sortOrder, sortType = "string") => {
      if (!sort || !sortOrder || !sortType) {
        return docs;
      }
      const parse = sortType === "string" ? (x) => `${x}` : (x) => parseFloat(x);
      return docs.slice().sort((a, b) => {
        const colA = parse(a[sort]);
        const colB = parse(b[sort]);
        if (sortOrder.toLowerCase() === "descending") {
          return colA > colB ? -1 : 1;
        } else {
          return colA > colB ? 1 : -1;
        }
      });
    };
    var luceneLimit = (docs, limit) => {
      const numLimit = parseFloat(limit);
      if (isNaN(numLimit)) {
        return docs;
      }
      return docs.slice(0, numLimit);
    };
    var hasFilters = (query) => {
      if (!query) {
        return false;
      }
      const skipped = ["allOr", "onEmptyFilter"];
      for (let [key, value] of Object.entries(query)) {
        if (skipped.includes(key) || typeof value !== "object") {
          continue;
        }
        if (Object.keys(value || {}).length !== 0) {
          return true;
        }
      }
      return false;
    };
    var utils_exports = {};
    __export(utils_exports, {
      parallelForeach: () => parallelForeach,
      unreachable: () => unreachable
    });
    function unreachable(value, message = `No such case in exhaustive switch: ${value}`) {
      throw new Error(message);
    }
    async function parallelForeach(items, task, maxConcurrency) {
      const promises = [];
      let index = 0;
      const processItem = async (item) => {
        try {
          await task(item);
        } finally {
          processNext();
        }
      };
      const processNext = () => {
        if (index >= items.length) {
          return;
        }
        const item = items[index];
        index++;
        const promise = processItem(item);
        promises.push(promise);
        if (promises.length >= maxConcurrency) {
          Promise.race(promises).then(processNext);
        } else {
          processNext();
        }
      };
      processNext();
      await Promise.all(promises);
    }
    var sdk_exports = {};
    __export(sdk_exports, {
      applications: () => applications_exports,
      users: () => users_exports
    });
    var applications_exports = {};
    __export(applications_exports, {
      getDevAppID: () => getDevAppID,
      getProdAppID: () => getProdAppID
    });
    var APP_PREFIX = prefixed("app");
    var APP_DEV_PREFIX = prefixed("app_dev");
    function getDevAppID(appId) {
      if (!appId) {
        throw new Error("No app ID provided");
      }
      if (appId.startsWith(APP_DEV_PREFIX)) {
        return appId;
      }
      const split = appId.split(APP_PREFIX);
      split.shift();
      const rest = split.join(APP_PREFIX);
      return `${APP_DEV_PREFIX}${rest}`;
    }
    function getProdAppID(appId) {
      if (!appId) {
        throw new Error("No app ID provided");
      }
      if (!appId.startsWith(APP_DEV_PREFIX)) {
        return appId;
      }
      const split = appId.split(APP_DEV_PREFIX);
      split.shift();
      const rest = split.join(APP_DEV_PREFIX);
      return `${APP_PREFIX}${rest}`;
    }
    var users_exports = {};
    __export(users_exports, {
      containsUserID: () => containsUserID,
      getGlobalUserID: () => getGlobalUserID,
      hasAdminPermissions: () => hasAdminPermissions,
      hasAppBuilderPermissions: () => hasAppBuilderPermissions,
      hasBuilderPermissions: () => hasBuilderPermissions,
      isAdmin: () => isAdmin,
      isAdminOrBuilder: () => isAdminOrBuilder,
      isAdminOrGlobalBuilder: () => isAdminOrGlobalBuilder,
      isBuilder: () => isBuilder,
      isGlobalBuilder: () => isGlobalBuilder
    });
    function isBuilder(user, appId) {
      var _a, _b, _c;
      if (!user) {
        return false;
      }
      if ((_a = user.builder) == null ? void 0 : _a.global) {
        return true;
      } else if (appId && ((_c = (_b = user.builder) == null ? void 0 : _b.apps) == null ? void 0 : _c.includes(getProdAppID(appId)))) {
        return true;
      }
      return false;
    }
    function isGlobalBuilder(user) {
      return isBuilder(user) && !hasAppBuilderPermissions(user) || isAdmin(user);
    }
    function isAdmin(user) {
      if (!user) {
        return false;
      }
      return hasAdminPermissions(user);
    }
    function isAdminOrBuilder(user, appId) {
      return isBuilder(user, appId) || isAdmin(user);
    }
    function isAdminOrGlobalBuilder(user, appId) {
      return isGlobalBuilder(user) || isAdmin(user);
    }
    function hasAppBuilderPermissions(user) {
      var _a, _b, _c;
      if (!user) {
        return false;
      }
      const appLength = (_b = (_a = user.builder) == null ? void 0 : _a.apps) == null ? void 0 : _b.length;
      const isGlobalBuilder2 = !!((_c = user.builder) == null ? void 0 : _c.global);
      return !isGlobalBuilder2 && appLength != null && appLength > 0;
    }
    function hasBuilderPermissions(user) {
      var _a;
      if (!user) {
        return false;
      }
      return ((_a = user.builder) == null ? void 0 : _a.global) || hasAppBuilderPermissions(user);
    }
    function hasAdminPermissions(user) {
      var _a;
      if (!user) {
        return false;
      }
      return !!((_a = user.admin) == null ? void 0 : _a.global);
    }
    function getGlobalUserID(userId) {
      if (typeof userId !== "string") {
        return userId;
      }
      const prefix = `${"ro"}${SEPARATOR}${"ta_users"}${SEPARATOR}`;
      if (!userId.startsWith(prefix)) {
        return userId;
      }
      return userId.split(prefix)[1];
    }
    function containsUserID(value) {
      if (typeof value !== "string") {
        return false;
      }
      return value.includes(`${"us"}${SEPARATOR}`);
    }
    var allowDisplayColumnByType = {
      ["string"]: true,
      ["longform"]: true,
      ["options"]: true,
      ["number"]: true,
      ["datetime"]: true,
      ["formula"]: true,
      ["auto"]: true,
      ["internal"]: true,
      ["barcodeqr"]: true,
      ["bigint"]: true,
      ["boolean"]: false,
      ["array"]: false,
      ["attachment"]: false,
      ["link"]: false,
      ["json"]: false,
      ["bb_reference"]: false
    };
    function canBeDisplayColumn(type) {
      return !!allowDisplayColumnByType[type];
    }
  }
});

export {
  require_dist
};
//# sourceMappingURL=chunk-CE3P6N5C.js.map
