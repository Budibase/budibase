{
  "version": 3,
  "sources": ["../../../../../../../node_modules/@roxi/routify/node_modules/commander/index.js"],
  "sourcesContent": ["/**\n * Module dependencies.\n */\n\nconst EventEmitter = require('events').EventEmitter;\nconst childProcess = require('child_process');\nconst path = require('path');\nconst fs = require('fs');\n\n// @ts-check\n\n// Although this is a class, methods are static in style to allow override using subclass or just functions.\nclass Help {\n  constructor() {\n    this.helpWidth = undefined;\n    this.sortSubcommands = false;\n    this.sortOptions = false;\n  }\n\n  /**\n   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Command[]}\n   */\n\n  visibleCommands(cmd) {\n    const visibleCommands = cmd.commands.filter(cmd => !cmd._hidden);\n    if (cmd._hasImplicitHelpCommand()) {\n      // Create a command matching the implicit help command.\n      const args = cmd._helpCommandnameAndArgs.split(/ +/);\n      const helpCommand = cmd.createCommand(args.shift())\n        .helpOption(false);\n      helpCommand.description(cmd._helpCommandDescription);\n      helpCommand._parseExpectedArgs(args);\n      visibleCommands.push(helpCommand);\n    }\n    if (this.sortSubcommands) {\n      visibleCommands.sort((a, b) => {\n        return a.name().localeCompare(b.name());\n      });\n    }\n    return visibleCommands;\n  }\n\n  /**\n   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Option[]}\n   */\n\n  visibleOptions(cmd) {\n    const visibleOptions = cmd.options.filter((option) => !option.hidden);\n    // Implicit help\n    const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);\n    const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);\n    if (showShortHelpFlag || showLongHelpFlag) {\n      let helpOption;\n      if (!showShortHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);\n      } else if (!showLongHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);\n      } else {\n        helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);\n      }\n      visibleOptions.push(helpOption);\n    }\n    if (this.sortOptions) {\n      const getSortKey = (option) => {\n        // WYSIWYG for order displayed in help with short before long, no special handling for negated.\n        return option.short ? option.short.replace(/^-/, '') : option.long.replace(/^--/, '');\n      };\n      visibleOptions.sort((a, b) => {\n        return getSortKey(a).localeCompare(getSortKey(b));\n      });\n    }\n    return visibleOptions;\n  }\n\n  /**\n   * Get an array of the arguments which have descriptions.\n   *\n   * @param {Command} cmd\n   * @returns {{ term: string, description:string }[]}\n   */\n\n  visibleArguments(cmd) {\n    if (cmd._argsDescription && cmd._args.length) {\n      return cmd._args.map((argument) => {\n        return { term: argument.name, description: cmd._argsDescription[argument.name] || '' };\n      }, 0);\n    }\n    return [];\n  }\n\n  /**\n   * Get the command term to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandTerm(cmd) {\n    // Legacy. Ignores custom usage string, and nested commands.\n    const args = cmd._args.map(arg => humanReadableArgName(arg)).join(' ');\n    return cmd._name +\n      (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +\n      (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option\n      (args ? ' ' + args : '');\n  }\n\n  /**\n   * Get the option term to show in the list of options.\n   *\n   * @param {Option} option\n   * @returns {string}\n   */\n\n  optionTerm(option) {\n    return option.flags;\n  }\n\n  /**\n   * Get the longest command term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestSubcommandTermLength(cmd, helper) {\n    return helper.visibleCommands(cmd).reduce((max, command) => {\n      return Math.max(max, helper.subcommandTerm(command).length);\n    }, 0);\n  };\n\n  /**\n   * Get the longest option term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestOptionTermLength(cmd, helper) {\n    return helper.visibleOptions(cmd).reduce((max, option) => {\n      return Math.max(max, helper.optionTerm(option).length);\n    }, 0);\n  };\n\n  /**\n   * Get the longest argument term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestArgumentTermLength(cmd, helper) {\n    return helper.visibleArguments(cmd).reduce((max, argument) => {\n      return Math.max(max, argument.term.length);\n    }, 0);\n  };\n\n  /**\n   * Get the command usage to be displayed at the top of the built-in help.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandUsage(cmd) {\n    // Usage\n    let cmdName = cmd._name;\n    if (cmd._aliases[0]) {\n      cmdName = cmdName + '|' + cmd._aliases[0];\n    }\n    let parentCmdNames = '';\n    for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {\n      parentCmdNames = parentCmd.name() + ' ' + parentCmdNames;\n    }\n    return parentCmdNames + cmdName + ' ' + cmd.usage();\n  }\n\n  /**\n   * Get the description for the command.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.description();\n  }\n\n  /**\n   * Get the command description to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.description();\n  }\n\n  /**\n   * Get the option description to show in the list of options.\n   *\n   * @param {Option} option\n   * @return {string}\n   */\n\n  optionDescription(option) {\n    if (option.negate) {\n      return option.description;\n    }\n    const extraInfo = [];\n    if (option.argChoices) {\n      extraInfo.push(\n        // use stringify to match the display of the default value\n        `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);\n    }\n    if (option.defaultValue !== undefined) {\n      extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);\n    }\n    if (extraInfo.length > 0) {\n      return `${option.description} (${extraInfo.join(', ')})`;\n    }\n    return option.description;\n  };\n\n  /**\n   * Generate the built-in help text.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {string}\n   */\n\n  formatHelp(cmd, helper) {\n    const termWidth = helper.padWidth(cmd, helper);\n    const helpWidth = helper.helpWidth || 80;\n    const itemIndentWidth = 2;\n    const itemSeparatorWidth = 2; // between term and description\n    function formatItem(term, description) {\n      if (description) {\n        const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;\n        return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);\n      }\n      return term;\n    };\n    function formatList(textArray) {\n      return textArray.join('\\n').replace(/^/gm, ' '.repeat(itemIndentWidth));\n    }\n\n    // Usage\n    let output = [`Usage: ${helper.commandUsage(cmd)}`, ''];\n\n    // Description\n    const commandDescription = helper.commandDescription(cmd);\n    if (commandDescription.length > 0) {\n      output = output.concat([commandDescription, '']);\n    }\n\n    // Arguments\n    const argumentList = helper.visibleArguments(cmd).map((argument) => {\n      return formatItem(argument.term, argument.description);\n    });\n    if (argumentList.length > 0) {\n      output = output.concat(['Arguments:', formatList(argumentList), '']);\n    }\n\n    // Options\n    const optionList = helper.visibleOptions(cmd).map((option) => {\n      return formatItem(helper.optionTerm(option), helper.optionDescription(option));\n    });\n    if (optionList.length > 0) {\n      output = output.concat(['Options:', formatList(optionList), '']);\n    }\n\n    // Commands\n    const commandList = helper.visibleCommands(cmd).map((cmd) => {\n      return formatItem(helper.subcommandTerm(cmd), helper.subcommandDescription(cmd));\n    });\n    if (commandList.length > 0) {\n      output = output.concat(['Commands:', formatList(commandList), '']);\n    }\n\n    return output.join('\\n');\n  }\n\n  /**\n   * Calculate the pad width from the maximum term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  padWidth(cmd, helper) {\n    return Math.max(\n      helper.longestOptionTermLength(cmd, helper),\n      helper.longestSubcommandTermLength(cmd, helper),\n      helper.longestArgumentTermLength(cmd, helper)\n    );\n  };\n\n  /**\n   * Wrap the given string to width characters per line, with lines after the first indented.\n   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.\n   *\n   * @param {string} str\n   * @param {number} width\n   * @param {number} indent\n   * @param {number} [minColumnWidth=40]\n   * @return {string}\n   *\n   */\n\n  wrap(str, width, indent, minColumnWidth = 40) {\n    // Detect manually wrapped and indented strings by searching for line breaks\n    // followed by multiple spaces/tabs.\n    if (str.match(/[\\n]\\s+/)) return str;\n    // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).\n    const columnWidth = width - indent;\n    if (columnWidth < minColumnWidth) return str;\n\n    const leadingStr = str.substr(0, indent);\n    const columnText = str.substr(indent);\n\n    const indentString = ' '.repeat(indent);\n    const regex = new RegExp('.{1,' + (columnWidth - 1) + '}([\\\\s\\u200B]|$)|[^\\\\s\\u200B]+?([\\\\s\\u200B]|$)', 'g');\n    const lines = columnText.match(regex) || [];\n    return leadingStr + lines.map((line, i) => {\n      if (line.slice(-1) === '\\n') {\n        line = line.slice(0, line.length - 1);\n      }\n      return ((i > 0) ? indentString : '') + line.trimRight();\n    }).join('\\n');\n  }\n}\n\nclass Option {\n  /**\n   * Initialize a new `Option` with the given `flags` and `description`.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   */\n\n  constructor(flags, description) {\n    this.flags = flags;\n    this.description = description || '';\n\n    this.required = flags.includes('<'); // A value must be supplied when the option is specified.\n    this.optional = flags.includes('['); // A value is optional when the option is specified.\n    // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument\n    this.variadic = /\\w\\.\\.\\.[>\\]]$/.test(flags); // The option can take multiple values.\n    this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.\n    const optionFlags = _parseOptionFlags(flags);\n    this.short = optionFlags.shortFlag;\n    this.long = optionFlags.longFlag;\n    this.negate = false;\n    if (this.long) {\n      this.negate = this.long.startsWith('--no-');\n    }\n    this.defaultValue = undefined;\n    this.defaultValueDescription = undefined;\n    this.parseArg = undefined;\n    this.hidden = false;\n    this.argChoices = undefined;\n  }\n\n  /**\n   * Set the default value, and optionally supply the description to be displayed in the help.\n   *\n   * @param {any} value\n   * @param {string} [description]\n   * @return {Option}\n   */\n\n  default(value, description) {\n    this.defaultValue = value;\n    this.defaultValueDescription = description;\n    return this;\n  };\n\n  /**\n   * Set the custom handler for processing CLI option arguments into option values.\n   *\n   * @param {Function} [fn]\n   * @return {Option}\n   */\n\n  argParser(fn) {\n    this.parseArg = fn;\n    return this;\n  };\n\n  /**\n   * Whether the option is mandatory and must have a value after parsing.\n   *\n   * @param {boolean} [mandatory=true]\n   * @return {Option}\n   */\n\n  makeOptionMandatory(mandatory = true) {\n    this.mandatory = !!mandatory;\n    return this;\n  };\n\n  /**\n   * Hide option in help.\n   *\n   * @param {boolean} [hide=true]\n   * @return {Option}\n   */\n\n  hideHelp(hide = true) {\n    this.hidden = !!hide;\n    return this;\n  };\n\n  /**\n   * @api private\n   */\n\n  _concatValue(value, previous) {\n    if (previous === this.defaultValue || !Array.isArray(previous)) {\n      return [value];\n    }\n\n    return previous.concat(value);\n  }\n\n  /**\n   * Only allow option value to be one of choices.\n   *\n   * @param {string[]} values\n   * @return {Option}\n   */\n\n  choices(values) {\n    this.argChoices = values;\n    this.parseArg = (arg, previous) => {\n      if (!values.includes(arg)) {\n        throw new InvalidOptionArgumentError(`Allowed choices are ${values.join(', ')}.`);\n      }\n      if (this.variadic) {\n        return this._concatValue(arg, previous);\n      }\n      return arg;\n    };\n    return this;\n  };\n\n  /**\n   * Return option name.\n   *\n   * @return {string}\n   */\n\n  name() {\n    if (this.long) {\n      return this.long.replace(/^--/, '');\n    }\n    return this.short.replace(/^-/, '');\n  };\n\n  /**\n   * Return option name, in a camelcase format that can be used\n   * as a object attribute key.\n   *\n   * @return {string}\n   * @api private\n   */\n\n  attributeName() {\n    return camelcase(this.name().replace(/^no-/, ''));\n  };\n\n  /**\n   * Check if `arg` matches the short or long flag.\n   *\n   * @param {string} arg\n   * @return {boolean}\n   * @api private\n   */\n\n  is(arg) {\n    return this.short === arg || this.long === arg;\n  };\n}\n\n/**\n * CommanderError class\n * @class\n */\nclass CommanderError extends Error {\n  /**\n   * Constructs the CommanderError class\n   * @param {number} exitCode suggested exit code which could be used with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   * @constructor\n   */\n  constructor(exitCode, code, message) {\n    super(message);\n    // properly capture stack trace in Node.js\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n    this.code = code;\n    this.exitCode = exitCode;\n    this.nestedError = undefined;\n  }\n}\n\n/**\n * InvalidOptionArgumentError class\n * @class\n */\nclass InvalidOptionArgumentError extends CommanderError {\n  /**\n   * Constructs the InvalidOptionArgumentError class\n   * @param {string} [message] explanation of why argument is invalid\n   * @constructor\n   */\n  constructor(message) {\n    super(1, 'commander.invalidOptionArgument', message);\n    // properly capture stack trace in Node.js\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n  }\n}\n\nclass Command extends EventEmitter {\n  /**\n   * Initialize a new `Command`.\n   *\n   * @param {string} [name]\n   */\n\n  constructor(name) {\n    super();\n    this.commands = [];\n    this.options = [];\n    this.parent = null;\n    this._allowUnknownOption = false;\n    this._allowExcessArguments = true;\n    this._args = [];\n    this.rawArgs = null;\n    this._scriptPath = null;\n    this._name = name || '';\n    this._optionValues = {};\n    this._storeOptionsAsProperties = false;\n    this._actionResults = [];\n    this._actionHandler = null;\n    this._executableHandler = false;\n    this._executableFile = null; // custom name for executable\n    this._defaultCommandName = null;\n    this._exitCallback = null;\n    this._aliases = [];\n    this._combineFlagAndOptionalValue = true;\n    this._description = '';\n    this._argsDescription = undefined;\n    this._enablePositionalOptions = false;\n    this._passThroughOptions = false;\n\n    // see .configureOutput() for docs\n    this._outputConfiguration = {\n      writeOut: (str) => process.stdout.write(str),\n      writeErr: (str) => process.stderr.write(str),\n      getOutHelpWidth: () => process.stdout.isTTY ? process.stdout.columns : undefined,\n      getErrHelpWidth: () => process.stderr.isTTY ? process.stderr.columns : undefined,\n      outputError: (str, write) => write(str)\n    };\n\n    this._hidden = false;\n    this._hasHelpOption = true;\n    this._helpFlags = '-h, --help';\n    this._helpDescription = 'display help for command';\n    this._helpShortFlag = '-h';\n    this._helpLongFlag = '--help';\n    this._addImplicitHelpCommand = undefined; // Deliberately undefined, not decided whether true or false\n    this._helpCommandName = 'help';\n    this._helpCommandnameAndArgs = 'help [command]';\n    this._helpCommandDescription = 'display help for command';\n    this._helpConfiguration = {};\n  }\n\n  /**\n   * Define a command.\n   *\n   * There are two styles of command: pay attention to where to put the description.\n   *\n   * Examples:\n   *\n   *      // Command implemented using action handler (description is supplied separately to `.command`)\n   *      program\n   *        .command('clone <source> [destination]')\n   *        .description('clone a repository into a newly created directory')\n   *        .action((source, destination) => {\n   *          console.log('clone command called');\n   *        });\n   *\n   *      // Command implemented using separate executable file (description is second parameter to `.command`)\n   *      program\n   *        .command('start <service>', 'start named service')\n   *        .command('stop [service]', 'stop named service, or all if no name supplied');\n   *\n   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`\n   * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)\n   * @param {Object} [execOpts] - configuration options (for executable)\n   * @return {Command} returns new command for action handler, or `this` for executable command\n   */\n\n  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {\n    let desc = actionOptsOrExecDesc;\n    let opts = execOpts;\n    if (typeof desc === 'object' && desc !== null) {\n      opts = desc;\n      desc = null;\n    }\n    opts = opts || {};\n    const args = nameAndArgs.split(/ +/);\n    const cmd = this.createCommand(args.shift());\n\n    if (desc) {\n      cmd.description(desc);\n      cmd._executableHandler = true;\n    }\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n\n    cmd._outputConfiguration = this._outputConfiguration;\n\n    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden\n    cmd._hasHelpOption = this._hasHelpOption;\n    cmd._helpFlags = this._helpFlags;\n    cmd._helpDescription = this._helpDescription;\n    cmd._helpShortFlag = this._helpShortFlag;\n    cmd._helpLongFlag = this._helpLongFlag;\n    cmd._helpCommandName = this._helpCommandName;\n    cmd._helpCommandnameAndArgs = this._helpCommandnameAndArgs;\n    cmd._helpCommandDescription = this._helpCommandDescription;\n    cmd._helpConfiguration = this._helpConfiguration;\n    cmd._exitCallback = this._exitCallback;\n    cmd._storeOptionsAsProperties = this._storeOptionsAsProperties;\n    cmd._combineFlagAndOptionalValue = this._combineFlagAndOptionalValue;\n    cmd._allowExcessArguments = this._allowExcessArguments;\n    cmd._enablePositionalOptions = this._enablePositionalOptions;\n\n    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor\n    this.commands.push(cmd);\n    cmd._parseExpectedArgs(args);\n    cmd.parent = this;\n\n    if (desc) return this;\n    return cmd;\n  };\n\n  /**\n   * Factory routine to create a new unattached command.\n   *\n   * See .command() for creating an attached subcommand, which uses this routine to\n   * create the command. You can override createCommand to customise subcommands.\n   *\n   * @param {string} [name]\n   * @return {Command} new command\n   */\n\n  createCommand(name) {\n    return new Command(name);\n  };\n\n  /**\n   * You can customise the help with a subclass of Help by overriding createHelp,\n   * or by overriding Help properties using configureHelp().\n   *\n   * @return {Help}\n   */\n\n  createHelp() {\n    return Object.assign(new Help(), this.configureHelp());\n  };\n\n  /**\n   * You can customise the help by overriding Help properties using configureHelp(),\n   * or with a subclass of Help by overriding createHelp().\n   *\n   * @param {Object} [configuration] - configuration options\n   * @return {Command|Object} `this` command for chaining, or stored configuration\n   */\n\n  configureHelp(configuration) {\n    if (configuration === undefined) return this._helpConfiguration;\n\n    this._helpConfiguration = configuration;\n    return this;\n  }\n\n  /**\n   * The default output goes to stdout and stderr. You can customise this for special\n   * applications. You can also customise the display of errors by overriding outputError.\n   *\n   * The configuration properties are all functions:\n   *\n   *    // functions to change where being written, stdout and stderr\n   *    writeOut(str)\n   *    writeErr(str)\n   *    // matching functions to specify width for wrapping help\n   *    getOutHelpWidth()\n   *    getErrHelpWidth()\n   *    // functions based on what is being written out\n   *    outputError(str, write) // used for displaying errors, and not used for displaying help\n   *\n   * @param {Object} [configuration] - configuration options\n   * @return {Command|Object} `this` command for chaining, or stored configuration\n   */\n\n  configureOutput(configuration) {\n    if (configuration === undefined) return this._outputConfiguration;\n\n    Object.assign(this._outputConfiguration, configuration);\n    return this;\n  }\n\n  /**\n   * Add a prepared subcommand.\n   *\n   * See .command() for creating an attached subcommand which inherits settings from its parent.\n   *\n   * @param {Command} cmd - new subcommand\n   * @param {Object} [opts] - configuration options\n   * @return {Command} `this` command for chaining\n   */\n\n  addCommand(cmd, opts) {\n    if (!cmd._name) throw new Error('Command passed to .addCommand() must have a name');\n\n    // To keep things simple, block automatic name generation for deeply nested executables.\n    // Fail fast and detect when adding rather than later when parsing.\n    function checkExplicitNames(commandArray) {\n      commandArray.forEach((cmd) => {\n        if (cmd._executableHandler && !cmd._executableFile) {\n          throw new Error(`Must specify executableFile for deeply nested executable: ${cmd.name()}`);\n        }\n        checkExplicitNames(cmd.commands);\n      });\n    }\n    checkExplicitNames(cmd.commands);\n\n    opts = opts || {};\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation\n\n    this.commands.push(cmd);\n    cmd.parent = this;\n    return this;\n  };\n\n  /**\n   * Define argument syntax for the command.\n   */\n\n  arguments(desc) {\n    return this._parseExpectedArgs(desc.split(/ +/));\n  };\n\n  /**\n   * Override default decision whether to add implicit help command.\n   *\n   *    addHelpCommand() // force on\n   *    addHelpCommand(false); // force off\n   *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details\n   *\n   * @return {Command} `this` command for chaining\n   */\n\n  addHelpCommand(enableOrNameAndArgs, description) {\n    if (enableOrNameAndArgs === false) {\n      this._addImplicitHelpCommand = false;\n    } else {\n      this._addImplicitHelpCommand = true;\n      if (typeof enableOrNameAndArgs === 'string') {\n        this._helpCommandName = enableOrNameAndArgs.split(' ')[0];\n        this._helpCommandnameAndArgs = enableOrNameAndArgs;\n      }\n      this._helpCommandDescription = description || this._helpCommandDescription;\n    }\n    return this;\n  };\n\n  /**\n   * @return {boolean}\n   * @api private\n   */\n\n  _hasImplicitHelpCommand() {\n    if (this._addImplicitHelpCommand === undefined) {\n      return this.commands.length && !this._actionHandler && !this._findCommand('help');\n    }\n    return this._addImplicitHelpCommand;\n  };\n\n  /**\n   * Parse expected `args`.\n   *\n   * For example `[\"[type]\"]` becomes `[{ required: false, name: 'type' }]`.\n   *\n   * @param {Array} args\n   * @return {Command} `this` command for chaining\n   * @api private\n   */\n\n  _parseExpectedArgs(args) {\n    if (!args.length) return;\n    args.forEach((arg) => {\n      const argDetails = {\n        required: false,\n        name: '',\n        variadic: false\n      };\n\n      switch (arg[0]) {\n        case '<':\n          argDetails.required = true;\n          argDetails.name = arg.slice(1, -1);\n          break;\n        case '[':\n          argDetails.name = arg.slice(1, -1);\n          break;\n      }\n\n      if (argDetails.name.length > 3 && argDetails.name.slice(-3) === '...') {\n        argDetails.variadic = true;\n        argDetails.name = argDetails.name.slice(0, -3);\n      }\n      if (argDetails.name) {\n        this._args.push(argDetails);\n      }\n    });\n    this._args.forEach((arg, i) => {\n      if (arg.variadic && i < this._args.length - 1) {\n        throw new Error(`only the last argument can be variadic '${arg.name}'`);\n      }\n    });\n    return this;\n  };\n\n  /**\n   * Register callback to use as replacement for calling process.exit.\n   *\n   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing\n   * @return {Command} `this` command for chaining\n   */\n\n  exitOverride(fn) {\n    if (fn) {\n      this._exitCallback = fn;\n    } else {\n      this._exitCallback = (err) => {\n        if (err.code !== 'commander.executeSubCommandAsync') {\n          throw err;\n        } else {\n          // Async callback from spawn events, not useful to throw.\n        }\n      };\n    }\n    return this;\n  };\n\n  /**\n   * Call process.exit, and _exitCallback if defined.\n   *\n   * @param {number} exitCode exit code for using with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   * @return never\n   * @api private\n   */\n\n  _exit(exitCode, code, message) {\n    if (this._exitCallback) {\n      this._exitCallback(new CommanderError(exitCode, code, message));\n      // Expecting this line is not reached.\n    }\n    process.exit(exitCode);\n  };\n\n  /**\n   * Register callback `fn` for the command.\n   *\n   * Examples:\n   *\n   *      program\n   *        .command('help')\n   *        .description('display verbose help')\n   *        .action(function() {\n   *           // output help here\n   *        });\n   *\n   * @param {Function} fn\n   * @return {Command} `this` command for chaining\n   */\n\n  action(fn) {\n    const listener = (args) => {\n      // The .action callback takes an extra parameter which is the command or options.\n      const expectedArgsCount = this._args.length;\n      const actionArgs = args.slice(0, expectedArgsCount);\n      if (this._storeOptionsAsProperties) {\n        actionArgs[expectedArgsCount] = this; // backwards compatible \"options\"\n      } else {\n        actionArgs[expectedArgsCount] = this.opts();\n      }\n      actionArgs.push(this);\n\n      const actionResult = fn.apply(this, actionArgs);\n      // Remember result in case it is async. Assume parseAsync getting called on root.\n      let rootCommand = this;\n      while (rootCommand.parent) {\n        rootCommand = rootCommand.parent;\n      }\n      rootCommand._actionResults.push(actionResult);\n    };\n    this._actionHandler = listener;\n    return this;\n  };\n\n  /**\n   * Factory routine to create a new unattached option.\n   *\n   * See .option() for creating an attached option, which uses this routine to\n   * create the option. You can override createOption to return a custom option.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @return {Option} new option\n   */\n\n  createOption(flags, description) {\n    return new Option(flags, description);\n  };\n\n  /**\n   * Add an option.\n   *\n   * @param {Option} option\n   * @return {Command} `this` command for chaining\n   */\n  addOption(option) {\n    const oname = option.name();\n    const name = option.attributeName();\n\n    let defaultValue = option.defaultValue;\n\n    // preassign default value for --no-*, [optional], <required>, or plain flag if boolean value\n    if (option.negate || option.optional || option.required || typeof defaultValue === 'boolean') {\n      // when --no-foo we make sure default is true, unless a --foo option is already defined\n      if (option.negate) {\n        const positiveLongFlag = option.long.replace(/^--no-/, '--');\n        defaultValue = this._findOption(positiveLongFlag) ? this._getOptionValue(name) : true;\n      }\n      // preassign only if we have a default\n      if (defaultValue !== undefined) {\n        this._setOptionValue(name, defaultValue);\n      }\n    }\n\n    // register the option\n    this.options.push(option);\n\n    // when it's passed assign the value\n    // and conditionally invoke the callback\n    this.on('option:' + oname, (val) => {\n      const oldValue = this._getOptionValue(name);\n\n      // custom processing\n      if (val !== null && option.parseArg) {\n        try {\n          val = option.parseArg(val, oldValue === undefined ? defaultValue : oldValue);\n        } catch (err) {\n          if (err.code === 'commander.invalidOptionArgument') {\n            const message = `error: option '${option.flags}' argument '${val}' is invalid. ${err.message}`;\n            this._displayError(err.exitCode, err.code, message);\n          }\n          throw err;\n        }\n      } else if (val !== null && option.variadic) {\n        val = option._concatValue(val, oldValue);\n      }\n\n      // unassigned or boolean value\n      if (typeof oldValue === 'boolean' || typeof oldValue === 'undefined') {\n        // if no value, negate false, and we have a default, then use it!\n        if (val == null) {\n          this._setOptionValue(name, option.negate\n            ? false\n            : defaultValue || true);\n        } else {\n          this._setOptionValue(name, val);\n        }\n      } else if (val !== null) {\n        // reassign\n        this._setOptionValue(name, option.negate ? false : val);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Internal implementation shared by .option() and .requiredOption()\n   *\n   * @api private\n   */\n  _optionEx(config, flags, description, fn, defaultValue) {\n    const option = this.createOption(flags, description);\n    option.makeOptionMandatory(!!config.mandatory);\n    if (typeof fn === 'function') {\n      option.default(defaultValue).argParser(fn);\n    } else if (fn instanceof RegExp) {\n      // deprecated\n      const regex = fn;\n      fn = (val, def) => {\n        const m = regex.exec(val);\n        return m ? m[0] : def;\n      };\n      option.default(defaultValue).argParser(fn);\n    } else {\n      option.default(fn);\n    }\n\n    return this.addOption(option);\n  }\n\n  /**\n   * Define option with `flags`, `description` and optional\n   * coercion `fn`.\n   *\n   * The `flags` string contains the short and/or long flags,\n   * separated by comma, a pipe or space. The following are all valid\n   * all will output this way when `--help` is used.\n   *\n   *    \"-p, --pepper\"\n   *    \"-p|--pepper\"\n   *    \"-p --pepper\"\n   *\n   * Examples:\n   *\n   *     // simple boolean defaulting to undefined\n   *     program.option('-p, --pepper', 'add pepper');\n   *\n   *     program.pepper\n   *     // => undefined\n   *\n   *     --pepper\n   *     program.pepper\n   *     // => true\n   *\n   *     // simple boolean defaulting to true (unless non-negated option is also defined)\n   *     program.option('-C, --no-cheese', 'remove cheese');\n   *\n   *     program.cheese\n   *     // => true\n   *\n   *     --no-cheese\n   *     program.cheese\n   *     // => false\n   *\n   *     // required argument\n   *     program.option('-C, --chdir <path>', 'change the working directory');\n   *\n   *     --chdir /tmp\n   *     program.chdir\n   *     // => \"/tmp\"\n   *\n   *     // optional argument\n   *     program.option('-c, --cheese [type]', 'add cheese [marble]');\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @param {Function|*} [fn] - custom option processing function or default value\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n\n  option(flags, description, fn, defaultValue) {\n    return this._optionEx({}, flags, description, fn, defaultValue);\n  };\n\n  /**\n  * Add a required option which must have a value after parsing. This usually means\n  * the option must be specified on the command line. (Otherwise the same as .option().)\n  *\n  * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.\n  *\n  * @param {string} flags\n  * @param {string} [description]\n  * @param {Function|*} [fn] - custom option processing function or default value\n  * @param {*} [defaultValue]\n  * @return {Command} `this` command for chaining\n  */\n\n  requiredOption(flags, description, fn, defaultValue) {\n    return this._optionEx({ mandatory: true }, flags, description, fn, defaultValue);\n  };\n\n  /**\n   * Alter parsing of short flags with optional values.\n   *\n   * Examples:\n   *\n   *    // for `.option('-f,--flag [value]'):\n   *    .combineFlagAndOptionalValue(true)  // `-f80` is treated like `--flag=80`, this is the default behaviour\n   *    .combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`\n   *\n   * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.\n   */\n  combineFlagAndOptionalValue(combine = true) {\n    this._combineFlagAndOptionalValue = !!combine;\n    return this;\n  };\n\n  /**\n   * Allow unknown options on the command line.\n   *\n   * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown\n   * for unknown options.\n   */\n  allowUnknownOption(allowUnknown = true) {\n    this._allowUnknownOption = !!allowUnknown;\n    return this;\n  };\n\n  /**\n   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.\n   *\n   * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown\n   * for excess arguments.\n   */\n  allowExcessArguments(allowExcess = true) {\n    this._allowExcessArguments = !!allowExcess;\n    return this;\n  };\n\n  /**\n   * Enable positional options. Positional means global options are specified before subcommands which lets\n   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.\n   * The default behaviour is non-positional and global options may appear anywhere on the command line.\n   *\n   * @param {Boolean} [positional=true]\n   */\n  enablePositionalOptions(positional = true) {\n    this._enablePositionalOptions = !!positional;\n    return this;\n  };\n\n  /**\n   * Pass through options that come after command-arguments rather than treat them as command-options,\n   * so actual command-options come before command-arguments. Turning this on for a subcommand requires\n   * positional options to have been enabled on the program (parent commands).\n   * The default behaviour is non-positional and options may appear before or after command-arguments.\n   *\n   * @param {Boolean} [passThrough=true]\n   * for unknown options.\n   */\n  passThroughOptions(passThrough = true) {\n    this._passThroughOptions = !!passThrough;\n    if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {\n      throw new Error('passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)');\n    }\n    return this;\n  };\n\n  /**\n    * Whether to store option values as properties on command object,\n    * or store separately (specify false). In both cases the option values can be accessed using .opts().\n    *\n    * @param {boolean} [storeAsProperties=true]\n    * @return {Command} `this` command for chaining\n    */\n\n  storeOptionsAsProperties(storeAsProperties = true) {\n    this._storeOptionsAsProperties = !!storeAsProperties;\n    if (this.options.length) {\n      throw new Error('call .storeOptionsAsProperties() before adding options');\n    }\n    return this;\n  };\n\n  /**\n   * Store option value\n   *\n   * @param {string} key\n   * @param {Object} value\n   * @api private\n   */\n\n  _setOptionValue(key, value) {\n    if (this._storeOptionsAsProperties) {\n      this[key] = value;\n    } else {\n      this._optionValues[key] = value;\n    }\n  };\n\n  /**\n   * Retrieve option value\n   *\n   * @param {string} key\n   * @return {Object} value\n   * @api private\n   */\n\n  _getOptionValue(key) {\n    if (this._storeOptionsAsProperties) {\n      return this[key];\n    }\n    return this._optionValues[key];\n  };\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * Examples:\n   *\n   *      program.parse(process.argv);\n   *      program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions\n   *      program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv] - optional, defaults to process.argv\n   * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron\n   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'\n   * @return {Command} `this` command for chaining\n   */\n\n  parse(argv, parseOptions) {\n    if (argv !== undefined && !Array.isArray(argv)) {\n      throw new Error('first parameter to parse must be array or undefined');\n    }\n    parseOptions = parseOptions || {};\n\n    // Default to using process.argv\n    if (argv === undefined) {\n      argv = process.argv;\n      // @ts-ignore: unknown property\n      if (process.versions && process.versions.electron) {\n        parseOptions.from = 'electron';\n      }\n    }\n    this.rawArgs = argv.slice();\n\n    // make it a little easier for callers by supporting various argv conventions\n    let userArgs;\n    switch (parseOptions.from) {\n      case undefined:\n      case 'node':\n        this._scriptPath = argv[1];\n        userArgs = argv.slice(2);\n        break;\n      case 'electron':\n        // @ts-ignore: unknown property\n        if (process.defaultApp) {\n          this._scriptPath = argv[1];\n          userArgs = argv.slice(2);\n        } else {\n          userArgs = argv.slice(1);\n        }\n        break;\n      case 'user':\n        userArgs = argv.slice(0);\n        break;\n      default:\n        throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);\n    }\n    if (!this._scriptPath && require.main) {\n      this._scriptPath = require.main.filename;\n    }\n\n    // Guess name, used in usage in help.\n    this._name = this._name || (this._scriptPath && path.basename(this._scriptPath, path.extname(this._scriptPath)));\n\n    // Let's go!\n    this._parseCommand([], userArgs);\n\n    return this;\n  };\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * Examples:\n   *\n   *      program.parseAsync(process.argv);\n   *      program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions\n   *      program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv]\n   * @param {Object} [parseOptions]\n   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'\n   * @return {Promise}\n   */\n\n  parseAsync(argv, parseOptions) {\n    this.parse(argv, parseOptions);\n    return Promise.all(this._actionResults).then(() => this);\n  };\n\n  /**\n   * Execute a sub-command executable.\n   *\n   * @api private\n   */\n\n  _executeSubCommand(subcommand, args) {\n    args = args.slice();\n    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.\n    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];\n\n    // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.\n    this._checkForMissingMandatoryOptions();\n\n    // Want the entry script as the reference for command name and directory for searching for other files.\n    let scriptPath = this._scriptPath;\n    // Fallback in case not set, due to how Command created or called.\n    if (!scriptPath && require.main) {\n      scriptPath = require.main.filename;\n    }\n\n    let baseDir;\n    try {\n      const resolvedLink = fs.realpathSync(scriptPath);\n      baseDir = path.dirname(resolvedLink);\n    } catch (e) {\n      baseDir = '.'; // dummy, probably not going to find executable!\n    }\n\n    // name of the subcommand, like `pm-install`\n    let bin = path.basename(scriptPath, path.extname(scriptPath)) + '-' + subcommand._name;\n    if (subcommand._executableFile) {\n      bin = subcommand._executableFile;\n    }\n\n    const localBin = path.join(baseDir, bin);\n    if (fs.existsSync(localBin)) {\n      // prefer local `./<bin>` to bin in the $PATH\n      bin = localBin;\n    } else {\n      // Look for source files.\n      sourceExt.forEach((ext) => {\n        if (fs.existsSync(`${localBin}${ext}`)) {\n          bin = `${localBin}${ext}`;\n        }\n      });\n    }\n    launchWithNode = sourceExt.includes(path.extname(bin));\n\n    let proc;\n    if (process.platform !== 'win32') {\n      if (launchWithNode) {\n        args.unshift(bin);\n        // add executable arguments to spawn\n        args = incrementNodeInspectorPort(process.execArgv).concat(args);\n\n        proc = childProcess.spawn(process.argv[0], args, { stdio: 'inherit' });\n      } else {\n        proc = childProcess.spawn(bin, args, { stdio: 'inherit' });\n      }\n    } else {\n      args.unshift(bin);\n      // add executable arguments to spawn\n      args = incrementNodeInspectorPort(process.execArgv).concat(args);\n      proc = childProcess.spawn(process.execPath, args, { stdio: 'inherit' });\n    }\n\n    const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];\n    signals.forEach((signal) => {\n      // @ts-ignore\n      process.on(signal, () => {\n        if (proc.killed === false && proc.exitCode === null) {\n          proc.kill(signal);\n        }\n      });\n    });\n\n    // By default terminate process when spawned process terminates.\n    // Suppressing the exit if exitCallback defined is a bit messy and of limited use, but does allow process to stay running!\n    const exitCallback = this._exitCallback;\n    if (!exitCallback) {\n      proc.on('close', process.exit.bind(process));\n    } else {\n      proc.on('close', () => {\n        exitCallback(new CommanderError(process.exitCode || 0, 'commander.executeSubCommandAsync', '(close)'));\n      });\n    }\n    proc.on('error', (err) => {\n      // @ts-ignore\n      if (err.code === 'ENOENT') {\n        const executableMissing = `'${bin}' does not exist\n - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead\n - if the default executable name is not suitable, use the executableFile option to supply a custom name`;\n        throw new Error(executableMissing);\n      // @ts-ignore\n      } else if (err.code === 'EACCES') {\n        throw new Error(`'${bin}' not executable`);\n      }\n      if (!exitCallback) {\n        process.exit(1);\n      } else {\n        const wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');\n        wrappedError.nestedError = err;\n        exitCallback(wrappedError);\n      }\n    });\n\n    // Store the reference to the child process\n    this.runningCommand = proc;\n  };\n\n  /**\n   * @api private\n   */\n  _dispatchSubcommand(commandName, operands, unknown) {\n    const subCommand = this._findCommand(commandName);\n    if (!subCommand) this.help({ error: true });\n\n    if (subCommand._executableHandler) {\n      this._executeSubCommand(subCommand, operands.concat(unknown));\n    } else {\n      subCommand._parseCommand(operands, unknown);\n    }\n  };\n\n  /**\n   * Process arguments in context of this command.\n   *\n   * @api private\n   */\n\n  _parseCommand(operands, unknown) {\n    const parsed = this.parseOptions(unknown);\n    operands = operands.concat(parsed.operands);\n    unknown = parsed.unknown;\n    this.args = operands.concat(unknown);\n\n    if (operands && this._findCommand(operands[0])) {\n      this._dispatchSubcommand(operands[0], operands.slice(1), unknown);\n    } else if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {\n      if (operands.length === 1) {\n        this.help();\n      } else {\n        this._dispatchSubcommand(operands[1], [], [this._helpLongFlag]);\n      }\n    } else if (this._defaultCommandName) {\n      outputHelpIfRequested(this, unknown); // Run the help for default command from parent rather than passing to default command\n      this._dispatchSubcommand(this._defaultCommandName, operands, unknown);\n    } else {\n      if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {\n        // probably missing subcommand and no handler, user needs help\n        this.help({ error: true });\n      }\n\n      outputHelpIfRequested(this, parsed.unknown);\n      this._checkForMissingMandatoryOptions();\n\n      // We do not always call this check to avoid masking a \"better\" error, like unknown command.\n      const checkForUnknownOptions = () => {\n        if (parsed.unknown.length > 0) {\n          this.unknownOption(parsed.unknown[0]);\n        }\n      };\n\n      const commandEvent = `command:${this.name()}`;\n      if (this._actionHandler) {\n        checkForUnknownOptions();\n        // Check expected arguments and collect variadic together.\n        const args = this.args.slice();\n        this._args.forEach((arg, i) => {\n          if (arg.required && args[i] == null) {\n            this.missingArgument(arg.name);\n          } else if (arg.variadic) {\n            args[i] = args.splice(i);\n            args.length = Math.min(i + 1, args.length);\n          }\n        });\n        if (args.length > this._args.length) {\n          this._excessArguments(args);\n        }\n\n        this._actionHandler(args);\n        if (this.parent) this.parent.emit(commandEvent, operands, unknown); // legacy\n      } else if (this.parent && this.parent.listenerCount(commandEvent)) {\n        checkForUnknownOptions();\n        this.parent.emit(commandEvent, operands, unknown); // legacy\n      } else if (operands.length) {\n        if (this._findCommand('*')) { // legacy default command\n          this._dispatchSubcommand('*', operands, unknown);\n        } else if (this.listenerCount('command:*')) {\n          // skip option check, emit event for possible misspelling suggestion\n          this.emit('command:*', operands, unknown);\n        } else if (this.commands.length) {\n          this.unknownCommand();\n        } else {\n          checkForUnknownOptions();\n        }\n      } else if (this.commands.length) {\n        // This command has subcommands and nothing hooked up at this level, so display help.\n        this.help({ error: true });\n      } else {\n        checkForUnknownOptions();\n        // fall through for caller to handle after calling .parse()\n      }\n    }\n  };\n\n  /**\n   * Find matching command.\n   *\n   * @api private\n   */\n  _findCommand(name) {\n    if (!name) return undefined;\n    return this.commands.find(cmd => cmd._name === name || cmd._aliases.includes(name));\n  };\n\n  /**\n   * Return an option matching `arg` if any.\n   *\n   * @param {string} arg\n   * @return {Option}\n   * @api private\n   */\n\n  _findOption(arg) {\n    return this.options.find(option => option.is(arg));\n  };\n\n  /**\n   * Display an error message if a mandatory option does not have a value.\n   * Lazy calling after checking for help flags from leaf subcommand.\n   *\n   * @api private\n   */\n\n  _checkForMissingMandatoryOptions() {\n    // Walk up hierarchy so can call in subcommand after checking for displaying help.\n    for (let cmd = this; cmd; cmd = cmd.parent) {\n      cmd.options.forEach((anOption) => {\n        if (anOption.mandatory && (cmd._getOptionValue(anOption.attributeName()) === undefined)) {\n          cmd.missingMandatoryOptionValue(anOption);\n        }\n      });\n    }\n  };\n\n  /**\n   * Parse options from `argv` removing known options,\n   * and return argv split into operands and unknown arguments.\n   *\n   * Examples:\n   *\n   *    argv => operands, unknown\n   *    --known kkk op => [op], []\n   *    op --known kkk => [op], []\n   *    sub --unknown uuu op => [sub], [--unknown uuu op]\n   *    sub -- --unknown uuu op => [sub --unknown uuu op], []\n   *\n   * @param {String[]} argv\n   * @return {{operands: String[], unknown: String[]}}\n   */\n\n  parseOptions(argv) {\n    const operands = []; // operands, not options or values\n    const unknown = []; // first unknown option and remaining unknown args\n    let dest = operands;\n    const args = argv.slice();\n\n    function maybeOption(arg) {\n      return arg.length > 1 && arg[0] === '-';\n    }\n\n    // parse options\n    let activeVariadicOption = null;\n    while (args.length) {\n      const arg = args.shift();\n\n      // literal\n      if (arg === '--') {\n        if (dest === unknown) dest.push(arg);\n        dest.push(...args);\n        break;\n      }\n\n      if (activeVariadicOption && !maybeOption(arg)) {\n        this.emit(`option:${activeVariadicOption.name()}`, arg);\n        continue;\n      }\n      activeVariadicOption = null;\n\n      if (maybeOption(arg)) {\n        const option = this._findOption(arg);\n        // recognised option, call listener to assign value with possible custom processing\n        if (option) {\n          if (option.required) {\n            const value = args.shift();\n            if (value === undefined) this.optionMissingArgument(option);\n            this.emit(`option:${option.name()}`, value);\n          } else if (option.optional) {\n            let value = null;\n            // historical behaviour is optional value is following arg unless an option\n            if (args.length > 0 && !maybeOption(args[0])) {\n              value = args.shift();\n            }\n            this.emit(`option:${option.name()}`, value);\n          } else { // boolean flag\n            this.emit(`option:${option.name()}`);\n          }\n          activeVariadicOption = option.variadic ? option : null;\n          continue;\n        }\n      }\n\n      // Look for combo options following single dash, eat first one if known.\n      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {\n        const option = this._findOption(`-${arg[1]}`);\n        if (option) {\n          if (option.required || (option.optional && this._combineFlagAndOptionalValue)) {\n            // option with value following in same argument\n            this.emit(`option:${option.name()}`, arg.slice(2));\n          } else {\n            // boolean option, emit and put back remainder of arg for further processing\n            this.emit(`option:${option.name()}`);\n            args.unshift(`-${arg.slice(2)}`);\n          }\n          continue;\n        }\n      }\n\n      // Look for known long flag with value, like --foo=bar\n      if (/^--[^=]+=/.test(arg)) {\n        const index = arg.indexOf('=');\n        const option = this._findOption(arg.slice(0, index));\n        if (option && (option.required || option.optional)) {\n          this.emit(`option:${option.name()}`, arg.slice(index + 1));\n          continue;\n        }\n      }\n\n      // Not a recognised option by this command.\n      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.\n\n      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.\n      if (maybeOption(arg)) {\n        dest = unknown;\n      }\n\n      // If using positionalOptions, stop processing our options at subcommand.\n      if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {\n        if (this._findCommand(arg)) {\n          operands.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {\n          operands.push(arg);\n          if (args.length > 0) operands.push(...args);\n          break;\n        } else if (this._defaultCommandName) {\n          unknown.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        }\n      }\n\n      // If using passThroughOptions, stop processing options at first command-argument.\n      if (this._passThroughOptions) {\n        dest.push(arg);\n        if (args.length > 0) dest.push(...args);\n        break;\n      }\n\n      // add arg\n      dest.push(arg);\n    }\n\n    return { operands, unknown };\n  };\n\n  /**\n   * Return an object containing options as key-value pairs\n   *\n   * @return {Object}\n   */\n  opts() {\n    if (this._storeOptionsAsProperties) {\n      // Preserve original behaviour so backwards compatible when still using properties\n      const result = {};\n      const len = this.options.length;\n\n      for (let i = 0; i < len; i++) {\n        const key = this.options[i].attributeName();\n        result[key] = key === this._versionOptionName ? this._version : this[key];\n      }\n      return result;\n    }\n\n    return this._optionValues;\n  };\n\n  /**\n   * Internal bottleneck for handling of parsing errors.\n   *\n   * @api private\n   */\n  _displayError(exitCode, code, message) {\n    this._outputConfiguration.outputError(`${message}\\n`, this._outputConfiguration.writeErr);\n    this._exit(exitCode, code, message);\n  }\n\n  /**\n   * Argument `name` is missing.\n   *\n   * @param {string} name\n   * @api private\n   */\n\n  missingArgument(name) {\n    const message = `error: missing required argument '${name}'`;\n    this._displayError(1, 'commander.missingArgument', message);\n  };\n\n  /**\n   * `Option` is missing an argument.\n   *\n   * @param {Option} option\n   * @api private\n   */\n\n  optionMissingArgument(option) {\n    const message = `error: option '${option.flags}' argument missing`;\n    this._displayError(1, 'commander.optionMissingArgument', message);\n  };\n\n  /**\n   * `Option` does not have a value, and is a mandatory option.\n   *\n   * @param {Option} option\n   * @api private\n   */\n\n  missingMandatoryOptionValue(option) {\n    const message = `error: required option '${option.flags}' not specified`;\n    this._displayError(1, 'commander.missingMandatoryOptionValue', message);\n  };\n\n  /**\n   * Unknown option `flag`.\n   *\n   * @param {string} flag\n   * @api private\n   */\n\n  unknownOption(flag) {\n    if (this._allowUnknownOption) return;\n    const message = `error: unknown option '${flag}'`;\n    this._displayError(1, 'commander.unknownOption', message);\n  };\n\n  /**\n   * Excess arguments, more than expected.\n   *\n   * @param {string[]} receivedArgs\n   * @api private\n   */\n\n  _excessArguments(receivedArgs) {\n    if (this._allowExcessArguments) return;\n\n    const expected = this._args.length;\n    const s = (expected === 1) ? '' : 's';\n    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';\n    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;\n    this._displayError(1, 'commander.excessArguments', message);\n  };\n\n  /**\n   * Unknown command.\n   *\n   * @api private\n   */\n\n  unknownCommand() {\n    const partCommands = [this.name()];\n    for (let parentCmd = this.parent; parentCmd; parentCmd = parentCmd.parent) {\n      partCommands.unshift(parentCmd.name());\n    }\n    const fullCommand = partCommands.join(' ');\n    const message = `error: unknown command '${this.args[0]}'.` +\n      (this._hasHelpOption ? ` See '${fullCommand} ${this._helpLongFlag}'.` : '');\n    this._displayError(1, 'commander.unknownCommand', message);\n  };\n\n  /**\n   * Set the program version to `str`.\n   *\n   * This method auto-registers the \"-V, --version\" flag\n   * which will print the version number when passed.\n   *\n   * You can optionally supply the  flags and description to override the defaults.\n   *\n   * @param {string} str\n   * @param {string} [flags]\n   * @param {string} [description]\n   * @return {this | string} `this` command for chaining, or version string if no arguments\n   */\n\n  version(str, flags, description) {\n    if (str === undefined) return this._version;\n    this._version = str;\n    flags = flags || '-V, --version';\n    description = description || 'output the version number';\n    const versionOption = this.createOption(flags, description);\n    this._versionOptionName = versionOption.attributeName();\n    this.options.push(versionOption);\n    this.on('option:' + versionOption.name(), () => {\n      this._outputConfiguration.writeOut(`${str}\\n`);\n      this._exit(0, 'commander.version', str);\n    });\n    return this;\n  };\n\n  /**\n   * Set the description to `str`.\n   *\n   * @param {string} [str]\n   * @param {Object} [argsDescription]\n   * @return {string|Command}\n   */\n  description(str, argsDescription) {\n    if (str === undefined && argsDescription === undefined) return this._description;\n    this._description = str;\n    this._argsDescription = argsDescription;\n    return this;\n  };\n\n  /**\n   * Set an alias for the command.\n   *\n   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string} [alias]\n   * @return {string|Command}\n   */\n\n  alias(alias) {\n    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility\n\n    let command = this;\n    if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {\n      // assume adding alias for last added executable subcommand, rather than this\n      command = this.commands[this.commands.length - 1];\n    }\n\n    if (alias === command._name) throw new Error('Command alias can\\'t be the same as its name');\n\n    command._aliases.push(alias);\n    return this;\n  };\n\n  /**\n   * Set aliases for the command.\n   *\n   * Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string[]} [aliases]\n   * @return {string[]|Command}\n   */\n\n  aliases(aliases) {\n    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().\n    if (aliases === undefined) return this._aliases;\n\n    aliases.forEach((alias) => this.alias(alias));\n    return this;\n  };\n\n  /**\n   * Set / get the command usage `str`.\n   *\n   * @param {string} [str]\n   * @return {String|Command}\n   */\n\n  usage(str) {\n    if (str === undefined) {\n      if (this._usage) return this._usage;\n\n      const args = this._args.map((arg) => {\n        return humanReadableArgName(arg);\n      });\n      return [].concat(\n        (this.options.length || this._hasHelpOption ? '[options]' : []),\n        (this.commands.length ? '[command]' : []),\n        (this._args.length ? args : [])\n      ).join(' ');\n    }\n\n    this._usage = str;\n    return this;\n  };\n\n  /**\n   * Get or set the name of the command\n   *\n   * @param {string} [str]\n   * @return {string|Command}\n   */\n\n  name(str) {\n    if (str === undefined) return this._name;\n    this._name = str;\n    return this;\n  };\n\n  /**\n   * Return program help documentation.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout\n   * @return {string}\n   */\n\n  helpInformation(contextOptions) {\n    const helper = this.createHelp();\n    if (helper.helpWidth === undefined) {\n      helper.helpWidth = (contextOptions && contextOptions.error) ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();\n    }\n    return helper.formatHelp(this, helper);\n  };\n\n  /**\n   * @api private\n   */\n\n  _getHelpContext(contextOptions) {\n    contextOptions = contextOptions || {};\n    const context = { error: !!contextOptions.error };\n    let write;\n    if (context.error) {\n      write = (arg) => this._outputConfiguration.writeErr(arg);\n    } else {\n      write = (arg) => this._outputConfiguration.writeOut(arg);\n    }\n    context.write = contextOptions.write || write;\n    context.command = this;\n    return context;\n  }\n\n  /**\n   * Output help information for this command.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n  outputHelp(contextOptions) {\n    let deprecatedCallback;\n    if (typeof contextOptions === 'function') {\n      deprecatedCallback = contextOptions;\n      contextOptions = undefined;\n    }\n    const context = this._getHelpContext(contextOptions);\n\n    const groupListeners = [];\n    let command = this;\n    while (command) {\n      groupListeners.push(command); // ordered from current command to root\n      command = command.parent;\n    }\n\n    groupListeners.slice().reverse().forEach(command => command.emit('beforeAllHelp', context));\n    this.emit('beforeHelp', context);\n\n    let helpInformation = this.helpInformation(context);\n    if (deprecatedCallback) {\n      helpInformation = deprecatedCallback(helpInformation);\n      if (typeof helpInformation !== 'string' && !Buffer.isBuffer(helpInformation)) {\n        throw new Error('outputHelp callback must return a string or a Buffer');\n      }\n    }\n    context.write(helpInformation);\n\n    this.emit(this._helpLongFlag); // deprecated\n    this.emit('afterHelp', context);\n    groupListeners.forEach(command => command.emit('afterAllHelp', context));\n  };\n\n  /**\n   * You can pass in flags and a description to override the help\n   * flags and help description for your command. Pass in false to\n   * disable the built-in help option.\n   *\n   * @param {string | boolean} [flags]\n   * @param {string} [description]\n   * @return {Command} `this` command for chaining\n   */\n\n  helpOption(flags, description) {\n    if (typeof flags === 'boolean') {\n      this._hasHelpOption = flags;\n      return this;\n    }\n    this._helpFlags = flags || this._helpFlags;\n    this._helpDescription = description || this._helpDescription;\n\n    const helpFlags = _parseOptionFlags(this._helpFlags);\n    this._helpShortFlag = helpFlags.shortFlag;\n    this._helpLongFlag = helpFlags.longFlag;\n\n    return this;\n  };\n\n  /**\n   * Output help information and exit.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n  help(contextOptions) {\n    this.outputHelp(contextOptions);\n    let exitCode = process.exitCode || 0;\n    if (exitCode === 0 && contextOptions && typeof contextOptions !== 'function' && contextOptions.error) {\n      exitCode = 1;\n    }\n    // message: do not have all displayed text available so only passing placeholder.\n    this._exit(exitCode, 'commander.help', '(outputHelp)');\n  };\n\n  /**\n   * Add additional text to be displayed with the built-in help.\n   *\n   * Position is 'before' or 'after' to affect just this command,\n   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.\n   *\n   * @param {string} position - before or after built-in help\n   * @param {string | Function} text - string to add, or a function returning a string\n   * @return {Command} `this` command for chaining\n   */\n  addHelpText(position, text) {\n    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];\n    if (!allowedValues.includes(position)) {\n      throw new Error(`Unexpected value for position to addHelpText.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n    const helpEvent = `${position}Help`;\n    this.on(helpEvent, (context) => {\n      let helpStr;\n      if (typeof text === 'function') {\n        helpStr = text({ error: context.error, command: context.command });\n      } else {\n        helpStr = text;\n      }\n      // Ignore falsy value when nothing to output.\n      if (helpStr) {\n        context.write(`${helpStr}\\n`);\n      }\n    });\n    return this;\n  }\n};\n\n/**\n * Expose the root command.\n */\n\nexports = module.exports = new Command();\nexports.program = exports; // More explicit access to global command.\n\n/**\n * Expose classes\n */\n\nexports.Command = Command;\nexports.Option = Option;\nexports.CommanderError = CommanderError;\nexports.InvalidOptionArgumentError = InvalidOptionArgumentError;\nexports.Help = Help;\n\n/**\n * Camel-case the given `flag`\n *\n * @param {string} flag\n * @return {string}\n * @api private\n */\n\nfunction camelcase(flag) {\n  return flag.split('-').reduce((str, word) => {\n    return str + word[0].toUpperCase() + word.slice(1);\n  });\n}\n\n/**\n * Output help information if help flags specified\n *\n * @param {Command} cmd - command to output help for\n * @param {Array} args - array of options to search for help flags\n * @api private\n */\n\nfunction outputHelpIfRequested(cmd, args) {\n  const helpOption = cmd._hasHelpOption && args.find(arg => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);\n  if (helpOption) {\n    cmd.outputHelp();\n    // (Do not have all displayed text available so only passing placeholder.)\n    cmd._exit(0, 'commander.helpDisplayed', '(outputHelp)');\n  }\n}\n\n/**\n * Takes an argument and returns its human readable equivalent for help usage.\n *\n * @param {Object} arg\n * @return {string}\n * @api private\n */\n\nfunction humanReadableArgName(arg) {\n  const nameOutput = arg.name + (arg.variadic === true ? '...' : '');\n\n  return arg.required\n    ? '<' + nameOutput + '>'\n    : '[' + nameOutput + ']';\n}\n\n/**\n * Parse the short and long flag out of something like '-m,--mixed <value>'\n *\n * @api private\n */\n\nfunction _parseOptionFlags(flags) {\n  let shortFlag;\n  let longFlag;\n  // Use original very loose parsing to maintain backwards compatibility for now,\n  // which allowed for example unintended `-sw, --short-word` [sic].\n  const flagParts = flags.split(/[ |,]+/);\n  if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1])) shortFlag = flagParts.shift();\n  longFlag = flagParts.shift();\n  // Add support for lone short flag without significantly changing parsing!\n  if (!shortFlag && /^-[^-]$/.test(longFlag)) {\n    shortFlag = longFlag;\n    longFlag = undefined;\n  }\n  return { shortFlag, longFlag };\n}\n\n/**\n * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).\n *\n * @param {string[]} args - array of arguments from node.execArgv\n * @returns {string[]}\n * @api private\n */\n\nfunction incrementNodeInspectorPort(args) {\n  // Testing for these options:\n  //  --inspect[=[host:]port]\n  //  --inspect-brk[=[host:]port]\n  //  --inspect-port=[host:]port\n  return args.map((arg) => {\n    if (!arg.startsWith('--inspect')) {\n      return arg;\n    }\n    let debugOption;\n    let debugHost = '127.0.0.1';\n    let debugPort = '9229';\n    let match;\n    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {\n      // e.g. --inspect\n      debugOption = match[1];\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {\n      debugOption = match[1];\n      if (/^\\d+$/.test(match[3])) {\n        // e.g. --inspect=1234\n        debugPort = match[3];\n      } else {\n        // e.g. --inspect=localhost\n        debugHost = match[3];\n      }\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\\d+)$/)) !== null) {\n      // e.g. --inspect=localhost:1234\n      debugOption = match[1];\n      debugHost = match[3];\n      debugPort = match[4];\n    }\n\n    if (debugOption && debugPort !== '0') {\n      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;\n    }\n    return arg;\n  });\n}\n"],
  "mappings": "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",
  "names": ["cmd", "command"]
}
