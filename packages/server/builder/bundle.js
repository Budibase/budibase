
(function(l, i, v, e) { v = l.createElement(i); v.async = 1; v.src = '//' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; e = l.getElementsByTagName(i)[0]; e.parentNode.insertBefore(v, e)})(document, 'script');
(function (fp, shortid, _, compilerUtil, lunr, safeBuffer) {
    'use strict';

    var ___default = 'default' in _ ? _['default'] : _;
    lunr = lunr && lunr.hasOwnProperty('default') ? lunr['default'] : lunr;

    function noop() { }
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function is_promise(value) {
        return value && typeof value === 'object' && typeof value.then === 'function';
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function validate_store(store, name) {
        if (!store || typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(component, store, callback) {
        const unsub = store.subscribe(callback);
        component.$$.on_destroy.push(unsub.unsubscribe
            ? () => unsub.unsubscribe()
            : unsub);
    }
    function create_slot(definition, ctx, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, fn) {
        return definition[1]
            ? assign({}, assign(ctx.$$scope.ctx, definition[1](fn ? fn(ctx) : {})))
            : ctx.$$scope.ctx;
    }
    function get_slot_changes(definition, ctx, changed, fn) {
        return definition[1]
            ? assign({}, assign(ctx.$$scope.changed || {}, definition[1](fn ? fn(changed) : {})))
            : ctx.$$scope.changed || {};
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function detach_before(after) {
        while (after.previousSibling) {
            after.parentNode.removeChild(after.previousSibling);
        }
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function stop_propagation(fn) {
        return function (event) {
            event.stopPropagation();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else
            node.setAttribute(attribute, value);
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_data(text, data) {
        data = '' + data;
        if (text.data !== data)
            text.data = data;
    }
    function set_style(node, key, value) {
        node.style.setProperty(key, value);
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
    }
    function select_options(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            option.selected = ~value.indexOf(option.__value);
        }
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    function select_multiple_value(select) {
        return [].map.call(select.querySelectorAll(':checked'), option => option.__value);
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error(`Function called outside component initialization`);
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            callbacks.slice().forEach(fn => fn(event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    function flush() {
        const seen_callbacks = new Set();
        do {
            // first, call beforeUpdate functions
            // and update components
            while (dirty_components.length) {
                const component = dirty_components.shift();
                set_current_component(component);
                update(component.$$);
            }
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    callback();
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
    }
    function update($$) {
        if ($$.fragment) {
            $$.update($$.dirty);
            run_all($$.before_update);
            $$.fragment.p($$.dirty, $$.ctx);
            $$.dirty = null;
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }

    function handle_promise(promise, info) {
        const token = info.token = {};
        function update(type, index, key, value) {
            if (info.token !== token)
                return;
            info.resolved = key && { [key]: value };
            const child_ctx = assign(assign({}, info.ctx), info.resolved);
            const block = type && (info.current = type)(child_ctx);
            if (info.block) {
                if (info.blocks) {
                    info.blocks.forEach((block, i) => {
                        if (i !== index && block) {
                            group_outros();
                            transition_out(block, 1, 1, () => {
                                info.blocks[i] = null;
                            });
                            check_outros();
                        }
                    });
                }
                else {
                    info.block.d(1);
                }
                block.c();
                transition_in(block, 1);
                block.m(info.mount(), info.anchor);
                flush();
            }
            info.block = block;
            if (info.blocks)
                info.blocks[index] = block;
        }
        if (is_promise(promise)) {
            promise.then(value => {
                update(info.then, 1, info.value, value);
            }, error => {
                update(info.catch, 2, info.error, error);
            });
            // if we previously had a then/catch block, destroy it
            if (info.current !== info.pending) {
                update(info.pending, 0);
                return true;
            }
        }
        else {
            if (info.current !== info.then) {
                update(info.then, 1, info.value, promise);
                return true;
            }
            info.resolved = { [info.value]: promise };
        }
    }

    function bind(component, name, callback) {
        if (component.$$.props.indexOf(name) === -1)
            return;
        component.$$.bound[name] = callback;
        callback(component.$$.ctx[name]);
    }
    function mount_component(component, target, anchor) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment.m(target, anchor);
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        if (component.$$.fragment) {
            run_all(component.$$.on_destroy);
            component.$$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            component.$$.on_destroy = component.$$.fragment = null;
            component.$$.ctx = {};
        }
    }
    function make_dirty(component, key) {
        if (!component.$$.dirty) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty = blank_object();
        }
        component.$$.dirty[key] = true;
    }
    function init(component, options, instance, create_fragment, not_equal, prop_names) {
        const parent_component = current_component;
        set_current_component(component);
        const props = options.props || {};
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props: prop_names,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            // everything else
            callbacks: blank_object(),
            dirty: null
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, props, (key, value) => {
                if ($$.ctx && not_equal($$.ctx[key], $$.ctx[key] = value)) {
                    if ($$.bound[key])
                        $$.bound[key](value);
                    if (ready)
                        make_dirty(component, key);
                }
            })
            : props;
        $$.update();
        ready = true;
        run_all($$.before_update);
        $$.fragment = create_fragment($$.ctx);
        if (options.target) {
            if (options.hydrate) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment.l(children(options.target));
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor);
            flush();
        }
        set_current_component(parent_component);
    }
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set() {
            // overridden by instance, if it has props
        }
    }
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error(`'target' is a required option`);
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn(`Component was already destroyed`); // eslint-disable-line no-console
            };
        }
    }

    /* src\common\Button.svelte generated by Svelte v3.6.9 */

    const file = "src\\common\\Button.svelte";

    function create_fragment(ctx) {
    	var button, button_class_value, current, dispose;

    	const default_slot_1 = ctx.$$slots.default;
    	const default_slot = create_slot(default_slot_1, ctx, null);

    	return {
    		c: function create() {
    			button = element("button");

    			if (default_slot) default_slot.c();

    			attr(button, "class", button_class_value = "" + ctx.color + " " + ctx.className + " " + ctx.borderClass + " " + (ctx.grouped ? "grouped" : "") + " svelte-7rfkdx");
    			attr(button, "style", ctx.style);
    			add_location(button, file, 14, 0, 260);
    			dispose = listen(button, "click", ctx.click_handler);
    		},

    		l: function claim(nodes) {
    			if (default_slot) default_slot.l(button_nodes);
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);

    			if (default_slot) {
    				default_slot.m(button, null);
    			}

    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (default_slot && default_slot.p && changed.$$scope) {
    				default_slot.p(get_slot_changes(default_slot_1, ctx, changed, null), get_slot_context(default_slot_1, ctx, null));
    			}

    			if ((!current || changed.color || changed.className || changed.borderClass || changed.grouped) && button_class_value !== (button_class_value = "" + ctx.color + " " + ctx.className + " " + ctx.borderClass + " " + (ctx.grouped ? "grouped" : "") + " svelte-7rfkdx")) {
    				attr(button, "class", button_class_value);
    			}

    			if (!current || changed.style) {
    				attr(button, "style", ctx.style);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(button);
    			}

    			if (default_slot) default_slot.d(detaching);
    			dispose();
    		}
    	};
    }

    function instance($$self, $$props, $$invalidate) {
    	let { color = "primary", className = "", style = "", groupPosition = "", grouped = false } = $$props;

    	const writable_props = ['color', 'className', 'style', 'groupPosition', 'grouped'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Button> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$set = $$props => {
    		if ('color' in $$props) $$invalidate('color', color = $$props.color);
    		if ('className' in $$props) $$invalidate('className', className = $$props.className);
    		if ('style' in $$props) $$invalidate('style', style = $$props.style);
    		if ('groupPosition' in $$props) $$invalidate('groupPosition', groupPosition = $$props.groupPosition);
    		if ('grouped' in $$props) $$invalidate('grouped', grouped = $$props.grouped);
    		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
    	};

    	let borderClass;

    	$$self.$$.update = ($$dirty = { grouped: 1 }) => {
    		if ($$dirty.grouped) { $$invalidate('borderClass', borderClass = grouped 
                             ? ""
                             : "border-normal"); }
    	};

    	return {
    		color,
    		className,
    		style,
    		groupPosition,
    		grouped,
    		borderClass,
    		click_handler,
    		$$slots,
    		$$scope
    	};
    }

    class Button extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, ["color", "className", "style", "groupPosition", "grouped"]);
    	}

    	get color() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get groupPosition() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set groupPosition(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get grouped() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set grouped(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const commonPlus = extra => fp.union(['onBegin', 'onComplete', 'onError'])(extra);

    const common = () => commonPlus([]);

    const _events = {
      recordApi: {
        save: commonPlus([
          'onInvalid',
          'onRecordUpdated',
          'onRecordCreated']),
        delete: common(),
        getContext: common(),
        getNew: common(),
        load: common(),
        validate: common(),
        uploadFile: common(),
        downloadFile: common(),
      },
      indexApi: {
        buildIndex: common(),
        listItems: common(),
        delete: common(),
        aggregates: common(),
      },
      collectionApi: {
        getAllowedRecordTypes: common(),
        initialise: common(),
        delete: common(),
      },
      authApi: {
        authenticate: common(),
        authenticateTemporaryAccess: common(),
        createTemporaryAccess: common(),
        createUser: common(),
        enableUser: common(),
        disableUser: common(),
        loadAccessLevels: common(),
        getNewAccessLevel: common(),
        getNewUser: common(),
        getNewUserAuth: common(),
        getUsers: common(),
        saveAccessLevels: common(),
        isAuthorized: common(),
        changeMyPassword: common(),
        setPasswordFromTemporaryCode: common(),
        scorePassword: common(),
        isValidPassword: common(),
        validateUser: common(),
        validateAccessLevels: common(),
        setUserAccessLevels: common(),
      },
      templateApi: {
        saveApplicationHierarchy: common(),
        saveActionsAndTriggers: common(),
      },
      actionsApi: {
        execute: common(),
      },
    };

    const _eventsList = [];

    const makeEvent = (area, method, name) => `${area}:${method}:${name}`;

    for (const areaKey in _events) {
      for (const methodKey in _events[areaKey]) {
        _events[areaKey][methodKey] = fp.reduce((obj, s) => {
          obj[s] = makeEvent(areaKey, methodKey, s);
          return obj;
        },
        {})(_events[areaKey][methodKey]);
      }
    }


    for (const areaKey in _events) {
      for (const methodKey in _events[areaKey]) {
        for (const name in _events[areaKey][methodKey]) {
          _eventsList.push(
            _events[areaKey][methodKey][name],
          );
        }
      }
    }


    const events = _events;

    const eventsList = _eventsList;

    class BadRequestError extends Error {
        constructor(message) {
            super(message);
            this.httpStatusCode = 400;
        }
    }

    class UnauthorisedError extends Error {
        constructor(message) {
            super(message);
            this.httpStatusCode = 401;
        }
    }

    class NotFoundError extends Error {
        constructor(message) {
            super(message);
            this.httpStatusCode = 404;
        }
    }

    const apiWrapper = async (app, eventNamespace, isAuthorized, eventContext, func, ...params) => {
      pushCallStack(app, eventNamespace);

      if (!isAuthorized(app)) {
        handleNotAuthorized(app, eventContext, eventNamespace);
        return;
      }

      const startDate = Date.now();
      const elapsed = () => (Date.now() - startDate);

      try {
        await app.publish(
          eventNamespace.onBegin,
          eventContext,
        );

        const result = await func(...params);

        await publishComplete(app, eventContext, eventNamespace, elapsed, result);
        return result;
      } catch (error) {
        await publishError(app, eventContext, eventNamespace, elapsed, error);
        throw error;
      }
    };

    const apiWrapperSync = (app, eventNamespace, isAuthorized, eventContext, func, ...params) => {
      pushCallStack(app, eventNamespace);

      if (!isAuthorized(app)) {
        handleNotAuthorized(app, eventContext, eventNamespace);
        return;
      }

      const startDate = Date.now();
      const elapsed = () => (Date.now() - startDate);

      try {
        app.publish(
          eventNamespace.onBegin,
          eventContext,
        );

        const result = func(...params);

        publishComplete(app, eventContext, eventNamespace, elapsed, result);
        return result;
      } catch (error) {
        publishError(app, eventContext, eventNamespace, elapsed, error);
        throw error;
      }
    };

    const handleNotAuthorized = (app, eventContext, eventNamespace) => {
      const err = new UnauthorisedError(`Unauthorized: ${eventNamespace}`);
      publishError(app, eventContext, eventNamespace, () => 0, err);
      throw err;
    };

    const pushCallStack = (app, eventNamespace, seedCallId) => {
      const callId = shortid.generate();

      const createCallStack = () => ({
        seedCallId: !fp.isUndefined(seedCallId)
          ? seedCallId
          : callId,
        threadCallId: callId,
        stack: [],
      });

      if (fp.isUndefined(app.calls)) {
        app.calls = createCallStack();
      }

      app.calls.stack.push({
        namespace: eventNamespace,
        callId,
      });
    };

    const popCallStack = (app) => {
      app.calls.stack.pop();
      if (app.calls.stack.length === 0) {
        delete app.calls;
      }
    };

    const publishError = async (app, eventContext, eventNamespace, elapsed, err) => {
      const ctx = fp.cloneDeep(eventContext);
      ctx.error = err;
      ctx.elapsed = elapsed();
      await app.publish(
        eventNamespace.onError,
        ctx,
      );
      popCallStack(app);
    };

    const publishComplete = async (app, eventContext, eventNamespace, elapsed, result) => {
      const endcontext = fp.cloneDeep(eventContext);
      endcontext.result = result;
      endcontext.elapsed = elapsed();
      await app.publish(
        eventNamespace.onComplete,
        endcontext,
      );
      popCallStack(app);
      return result;
    };

    const lockOverlapMilliseconds = 10;

    const getLock = async (app, lockFile, timeoutMilliseconds, maxLockRetries, retryCount = 0) => {
      try {
        const timeout = (await app.getEpochTime())
                + timeoutMilliseconds;

        const lock = {
          timeout,
          key: lockFile,
          totalTimeout: timeoutMilliseconds,
        };

        await app.datastore.createFile(
          lockFile,
          getLockFileContent(
            lock.totalTimeout,
            lock.timeout,
          ),
        );

        return lock;
      } catch (e) {
        if (retryCount == maxLockRetries) { return NO_LOCK; }

        const lock = parseLockFileContent(
          lockFile,
          await app.datastore.loadFile(lockFile),
        );

        const currentEpochTime = await app.getEpochTime();

        if (currentEpochTime < lock.timeout) {
          return NO_LOCK;
        }

        try {
          await app.datastore.deleteFile(lockFile);
        } catch (_) {
          //empty
        }

        await sleepForRetry();

        return await getLock(
          app, lockFile, timeoutMilliseconds,
          maxLockRetries, retryCount + 1,
        );
      }
    };

    const getLockFileContent = (totalTimeout, epochTime) => `${totalTimeout}:${epochTime.toString()}`;

    const parseLockFileContent = (key, content) => $(content, [
      fp.split(':'),
      parts => ({
        totalTimeout: new Number(parts[0]),
        timeout: new Number(parts[1]),
        key,
      }),
    ]);

    const releaseLock = async (app, lock) => {
      const currentEpochTime = await app.getEpochTime();
      // only release if not timedout
      if (currentEpochTime < (lock.timeout - lockOverlapMilliseconds)) {
        try {
          await app.datastore.deleteFile(lock.key);
        } catch (_) {
          //empty
        }
      }
    };

    const NO_LOCK = 'no lock';
    const isNolock = id => id === NO_LOCK;

    const sleepForRetry = () => new Promise(resolve => setTimeout(resolve, lockOverlapMilliseconds));

    // this is the combinator function
    const $$ = (...funcs) => arg => _.flow(funcs)(arg);

    // this is the pipe function
    const $ = (arg, funcs) => $$(...funcs)(arg);

    const keySep = '/';
    const trimKeySep = str => _.trim(str, keySep);
    const splitByKeySep = str => _.split(str, keySep);
    const safeKey = key => _.replace(`${keySep}${trimKeySep(key)}`, `${keySep}${keySep}`, keySep);
    const joinKey = (...strs) => {
      const paramsOrArray = strs.length === 1 & _.isArray(strs[0])
        ? strs[0] : strs;
      return safeKey(_.join(paramsOrArray, keySep));
    };
    const splitKey = $$(trimKeySep, splitByKeySep);
    const getDirFomKey = $$(splitKey, _.dropRight, p => joinKey(...p));
    const getFileFromKey = $$(splitKey, _.takeRight, _.head);

    const configFolder = `${keySep}.config`;
    const fieldDefinitions = joinKey(configFolder, 'fields.json');
    const templateDefinitions = joinKey(configFolder, 'templates.json');
    const appDefinitionFile = joinKey(configFolder, 'appDefinition.json');
    const dirIndex = folderPath => joinKey(configFolder, 'dir', ...splitKey(folderPath), 'dir.idx');
    const getIndexKeyFromFileKey = $$(getDirFomKey, dirIndex);

    const ifExists = (val, exists, notExists) => (_.isUndefined(val)
      ? _.isUndefined(notExists) ? (() => { })() : notExists()
      : exists());

    const getOrDefault = (val, defaultVal) => ifExists(val, () => val, () => defaultVal);

    const not = func => val => !func(val);
    const isDefined = not(_.isUndefined);
    const isNonNull = not(_.isNull);
    const isNotNaN = not(_.isNaN);

    const allTrue = (...funcArgs) => val => _.reduce(funcArgs,
      (result, conditionFunc) => (_.isNull(result) || result == true) && conditionFunc(val),
      null);

    const anyTrue = (...funcArgs) => val => _.reduce(funcArgs,
      (result, conditionFunc) => result == true || conditionFunc(val),
      null);

    const insensitiveEquals = (str1, str2) => str1.trim().toLowerCase() === str2.trim().toLowerCase();

    const isSomething = allTrue(isDefined, isNonNull, isNotNaN);
    const isNothing = not(isSomething);
    const isNothingOrEmpty = v => isNothing(v) || _.isEmpty(v);
    const somethingOrGetDefault = getDefaultFunc => val => (isSomething(val) ? val : getDefaultFunc());
    const somethingOrDefault = (val, defaultVal) => somethingOrGetDefault(_.constant(defaultVal))(val);

    const mapIfSomethingOrDefault = (mapFunc, defaultVal) => val => (isSomething(val) ? mapFunc(val) : defaultVal);

    const mapIfSomethingOrBlank = mapFunc => mapIfSomethingOrDefault(mapFunc, '');

    const none = predicate => collection => !fp.some(predicate)(collection);

    const all = predicate => collection => none(v => !predicate(v))(collection);

    const isNotEmpty = ob => !_.isEmpty(ob);
    const isNonEmptyArray = allTrue(_.isArray, isNotEmpty);
    const isNonEmptyString = allTrue(_.isString, isNotEmpty);
    const tryOr = failFunc => (func, ...args) => {
      try {
        return func.apply(null, ...args);
      } catch (_) {
        return failFunc();
      }
    };

    const tryAwaitOr = failFunc => async (func, ...args) => {
      try {
        return await func.apply(null, ...args);
      } catch (_) {
        return await failFunc();
      }
    };

    const defineError = (func, errorPrefix) => {
      try {
        return func();
      } catch (err) {
        err.message = `${errorPrefix} : ${err.message}`;
        throw err;
      }
    };

    const tryOrIgnore = tryOr(() => { });
    const tryAwaitOrIgnore = tryAwaitOr(async () => { });
    const causesException = (func) => {
      try {
        func();
        return false;
      } catch (e) {
        return true;
      }
    };

    const executesWithoutException = func => !causesException(func);

    const handleErrorWith = returnValInError => tryOr(_.constant(returnValInError));

    const handleErrorWithUndefined = handleErrorWith(undefined);

    const switchCase = (...cases) => (value) => {
      const nextCase = () => _.head(cases)[0](value);
      const nextResult = () => _.head(cases)[1](value);

      if (_.isEmpty(cases)) return; // undefined
      if (nextCase() === true) return nextResult();
      return switchCase(..._.tail(cases))(value);
    };

    const isValue = val1 => val2 => (val1 === val2);
    const isOneOf = (...vals) => val => _.includes(vals, val);
    const defaultCase = _.constant(true);
    const memberMatches = (member, match) => obj => match(obj[member]);


    const StartsWith = searchFor => searchIn => _.startsWith(searchIn, searchFor);

    const contains = val => array => (_.findIndex(array, v => v === val) > -1);

    const getHashCode = (s) => {
      let hash = 0; let i; let char; let
        l;
      if (s.length == 0) return hash;
      for (i = 0, l = s.length; i < l; i++) {
        char = s.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash |= 0; // Convert to 32bit integer
      }

      // converting to string, but dont want a "-" prefixed
      if (hash < 0) { return `n${(hash * -1).toString()}`; }
      return hash.toString();
    };

    // thanks to https://blog.grossman.io/how-to-write-async-await-without-try-catch-blocks-in-javascript/
    const awEx = async (promise) => {
      try {
        const result = await promise;
        return [undefined, result];
      } catch (error) {
        return [error, undefined];
      }
    };

    const isSafeInteger = n => _.isInteger(n)
        && n <= Number.MAX_SAFE_INTEGER
        && n >= 0 - Number.MAX_SAFE_INTEGER;

    const toDateOrNull = s => (_.isNull(s) ? null
      : _.isDate(s) ? s : new Date(s));
    const toBoolOrNull = s => (_.isNull(s) ? null
      : s === 'true' || s === true);
    const toNumberOrNull = s => (_.isNull(s) ? null
      : _.toNumber(s));

    const isArrayOfString = opts => _.isArray(opts) && all(_.isString)(opts);

    const pause = async duration => new Promise(res => setTimeout(res, duration));

    const retry = async (fn, retries, delay, ...args) => {
      try {
        return await fn(...args);
      } catch (err) {
        if (retries > 1) {
          return await pause(delay).then(async () => await retry(fn, (retries - 1), delay, ...args));
        }
        throw err;
      }
    };

    var index = {
      ifExists,
      getOrDefault,
      isDefined,
      isNonNull,
      isNotNaN,
      allTrue,
      isSomething,
      mapIfSomethingOrDefault,
      mapIfSomethingOrBlank,
      configFolder,
      fieldDefinitions,
      isNothing,
      not,
      switchCase,
      defaultCase,
      StartsWith,
      contains,
      templateDefinitions,
      handleErrorWith,
      handleErrorWithUndefined,
      tryOr,
      tryOrIgnore,
      tryAwaitOr,
      tryAwaitOrIgnore,
      dirIndex,
      keySep,
      $,
      $$,
      getDirFomKey,
      getFileFromKey,
      splitKey,
      somethingOrDefault,
      getIndexKeyFromFileKey,
      joinKey,
      somethingOrGetDefault,
      appDefinitionFile,
      isValue,
      all,
      isOneOf,
      memberMatches,
      defineError,
      anyTrue,
      isNonEmptyArray,
      causesException,
      executesWithoutException,
      none,
      getHashCode,
      awEx,
      apiWrapper,
      events,
      eventsList,
      isNothingOrEmpty,
      isSafeInteger,
      toNumber: _.toNumber,
      toDate: toDateOrNull,
      toBool: toBoolOrNull,
      isArrayOfString,
      getLock,
      NO_LOCK,
      isNolock,
      insensitiveEquals,
      pause,
      retry,
    };

    const stringNotEmpty = s => isSomething(s) && s.trim().length > 0;

    const makerule = (field, error, isValid) => ({ field, error, isValid });

    const validationError = (rule, item) => ({ ...rule, item });

    const applyRuleSet = ruleSet => itemToValidate => $(ruleSet, [
      fp.map(applyRule(itemToValidate)),
      fp.filter(isSomething),
    ]);

    const applyRule = itemTovalidate => rule => (rule.isValid(itemTovalidate)
      ? null
      : validationError(rule, itemTovalidate));

    const compileFilter = index => compilerUtil.compileExpression(index.filter);

    const compileMap = index => compilerUtil.compileCode(index.map);

    const indexTypes = { reference: 'reference', ancestor: 'ancestor' };

    const indexRuleSet = [
      makerule('map', 'index has no map function',
        index => isNonEmptyString(index.map)),
      makerule('map', "index's map function does not compile",
        index => !isNonEmptyString(index.map)
                    || executesWithoutException(() => compileMap(index))),
      makerule('filter', "index's filter function does not compile",
        index => !isNonEmptyString(index.filter)
                    || executesWithoutException(() => compileFilter(index))),
      makerule('name', 'must declare a name for index',
        index => isNonEmptyString(index.name)),
      makerule('name', 'there is a duplicate named index on this node',
        index => fp.isEmpty(index.name)
                    || fp.countBy('name')(index.parent().indexes)[index.name] === 1),
      makerule('indexType', 'reference index may only exist on a record node',
        index => isRecord(index.parent())
                      || index.indexType !== indexTypes.reference),
      makerule('indexType', `index type must be one of: ${_.join(', ', _.keys(indexTypes))}`,
        index => fp.includes(index.indexType)(_.keys(indexTypes))),
    ];

    const getFlattenedHierarchy = (appHierarchy, useCached = true) => {
      if (isSomething(appHierarchy.getFlattenedHierarchy) && useCached) { return appHierarchy.getFlattenedHierarchy(); }

      const flattenHierarchy = (currentNode, flattened) => {
        flattened.push(currentNode);
        if ((!currentNode.children
                || currentNode.children.length === 0)
                && (!currentNode.indexes
                || currentNode.indexes.length === 0)
                && (!currentNode.aggregateGroups
                || currentNode.aggregateGroups.length === 0)) {
          return flattened;
        }

        const unionIfAny = l2 => l1 => fp.union(l1)(!l2 ? [] : l2);

        const children = $([], [
          unionIfAny(currentNode.children),
          unionIfAny(currentNode.indexes),
          unionIfAny(currentNode.aggregateGroups),
        ]);

        for (const child of children) {
          flattenHierarchy(child, flattened);
        }
        return flattened;
      };

      appHierarchy.getFlattenedHierarchy = () => flattenHierarchy(appHierarchy, []);
      return appHierarchy.getFlattenedHierarchy();
    };

    const getLastPartInKey = key => fp.last(splitKey(key));

    const getNodesInPath = appHierarchy => key => $(appHierarchy, [
      getFlattenedHierarchy,
      fp.filter(n => new RegExp(`${n.pathRegx()}`).test(key)),
    ]);

    const getExactNodeForPath = appHierarchy => key => $(appHierarchy, [
      getFlattenedHierarchy,
      fp.find(n => new RegExp(`${n.pathRegx()}$`).test(key)),
    ]);

    const hasMatchingAncestor = ancestorPredicate => decendantNode => switchCase(

      [node => isNothing(node.parent()),
        fp.constant(false)],

      [node => ancestorPredicate(node.parent()),
        fp.constant(true)],

      [defaultCase,
        node => hasMatchingAncestor(ancestorPredicate)(node.parent())],

    )(decendantNode);

    const getNode = (appHierarchy, nodeKey) => $(appHierarchy, [
      getFlattenedHierarchy,
      fp.find(n => n.nodeKey() === nodeKey
                      || (isCollectionRecord(n)
                          && n.collectionNodeKey() === nodeKey)),
    ]);

    const getNodeByKeyOrNodeKey = (appHierarchy, keyOrNodeKey) => {
      const nodeByKey = getExactNodeForPath(appHierarchy)(keyOrNodeKey);
      return isNothing(nodeByKey)
        ? getNode(appHierarchy, keyOrNodeKey)
        : nodeByKey;
    };

    const isNode = (appHierarchy, key) => isSomething(getExactNodeForPath(appHierarchy)(key));

    const getActualKeyOfParent = (parentNodeKey, actualChildKey) => $(actualChildKey, [
      splitKey,
      fp.take(splitKey(parentNodeKey).length),
      ks => joinKey(...ks),
    ]);

    const getParentKey = (key) => {
      return $(key, [
        splitKey,
        fp.take(splitKey(key).length - 1),
        joinKey,
      ]);
    };

    const isKeyAncestorOf = ancestorKey => decendantNode => hasMatchingAncestor(p => p.nodeKey() === ancestorKey)(decendantNode);

    const hasNoMatchingAncestors = parentPredicate => node => !hasMatchingAncestor(parentPredicate)(node);

    const findField = (recordNode, fieldName) => fp.find(f => f.name == fieldName)(recordNode.fields);

    const isAncestor = decendant => ancestor => isKeyAncestorOf(ancestor.nodeKey())(decendant);

    const isDecendant = ancestor => decendant => isAncestor(decendant)(ancestor);

    const getRecordNodeId = recordKey => $(recordKey, [
      splitKey,
      fp.last,
      getRecordNodeIdFromId,
    ]);

    const getRecordNodeIdFromId = recordId => $(recordId, [fp.split('-'), fp.first, parseInt]);

    const getRecordNodeById = (hierarchy, recordId) => $(hierarchy, [
      getFlattenedHierarchy,
      fp.find(n => isRecord(n)
                        && n.nodeId === getRecordNodeIdFromId(recordId)),
    ]);

    const recordNodeIdIsAllowed = indexNode => nodeId => indexNode.allowedRecordNodeIds.length === 0
        || fp.includes(nodeId)(indexNode.allowedRecordNodeIds);

    const recordNodeIsAllowed = indexNode => recordNode => recordNodeIdIsAllowed(indexNode)(recordNode.nodeId);

    const getAllowedRecordNodesForIndex = (appHierarchy, indexNode) => {
      const recordNodes = $(appHierarchy, [
        getFlattenedHierarchy,
        fp.filter(isRecord),
      ]);

      if (isGlobalIndex(indexNode)) {
        return $(recordNodes, [
          fp.filter(recordNodeIsAllowed(indexNode)),
        ]);
      }

      if (isAncestorIndex(indexNode)) {
        return $(recordNodes, [
          fp.filter(isDecendant(indexNode.parent())),
          fp.filter(recordNodeIsAllowed(indexNode)),
        ]);
      }

      if (isReferenceIndex(indexNode)) {
        return $(recordNodes, [
          fp.filter(n => fp.some(fieldReversesReferenceToIndex(indexNode))(n.fields)),
        ]);
      }
    };

    const getNodeFromNodeKeyHash = hierarchy => hash => $(hierarchy, [
      getFlattenedHierarchy,
      fp.find(n => getHashCode(n.nodeKey()) === hash),
    ]);

    const isRecord = node => isSomething(node) && node.type === 'record';
    const isSingleRecord = node => isRecord(node) && node.isSingle;
    const isCollectionRecord = node => isRecord(node) && !node.isSingle;
    const isIndex = node => isSomething(node) && node.type === 'index';
    const isaggregateGroup = node => isSomething(node) && node.type === 'aggregateGroup';
    const isShardedIndex = node => isIndex(node) && isNonEmptyString(node.getShardName);
    const isRoot = node => isSomething(node) && node.isRoot();
    const isDecendantOfARecord = hasMatchingAncestor(isRecord);
    const isGlobalIndex = node => isIndex(node) && isRoot(node.parent());
    const isReferenceIndex = node => isIndex(node) && node.indexType === indexTypes.reference;
    const isAncestorIndex = node => isIndex(node) && node.indexType === indexTypes.ancestor;

    const fieldReversesReferenceToNode = node => field => field.type === 'reference'
        && fp.intersection(field.typeOptions.reverseIndexNodeKeys)(fp.map(i => i.nodeKey())(node.indexes))
          .length > 0;

    const fieldReversesReferenceToIndex = indexNode => field => field.type === 'reference'
        && fp.intersection(field.typeOptions.reverseIndexNodeKeys)([indexNode.nodeKey()])
          .length > 0;

    var hierarchy = {
      getLastPartInKey,
      getNodesInPath,
      getExactNodeForPath,
      hasMatchingAncestor,
      getNode,
      getNodeByKeyOrNodeKey,
      isNode,
      getActualKeyOfParent,
      getParentKey,
      isKeyAncestorOf,
      hasNoMatchingAncestors,
      findField,
      isAncestor,
      isDecendant,
      getRecordNodeId,
      getRecordNodeIdFromId,
      getRecordNodeById,
      recordNodeIdIsAllowed,
      recordNodeIsAllowed,
      getAllowedRecordNodesForIndex,
      getNodeFromNodeKeyHash,
      isRecord,
      isCollectionRecord,
      isIndex,
      isaggregateGroup,
      isShardedIndex,
      isRoot,
      isDecendantOfARecord,
      isGlobalIndex,
      isReferenceIndex,
      isAncestorIndex,
      fieldReversesReferenceToNode,
      fieldReversesReferenceToIndex,
      getFlattenedHierarchy,
    };

    const getSafeFieldParser = (tryParse, defaultValueFunctions) => (field, record) => {
      if (_.has(record, field.name)) {
        return getSafeValueParser(tryParse, defaultValueFunctions)(record[field.name]);
      }
      return defaultValueFunctions[field.getUndefinedValue]();
    };

    const getSafeValueParser = (tryParse, defaultValueFunctions) => (value) => {
      const parsed = tryParse(value);
      if (parsed.success) {
        return parsed.value;
      }
      return defaultValueFunctions.default();
    };

    const getNewValue = (tryParse, defaultValueFunctions) => (field) => {
      const getInitialValue = fp.isUndefined(field) || fp.isUndefined(field.getInitialValue)
        ? 'default'
        : field.getInitialValue;

      return _.has(defaultValueFunctions, getInitialValue)
        ? defaultValueFunctions[getInitialValue]()
        : getSafeValueParser(tryParse, defaultValueFunctions)(getInitialValue);
    };

    const typeFunctions = specificFunctions => _.merge({
      value: fp.constant,
      null: fp.constant(null),
    }, specificFunctions);

    const validateTypeConstraints = validationRules => async (field, record, context) => {
      const fieldValue = record[field.name];
      const validateRule = async r => (!await r.isValid(fieldValue, field.typeOptions, context)
        ? r.getMessage(fieldValue, field.typeOptions)
        : '');

      const errors = [];
      for (const r of validationRules) {
        const err = await validateRule(r);
        if (isNotEmpty(err)) errors.push(err);
      }

      return errors;
    };

    const getDefaultOptions = fp.mapValues(v => v.defaultValue);

    const makerule$1 = (isValid, getMessage) => ({ isValid, getMessage });
    const parsedFailed = val => ({ success: false, value: val });
    const parsedSuccess = val => ({ success: true, value: val });
    const getDefaultExport = (name, tryParse, functions, options, validationRules, sampleValue, stringify) => ({
      getNew: getNewValue(tryParse, functions),
      safeParseField: getSafeFieldParser(tryParse, functions),
      safeParseValue: getSafeValueParser(tryParse, functions),
      tryParse,
      name,
      getDefaultOptions: () => getDefaultOptions(fp.cloneDeep(options)),
      optionDefinitions: options,
      validateTypeConstraints: validateTypeConstraints(validationRules),
      sampleValue,
      stringify: val => (val === null || val === undefined
        ? '' : stringify(val)),
      getDefaultValue: functions.default,
    });

    const stringFunctions = typeFunctions({
      default: _.constant(null),
    });

    const stringTryParse = switchCase(
      [_.isString, parsedSuccess],
      [_.isNull, parsedSuccess],
      [defaultCase, v => parsedSuccess(v.toString())],
    );

    const options = {
      maxLength: {
        defaultValue: null,
        isValid: n => n === null || isSafeInteger(n) && n > 0,
        requirementDescription: 'max length must be null (no limit) or a greater than zero integer',
        parse: toNumberOrNull,
      },
      values: {
        defaultValue: null,
        isValid: v => v === null || (isArrayOfString(v) && v.length > 0 && v.length < 10000),
        requirementDescription: "'values' must be null (no values) or an arry of at least one string",
        parse: s => s,
      },
      allowDeclaredValuesOnly: {
        defaultValue: false,
        isValid: _.isBoolean,
        requirementDescription: 'allowDeclaredValuesOnly must be true or false',
        parse: toBoolOrNull,
      },
    };

    const typeConstraints = [
      makerule$1(async (val, opts) => val === null || opts.maxLength === null || val.length <= opts.maxLength,
        (val, opts) => `value exceeds maximum length of ${opts.maxLength}`),
      makerule$1(async (val, opts) => val === null
                               || opts.allowDeclaredValuesOnly === false
                               || _.includes(opts.values, val),
      (val) => `"${val}" does not exist in the list of allowed values`),
    ];

    var string = getDefaultExport(
      'string',
      stringTryParse,
      stringFunctions,
      options,
      typeConstraints,
      'abcde',
      str => str,
    );

    const boolFunctions = typeFunctions({
      default: _.constant(null),
    });

    const boolTryParse = switchCase(
      [_.isBoolean, parsedSuccess],
      [_.isNull, parsedSuccess],
      [isOneOf('true', '1', 'yes', 'on'), () => parsedSuccess(true)],
      [isOneOf('false', '0', 'no', 'off'), () => parsedSuccess(false)],
      [defaultCase, parsedFailed],
    );

    const options$1 = {
      allowNulls: {
        defaultValue: true,
        isValid: _.isBoolean,
        requirementDescription: 'must be a true or false',
        parse: toBoolOrNull,
      },
    };

    const typeConstraints$1 = [
      makerule$1(async (val, opts) => opts.allowNulls === true || val !== null,
        () => 'field cannot be null'),
    ];

    var bool = getDefaultExport(
      'bool', boolTryParse, boolFunctions,
      options$1, typeConstraints$1, true, JSON.stringify,
    );

    const numberFunctions = typeFunctions({
      default: _.constant(null),
    });

    const parseStringtoNumberOrNull = (s) => {
      const num = Number(s);
      return isNaN(num) ? parsedFailed(s) : parsedSuccess(num);
    };

    const numberTryParse = switchCase(
      [_.isNumber, parsedSuccess],
      [_.isString, parseStringtoNumberOrNull],
      [_.isNull, parsedSuccess],
      [defaultCase, parsedFailed],
    );

    const options$2 = {
      maxValue: {
        defaultValue: Number.MAX_SAFE_INTEGER,
        isValid: isSafeInteger,
        requirementDescription: 'must be a valid integer',
        parse: toNumberOrNull,
      },
      minValue: {
        defaultValue: 0 - Number.MAX_SAFE_INTEGER,
        isValid: isSafeInteger,
        requirementDescription: 'must be a valid integer',
        parse: toNumberOrNull,
      },
      decimalPlaces: {
        defaultValue: 0,
        isValid: n => isSafeInteger(n) && n >= 0,
        requirementDescription: 'must be a positive integer',
        parse: toNumberOrNull,
      },
    };

    const getDecimalPlaces = (val) => {
      const splitDecimal = val.toString().split('.');
      if (splitDecimal.length === 1) return 0;
      return splitDecimal[1].length;
    };

    const typeConstraints$2 = [
      makerule$1(async (val, opts) => val === null || opts.minValue === null || val >= opts.minValue,
        (val, opts) => `value (${val.toString()}) must be greater than or equal to ${opts.minValue}`),
      makerule$1(async (val, opts) => val === null || opts.maxValue === null || val <= opts.maxValue,
        (val, opts) => `value (${val.toString()}) must be less than or equal to ${opts.minValue} options`),
      makerule$1(async (val, opts) => val === null || opts.decimalPlaces >= getDecimalPlaces(val),
        (val, opts) => `value (${val.toString()}) must have ${opts.decimalPlaces} decimal places or less`),
    ];

    var number = getDefaultExport(
      'number',
      numberTryParse,
      numberFunctions,
      options$2,
      typeConstraints$2,
      1,
      num => num.toString(),
    );

    const dateFunctions = typeFunctions({
      default: _.constant(null),
      now: () => new Date(),
    });

    const isValidDate = d => d instanceof Date && !isNaN(d);

    const parseStringToDate = s => switchCase(
      [isValidDate, parsedSuccess],
      [defaultCase, parsedFailed],
    )(new Date(s));


    const dateTryParse = switchCase(
      [_.isDate, parsedSuccess],
      [_.isString, parseStringToDate],
      [_.isNull, parsedSuccess],
      [defaultCase, parsedFailed],
    );

    const options$3 = {
      maxValue: {
        defaultValue: new Date(32503680000000),
        isValid: _.isDate,
        requirementDescription: 'must be a valid date',
        parse: toDateOrNull,
      },
      minValue: {
        defaultValue: new Date(-8520336000000),
        isValid: _.isDate,
        requirementDescription: 'must be a valid date',
        parse: toDateOrNull,
      },
    };

    const typeConstraints$3 = [
      makerule$1(async (val, opts) => val === null || opts.minValue === null || val >= opts.minValue,
        (val, opts) => `value (${val.toString()}) must be greater than or equal to ${opts.minValue}`),
      makerule$1(async (val, opts) => val === null || opts.maxValue === null || val <= opts.maxValue,
        (val, opts) => `value (${val.toString()}) must be less than or equal to ${opts.minValue} options`),
    ];

    var datetime = getDefaultExport(
      'datetime',
      dateTryParse,
      dateFunctions,
      options$3,
      typeConstraints$3,
      new Date(1984, 4, 1),
      date => JSON.stringify(date).replace(new RegExp('"', 'g'), ''),
    );

    const arrayFunctions = () => typeFunctions({
      default: _.constant([]),
    });

    const mapToParsedArrary = type => $$(
      fp.map(i => type.safeParseValue(i)),
      parsedSuccess,
    );

    const arrayTryParse = type => switchCase(
      [_.isArray, mapToParsedArrary(type)],
      [defaultCase, parsedFailed],
    );

    const typeName = type => `array<${type}>`;


    const options$4 = {
      maxLength: {
        defaultValue: 10000,
        isValid: isSafeInteger,
        requirementDescription: 'must be a positive integer',
        parse: toNumberOrNull,
      },
      minLength: {
        defaultValue: 0,
        isValid: n => isSafeInteger(n) && n >= 0,
        requirementDescription: 'must be a positive integer',
        parse: toNumberOrNull,
      },
    };

    const typeConstraints$4 = [
      makerule$1(async (val, opts) => val === null || val.length >= opts.minLength,
        (val, opts) => `must choose ${opts.minLength} or more options`),
      makerule$1(async (val, opts) => val === null || val.length <= opts.maxLength,
        (val, opts) => `cannot choose more than ${opts.maxLength} options`),
    ];

    var array = type => getDefaultExport(
      typeName(type.name),
      arrayTryParse(type),
      arrayFunctions(),
      options$4,
      typeConstraints$4,
      [type.sampleValue],
      JSON.stringify,
    );

    const referenceNothing = () => ({ key: '' });

    const referenceFunctions = typeFunctions({
      default: referenceNothing,
    });

    const hasStringValue = (ob, path) => _.has(ob, path)
        && _.isString(ob[path]);

    const isObjectWithKey = v => _.isObjectLike(v)
        && hasStringValue(v, 'key');

    const tryParseFromString = s => {

      try {
        const asObj = JSON.parse(s);
        if(isObjectWithKey) {
          return parsedSuccess(asObj);
        }
      }
      catch(_) {
        // EMPTY
      }

      return parsedFailed(s);
    };

    const referenceTryParse = v => switchCase(
      [isObjectWithKey, parsedSuccess],
      [_.isString, tryParseFromString],
      [_.isNull, () => parsedSuccess(referenceNothing())],
      [defaultCase, parsedFailed],
    )(v);

    const options$5 = {
      indexNodeKey: {
        defaultValue: null,
        isValid: isNonEmptyString,
        requirementDescription: 'must be a non-empty string',
        parse: s => s,
      },
      displayValue: {
        defaultValue: '',
        isValid: isNonEmptyString,
        requirementDescription: 'must be a non-empty string',
        parse: s => s,
      },
      reverseIndexNodeKeys: {
        defaultValue: null,
        isValid: v => isArrayOfString(v) && v.length > 0,
        requirementDescription: 'must be a non-empty array of strings',
        parse: s => s,
      },
    };

    const isEmptyString = s => _.isString(s) && _.isEmpty(s);

    const ensureReferenceExists = async (val, opts, context) => isEmptyString(val.key)
        || await context.referenceExists(opts, val.key);

    const typeConstraints$5 = [
      makerule$1(
        ensureReferenceExists,
        (val, opts) => `"${val[opts.displayValue]}" does not exist in options list (key: ${val.key})`,
      ),
    ];

    var reference = getDefaultExport(
      'reference',
      referenceTryParse,
      referenceFunctions,
      options$5,
      typeConstraints$5,
      { key: 'key', value: 'value' },
      JSON.stringify,
    );

    const illegalCharacters = '*?\\/:<>|\0\b\f\v';

    const isLegalFilename = (filePath) => {
      const fn = fileName(filePath);
      return fn.length <= 255
        && fp.intersection(fn.split(''))(illegalCharacters.split('')).length === 0
        && none(f => f === '..')(splitKey(filePath));
    };

    const fileNothing = () => ({ relativePath: '', size: 0 });

    const fileFunctions = typeFunctions({
      default: fileNothing,
    });

    const fileTryParse = v => switchCase(
      [isValidFile, parsedSuccess],
      [fp.isNull, () => parsedSuccess(fileNothing())],
      [defaultCase, parsedFailed],
    )(v);

    const fileName = filePath => $(filePath, [
      splitKey,
      fp.last,
    ]);

    const isValidFile = f => !fp.isNull(f)
        && fp.has('relativePath')(f) && fp.has('size')(f)
        && fp.isNumber(f.size)
        && fp.isString(f.relativePath)
        && isLegalFilename(f.relativePath);

    const options$6 = {};

    const typeConstraints$6 = [];

    var file$1 = getDefaultExport(
      'file',
      fileTryParse,
      fileFunctions,
      options$6,
      typeConstraints$6,
      { relativePath: 'some_file.jpg', size: 1000 },
      JSON.stringify,
    );

    const allTypes = () => {
      const basicTypes = {
        string, number, datetime, bool, reference, file: file$1,
      };

      const arrays = $(basicTypes, [
        _.keys,
        fp.map((k) => {
          const kvType = {};
          const concreteArray = array(basicTypes[k]);
          kvType[concreteArray.name] = concreteArray;
          return kvType;
        }),
        types => _.assign({}, ...types),
      ]);

      return _.merge({}, basicTypes, arrays);
    };


    const all$1 = allTypes();

    const getType = (typeName) => {
      if (!_.has(all$1, typeName)) throw new BadRequestError(`Do not recognise type ${typeName}`);
      return all$1[typeName];
    };

    const getDefaultOptions$1 = type => getType(type).getDefaultOptions();

    // 5 minutes
    const tempCodeExpiryLength = 5 * 60 * 1000;

    const AUTH_FOLDER = '/.auth';
    const USERS_LIST_FILE = joinKey(AUTH_FOLDER, 'users.json');
    const userAuthFile = username => joinKey(AUTH_FOLDER, `auth_${username}.json`);
    const USERS_LOCK_FILE = joinKey(AUTH_FOLDER, 'users_lock');
    const ACCESS_LEVELS_FILE = joinKey(AUTH_FOLDER, 'access_levels.json');
    const ACCESS_LEVELS_LOCK_FILE = joinKey(AUTH_FOLDER, 'access_levels_lock');

    const permissionTypes = {
      CREATE_RECORD: 'create record',
      UPDATE_RECORD: 'update record',
      READ_RECORD: 'read record',
      DELETE_RECORD: 'delete record',
      READ_INDEX: 'read index',
      MANAGE_INDEX: 'manage index',
      MANAGE_COLLECTION: 'manage collection',
      WRITE_TEMPLATES: 'write templates',
      CREATE_USER: 'create user',
      SET_PASSWORD: 'set password',
      CREATE_TEMPORARY_ACCESS: 'create temporary access',
      ENABLE_DISABLE_USER: 'enable or disable user',
      WRITE_ACCESS_LEVELS: 'write access levels',
      LIST_USERS: 'list users',
      LIST_ACCESS_LEVELS: 'list access levels',
      EXECUTE_ACTION: 'execute action',
      SET_USER_ACCESS_LEVELS: 'set user access levels',
    };

    const getUserByName = (users, name) => $(users, [
      fp.find(u => u.name.toLowerCase() === name.toLowerCase()),
    ]);

    const stripUserOfSensitiveStuff = (user) => {
      const stripped = fp.clone(user);
      delete stripped.tempCode;
      return stripped;
    };

    const parseTemporaryCode = fullCode => $(fullCode, [
      fp.split(':'),
      parts => ({
        id: parts[1],
        code: parts[2],
      }),
    ]);

    const isAuthorized = app => (permissionType, resourceKey) => apiWrapperSync(
      app,
      events.authApi.isAuthorized,
      alwaysAuthorized,
      { resourceKey, permissionType },
      _isAuthorized, app, permissionType, resourceKey,
    );

    const _isAuthorized = (app, permissionType, resourceKey) => {
      if (!app.user) {
        return false;
      }

      const validType = $(permissionTypes, [
        fp.values,
        fp.includes(permissionType),
      ]);

      if (!validType) {
        return false;
      }

      const permMatchesResource = (userperm) => {
        const nodeKey = isNothing(resourceKey)
          ? null
          : isNode(app.hierarchy, resourceKey)
            ? getNodeByKeyOrNodeKey(
              app.hierarchy, resourceKey,
            ).nodeKey()
            : resourceKey;

        return (userperm.type === permissionType)
            && (
              isNothing(resourceKey)
                || nodeKey === userperm.nodeKey
            );
      };

      return $(app.user.permissions, [
        fp.some(permMatchesResource),
      ]);
    };

    const nodePermission = type => ({
      add: (nodeKey, accessLevel) => accessLevel.permissions.push({ type, nodeKey }),
      isAuthorized: resourceKey => app => isAuthorized(app)(type, resourceKey),
      isNode: true,
      get: nodeKey => ({ type, nodeKey }),
    });

    const staticPermission = type => ({
      add: accessLevel => accessLevel.permissions.push({ type }),
      isAuthorized: app => isAuthorized(app)(type),
      isNode: false,
      get: () => ({ type }),
    });

    const createRecord = nodePermission(permissionTypes.CREATE_RECORD);

    const updateRecord = nodePermission(permissionTypes.UPDATE_RECORD);

    const deleteRecord = nodePermission(permissionTypes.DELETE_RECORD);

    const readRecord = nodePermission(permissionTypes.READ_RECORD);

    const writeTemplates = staticPermission(permissionTypes.WRITE_TEMPLATES);

    const createUser = staticPermission(permissionTypes.CREATE_USER);

    const setPassword = staticPermission(permissionTypes.SET_PASSWORD);

    const readIndex = nodePermission(permissionTypes.READ_INDEX);

    const manageIndex = staticPermission(permissionTypes.MANAGE_INDEX);

    const manageCollection = staticPermission(permissionTypes.MANAGE_COLLECTION);

    const createTemporaryAccess = staticPermission(permissionTypes.CREATE_TEMPORARY_ACCESS);

    const enableDisableUser = staticPermission(permissionTypes.ENABLE_DISABLE_USER);

    const writeAccessLevels = staticPermission(permissionTypes.WRITE_ACCESS_LEVELS);

    const listUsers = staticPermission(permissionTypes.LIST_USERS);

    const listAccessLevels = staticPermission(permissionTypes.LIST_ACCESS_LEVELS);

    const setUserAccessLevels = staticPermission(permissionTypes.SET_USER_ACCESS_LEVELS);

    const executeAction = nodePermission(permissionTypes.EXECUTE_ACTION);

    const alwaysAuthorized = () => true;

    const permission = {
      createRecord,
      updateRecord,
      deleteRecord,
      readRecord,
      writeTemplates,
      createUser,
      setPassword,
      readIndex,
      createTemporaryAccess,
      enableDisableUser,
      writeAccessLevels,
      listUsers,
      listAccessLevels,
      manageIndex,
      manageCollection,
      executeAction,
      setUserAccessLevels,
    };

    var global$1 = (typeof global !== "undefined" ? global :
                typeof self !== "undefined" ? self :
                typeof window !== "undefined" ? window : {});

    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
    var inited = false;
    function init$1 () {
      inited = true;
      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }

      revLookup['-'.charCodeAt(0)] = 62;
      revLookup['_'.charCodeAt(0)] = 63;
    }

    function toByteArray (b64) {
      if (!inited) {
        init$1();
      }
      var i, j, l, tmp, placeHolders, arr;
      var len = b64.length;

      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
      }

      // the number of equal signs (place holders)
      // if there are two placeholders, than the two characters before it
      // represent one byte
      // if there is only one, then the three characters before it represent 2 bytes
      // this is just a cheap hack to not do indexOf twice
      placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

      // base64 is 4/3 + up to two characters of the original data
      arr = new Arr(len * 3 / 4 - placeHolders);

      // if there are placeholders, only get up to the last complete 4 chars
      l = placeHolders > 0 ? len - 4 : len;

      var L = 0;

      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
        arr[L++] = (tmp >> 16) & 0xFF;
        arr[L++] = (tmp >> 8) & 0xFF;
        arr[L++] = tmp & 0xFF;
      }

      if (placeHolders === 2) {
        tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
        arr[L++] = tmp & 0xFF;
      } else if (placeHolders === 1) {
        tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
        arr[L++] = (tmp >> 8) & 0xFF;
        arr[L++] = tmp & 0xFF;
      }

      return arr
    }

    function tripletToBase64 (num) {
      return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
    }

    function encodeChunk (uint8, start, end) {
      var tmp;
      var output = [];
      for (var i = start; i < end; i += 3) {
        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
        output.push(tripletToBase64(tmp));
      }
      return output.join('')
    }

    function fromByteArray (uint8) {
      if (!inited) {
        init$1();
      }
      var tmp;
      var len = uint8.length;
      var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
      var output = '';
      var parts = [];
      var maxChunkLength = 16383; // must be multiple of 3

      // go through the array every three bytes, we'll deal with trailing stuff later
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
      }

      // pad the end with zeros, but make sure to not forget the extra bytes
      if (extraBytes === 1) {
        tmp = uint8[len - 1];
        output += lookup[tmp >> 2];
        output += lookup[(tmp << 4) & 0x3F];
        output += '==';
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
        output += lookup[tmp >> 10];
        output += lookup[(tmp >> 4) & 0x3F];
        output += lookup[(tmp << 2) & 0x3F];
        output += '=';
      }

      parts.push(output);

      return parts.join('')
    }

    function read (buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? (nBytes - 1) : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];

      i += d;

      e = s & ((1 << (-nBits)) - 1);
      s >>= (-nBits);
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      m = e & ((1 << (-nBits)) - 1);
      e >>= (-nBits);
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity)
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    }

    function write (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
      var i = isLE ? 0 : (nBytes - 1);
      var d = isLE ? 1 : -1;
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

      value = Math.abs(value);

      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }

        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }

      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

      e = (e << mLen) | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

      buffer[offset + i - d] |= s * 128;
    }

    var toString = {}.toString;

    var isArray = Array.isArray || function (arr) {
      return toString.call(arr) == '[object Array]';
    };

    var INSPECT_MAX_BYTES = 50;

    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Use Object implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * Due to various browser bugs, sometimes the Object implementation will be used even
     * when the browser supports typed arrays.
     *
     * Note:
     *
     *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
     *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
     *
     *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
     *
     *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
     *     incorrect length in some situations.

     * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
     * get the Object implementation, which is slower but behaves correctly.
     */
    Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
      ? global$1.TYPED_ARRAY_SUPPORT
      : true;

    function kMaxLength () {
      return Buffer.TYPED_ARRAY_SUPPORT
        ? 0x7fffffff
        : 0x3fffffff
    }

    function createBuffer (that, length) {
      if (kMaxLength() < length) {
        throw new RangeError('Invalid typed array length')
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = new Uint8Array(length);
        that.__proto__ = Buffer.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        if (that === null) {
          that = new Buffer(length);
        }
        that.length = length;
      }

      return that
    }

    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */

    function Buffer (arg, encodingOrOffset, length) {
      if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
        return new Buffer(arg, encodingOrOffset, length)
      }

      // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new Error(
            'If encoding is specified then the first argument must be a string'
          )
        }
        return allocUnsafe(this, arg)
      }
      return from(this, arg, encodingOrOffset, length)
    }

    Buffer.poolSize = 8192; // not used by this implementation

    // TODO: Legacy, not needed anymore. Remove in next major version.
    Buffer._augment = function (arr) {
      arr.__proto__ = Buffer.prototype;
      return arr
    };

    function from (that, value, encodingOrOffset, length) {
      if (typeof value === 'number') {
        throw new TypeError('"value" argument must not be a number')
      }

      if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
        return fromArrayBuffer(that, value, encodingOrOffset, length)
      }

      if (typeof value === 'string') {
        return fromString(that, value, encodingOrOffset)
      }

      return fromObject(that, value)
    }

    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/
    Buffer.from = function (value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length)
    };

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      Buffer.prototype.__proto__ = Uint8Array.prototype;
      Buffer.__proto__ = Uint8Array;
    }

    function assertSize (size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be a number')
      } else if (size < 0) {
        throw new RangeError('"size" argument must not be negative')
      }
    }

    function alloc (that, size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(that, size)
      }
      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpretted as a start offset.
        return typeof encoding === 'string'
          ? createBuffer(that, size).fill(fill, encoding)
          : createBuffer(that, size).fill(fill)
      }
      return createBuffer(that, size)
    }

    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/
    Buffer.alloc = function (size, fill, encoding) {
      return alloc(null, size, fill, encoding)
    };

    function allocUnsafe (that, size) {
      assertSize(size);
      that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT) {
        for (var i = 0; i < size; ++i) {
          that[i] = 0;
        }
      }
      return that
    }

    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */
    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(null, size)
    };
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */
    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(null, size)
    };

    function fromString (that, string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
      }

      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding')
      }

      var length = byteLength(string, encoding) | 0;
      that = createBuffer(that, length);

      var actual = that.write(string, encoding);

      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        that = that.slice(0, actual);
      }

      return that
    }

    function fromArrayLike (that, array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      that = createBuffer(that, length);
      for (var i = 0; i < length; i += 1) {
        that[i] = array[i] & 255;
      }
      return that
    }

    function fromArrayBuffer (that, array, byteOffset, length) {
      array.byteLength; // this throws if `array` is not a valid ArrayBuffer

      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('\'offset\' is out of bounds')
      }

      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('\'length\' is out of bounds')
      }

      if (byteOffset === undefined && length === undefined) {
        array = new Uint8Array(array);
      } else if (length === undefined) {
        array = new Uint8Array(array, byteOffset);
      } else {
        array = new Uint8Array(array, byteOffset, length);
      }

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = array;
        that.__proto__ = Buffer.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        that = fromArrayLike(that, array);
      }
      return that
    }

    function fromObject (that, obj) {
      if (internalIsBuffer(obj)) {
        var len = checked(obj.length) | 0;
        that = createBuffer(that, len);

        if (that.length === 0) {
          return that
        }

        obj.copy(that, 0, 0, len);
        return that
      }

      if (obj) {
        if ((typeof ArrayBuffer !== 'undefined' &&
            obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
          if (typeof obj.length !== 'number' || isnan(obj.length)) {
            return createBuffer(that, 0)
          }
          return fromArrayLike(that, obj)
        }

        if (obj.type === 'Buffer' && isArray(obj.data)) {
          return fromArrayLike(that, obj.data)
        }
      }

      throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
    }

    function checked (length) {
      // Note: cannot use `length < kMaxLength()` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= kMaxLength()) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                             'size: 0x' + kMaxLength().toString(16) + ' bytes')
      }
      return length | 0
    }
    Buffer.isBuffer = isBuffer;
    function internalIsBuffer (b) {
      return !!(b != null && b._isBuffer)
    }

    Buffer.compare = function compare (a, b) {
      if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
        throw new TypeError('Arguments must be Buffers')
      }

      if (a === b) return 0

      var x = a.length;
      var y = b.length;

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    Buffer.isEncoding = function isEncoding (encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true
        default:
          return false
      }
    };

    Buffer.concat = function concat (list, length) {
      if (!isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }

      if (list.length === 0) {
        return Buffer.alloc(0)
      }

      var i;
      if (length === undefined) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }

      var buffer = Buffer.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer
    };

    function byteLength (string, encoding) {
      if (internalIsBuffer(string)) {
        return string.length
      }
      if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
          (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength
      }
      if (typeof string !== 'string') {
        string = '' + string;
      }

      var len = string.length;
      if (len === 0) return 0

      // Use a for loop to avoid recursion
      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len
          case 'utf8':
          case 'utf-8':
          case undefined:
            return utf8ToBytes(string).length
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2
          case 'hex':
            return len >>> 1
          case 'base64':
            return base64ToBytes(string).length
          default:
            if (loweredCase) return utf8ToBytes(string).length // assume utf8
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.byteLength = byteLength;

    function slowToString (encoding, start, end) {
      var loweredCase = false;

      // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.

      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
      if (start === undefined || start < 0) {
        start = 0;
      }
      // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.
      if (start > this.length) {
        return ''
      }

      if (end === undefined || end > this.length) {
        end = this.length;
      }

      if (end <= 0) {
        return ''
      }

      // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
      end >>>= 0;
      start >>>= 0;

      if (end <= start) {
        return ''
      }

      if (!encoding) encoding = 'utf8';

      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end)

          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end)

          case 'ascii':
            return asciiSlice(this, start, end)

          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end)

          case 'base64':
            return base64Slice(this, start, end)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
      }
    }

    // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
    // Buffer instances.
    Buffer.prototype._isBuffer = true;

    function swap (b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }

    Buffer.prototype.swap16 = function swap16 () {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits')
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this
    };

    Buffer.prototype.swap32 = function swap32 () {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits')
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this
    };

    Buffer.prototype.swap64 = function swap64 () {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits')
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this
    };

    Buffer.prototype.toString = function toString () {
      var length = this.length | 0;
      if (length === 0) return ''
      if (arguments.length === 0) return utf8Slice(this, 0, length)
      return slowToString.apply(this, arguments)
    };

    Buffer.prototype.equals = function equals (b) {
      if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
      if (this === b) return true
      return Buffer.compare(this, b) === 0
    };

    Buffer.prototype.inspect = function inspect () {
      var str = '';
      var max = INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
        if (this.length > max) str += ' ... ';
      }
      return '<Buffer ' + str + '>'
    };

    Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError('Argument must be a Buffer')
      }

      if (start === undefined) {
        start = 0;
      }
      if (end === undefined) {
        end = target ? target.length : 0;
      }
      if (thisStart === undefined) {
        thisStart = 0;
      }
      if (thisEnd === undefined) {
        thisEnd = this.length;
      }

      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index')
      }

      if (thisStart >= thisEnd && start >= end) {
        return 0
      }
      if (thisStart >= thisEnd) {
        return -1
      }
      if (start >= end) {
        return 1
      }

      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;

      if (this === target) return 0

      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);

      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);

      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf
    function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1

      // Normalize byteOffset
      if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
      }
      byteOffset = +byteOffset;  // Coerce to Number.
      if (isNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : (buffer.length - 1);
      }

      // Normalize byteOffset: negative offsets start from the end of the buffer
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1
      }

      // Normalize val
      if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
      }

      // Finally, search either indexOf (if dir is true) or lastIndexOf
      if (internalIsBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
      } else if (typeof val === 'number') {
        val = val & 0xFF; // Search for a byte value [0-255]
        if (Buffer.TYPED_ARRAY_SUPPORT &&
            typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
          }
        }
        return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
      }

      throw new TypeError('val must be string, number or Buffer')
    }

    function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;

      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' ||
            encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }

      function read (buf, i) {
        if (indexSize === 1) {
          return buf[i]
        } else {
          return buf.readUInt16BE(i * indexSize)
        }
      }

      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break
            }
          }
          if (found) return i
        }
      }

      return -1
    }

    Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1
    };

    Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
    };

    Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
    };

    function hexWrite (buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }

      // must be an even number of digits
      var strLen = string.length;
      if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (isNaN(parsed)) return i
        buf[offset + i] = parsed;
      }
      return i
    }

    function utf8Write (buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
    }

    function asciiWrite (buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length)
    }

    function latin1Write (buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length)
    }

    function base64Write (buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length)
    }

    function ucs2Write (buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
    }

    Buffer.prototype.write = function write (string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
      // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
      // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === undefined) encoding = 'utf8';
        } else {
          encoding = length;
          length = undefined;
        }
      // legacy write(string, encoding, offset, length) - remove in v0.13
      } else {
        throw new Error(
          'Buffer.write(string, encoding, offset[, length]) is no longer supported'
        )
      }

      var remaining = this.length - offset;
      if (length === undefined || length > remaining) length = remaining;

      if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds')
      }

      if (!encoding) encoding = 'utf8';

      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length)

          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length)

          case 'ascii':
            return asciiWrite(this, string, offset, length)

          case 'latin1':
          case 'binary':
            return latin1Write(this, string, offset, length)

          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };

    Buffer.prototype.toJSON = function toJSON () {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    };

    function base64Slice (buf, start, end) {
      if (start === 0 && end === buf.length) {
        return fromByteArray(buf)
      } else {
        return fromByteArray(buf.slice(start, end))
      }
    }

    function utf8Slice (buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];

      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = (firstByte > 0xEF) ? 4
          : (firstByte > 0xDF) ? 3
          : (firstByte > 0xBF) ? 2
          : 1;

        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;

          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte;
              }
              break
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }

        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD;
          bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000;
          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }

        res.push(codePoint);
        i += bytesPerSequence;
      }

      return decodeCodePointsArray(res)
    }

    // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety
    var MAX_ARGUMENTS_LENGTH = 0x1000;

    function decodeCodePointsArray (codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
      }

      // Decode in chunks to avoid "call stack size exceeded".
      var res = '';
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res
    }

    function asciiSlice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
      }
      return ret
    }

    function latin1Slice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret
    }

    function hexSlice (buf, start, end) {
      var len = buf.length;

      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;

      var out = '';
      for (var i = start; i < end; ++i) {
        out += toHex(buf[i]);
      }
      return out
    }

    function utf16leSlice (buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = '';
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res
    }

    Buffer.prototype.slice = function slice (start, end) {
      var len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;

      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }

      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }

      if (end < start) end = start;

      var newBuf;
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer(sliceLen, undefined);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }

      return newBuf
    };

    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */
    function checkOffset (offset, ext, length) {
      if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
    }

    Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      return val
    };

    Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }

      var val = this[offset + --byteLength];
      var mul = 1;
      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul;
      }

      return val
    };

    Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset]
    };

    Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | (this[offset + 1] << 8)
    };

    Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return (this[offset] << 8) | this[offset + 1]
    };

    Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return ((this[offset]) |
          (this[offset + 1] << 8) |
          (this[offset + 2] << 16)) +
          (this[offset + 3] * 0x1000000)
    };

    Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] * 0x1000000) +
        ((this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        this[offset + 3])
    };

    Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var i = byteLength;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 0x80)) return (this[offset])
      return ((0xff - this[offset] + 1) * -1)
    };

    Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | (this[offset + 1] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | (this[offset] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16) |
        (this[offset + 3] << 24)
    };

    Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] << 24) |
        (this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        (this[offset + 3])
    };

    Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return read(this, offset, true, 23, 4)
    };

    Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return read(this, offset, false, 23, 4)
    };

    Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return read(this, offset, true, 52, 8)
    };

    Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return read(this, offset, false, 52, 8)
    };

    function checkInt (buf, value, offset, ext, max, min) {
      if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
    }

    Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var mul = 1;
      var i = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var i = byteLength - 1;
      var mul = 1;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      this[offset] = (value & 0xff);
      return offset + 1
    };

    function objectWriteUInt16 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffff + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
        buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
          (littleEndian ? i : 1 - i) * 8;
      }
    }

    Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2
    };

    Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8);
        this[offset + 1] = (value & 0xff);
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2
    };

    function objectWriteUInt32 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffffffff + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
        buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
      }
    }

    Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = (value >>> 24);
        this[offset + 2] = (value >>> 16);
        this[offset + 1] = (value >>> 8);
        this[offset] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4
    };

    Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24);
        this[offset + 1] = (value >>> 16);
        this[offset + 2] = (value >>> 8);
        this[offset + 3] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4
    };

    Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = byteLength - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      if (value < 0) value = 0xff + value + 1;
      this[offset] = (value & 0xff);
      return offset + 1
    };

    Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2
    };

    Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8);
        this[offset + 1] = (value & 0xff);
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2
    };

    Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
        this[offset + 2] = (value >>> 16);
        this[offset + 3] = (value >>> 24);
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4
    };

    Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (value < 0) value = 0xffffffff + value + 1;
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24);
        this[offset + 1] = (value >>> 16);
        this[offset + 2] = (value >>> 8);
        this[offset + 3] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4
    };

    function checkIEEE754 (buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
      if (offset < 0) throw new RangeError('Index out of range')
    }

    function writeFloat (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4
    }

    Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert)
    };

    Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert)
    };

    function writeDouble (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8
    }

    Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert)
    };

    Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert)
    };

    // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    Buffer.prototype.copy = function copy (target, targetStart, start, end) {
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;

      // Copy 0 bytes; we're done
      if (end === start) return 0
      if (target.length === 0 || this.length === 0) return 0

      // Fatal error conditions
      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds')
      }
      if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
      if (end < 0) throw new RangeError('sourceEnd out of bounds')

      // Are we oob?
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }

      var len = end - start;
      var i;

      if (this === target && start < targetStart && targetStart < end) {
        // descending copy from end
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
        // ascending copy from start
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }

      return len
    };

    // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])
    Buffer.prototype.fill = function fill (val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === 'string') {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string')
        }
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding)
        }
      } else if (typeof val === 'number') {
        val = val & 255;
      }

      // Invalid ranges are not set to a default, so can range check early.
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index')
      }

      if (end <= start) {
        return this
      }

      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;

      if (!val) val = 0;

      var i;
      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer(val)
          ? val
          : utf8ToBytes(new Buffer(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }

      return this
    };

    // HELPER FUNCTIONS
    // ================

    var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

    function base64clean (str) {
      // Node strips out invalid characters like \n and \t from the string, base64-js does not
      str = stringtrim(str).replace(INVALID_BASE64_RE, '');
      // Node converts strings with length < 2 to ''
      if (str.length < 2) return ''
      // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
      while (str.length % 4 !== 0) {
        str = str + '=';
      }
      return str
    }

    function stringtrim (str) {
      if (str.trim) return str.trim()
      return str.replace(/^\s+|\s+$/g, '')
    }

    function toHex (n) {
      if (n < 16) return '0' + n.toString(16)
      return n.toString(16)
    }

    function utf8ToBytes (string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            }

            // valid lead
            leadSurrogate = codePoint;

            continue
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }

        leadSurrogate = null;

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          bytes.push(
            codePoint >> 0x6 | 0xC0,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          bytes.push(
            codePoint >> 0xC | 0xE0,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          bytes.push(
            codePoint >> 0x12 | 0xF0,
            codePoint >> 0xC & 0x3F | 0x80,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else {
          throw new Error('Invalid code point')
        }
      }

      return bytes
    }

    function asciiToBytes (str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF);
      }
      return byteArray
    }

    function utf16leToBytes (str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break

        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }

      return byteArray
    }


    function base64ToBytes (str) {
      return toByteArray(base64clean(str))
    }

    function blitBuffer (src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if ((i + offset >= dst.length) || (i >= src.length)) break
        dst[i + offset] = src[i];
      }
      return i
    }

    function isnan (val) {
      return val !== val // eslint-disable-line no-self-compare
    }


    // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
    // The _isBuffer check is for Safari 5-7 support, because it's missing
    // Object.prototype.constructor. Remove this eventually
    function isBuffer(obj) {
      return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
    }

    function isFastBuffer (obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
    }

    // For Node v0.10 support. Remove this eventually.
    function isSlowBuffer (obj) {
      return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
    }

    const TRANSACTIONS_FOLDER = `${keySep}.transactions`;
    const LOCK_FILENAME = 'lock';
    const LOCK_FILE_KEY = joinKey(
      TRANSACTIONS_FOLDER, LOCK_FILENAME,
    );

    const createNodeErrors = {
      indexCannotBeParent: 'Index template cannot be a parent',
      allNonRootNodesMustHaveParent: 'Only the root node may have no parent',
      indexParentMustBeRecordOrRoot: 'An index may only have a record or root as a parent',
      aggregateParentMustBeAnIndex: 'aggregateGroup parent must be an index',
    };

    const pathRegxMaker = node => () => node.nodeKey().replace(/{id}/g, '[a-zA-Z0-9_-]+');

    const nodeKeyMaker = node => () => switchCase(

      [n => isRecord(n) && !isSingleRecord(n),
        n => joinKey(
          node.parent().nodeKey(),
          node.collectionName,
          `${n.nodeId}-{id}`,
        )],

      [isRoot,
        _.constant('/')],

      [defaultCase,
        n => joinKey(node.parent().nodeKey(), n.name)],

    )(node);


    const validate$1 = parent => (node) => {
      if (isIndex(node)
            && isSomething(parent)
            && !isRoot(parent)
            && !isRecord(parent)) {
        throw new BadRequestError(createNodeErrors.indexParentMustBeRecordOrRoot);
      }

      if (isaggregateGroup(node)
            && isSomething(parent)
            && !isIndex(parent)) {
        throw new BadRequestError(createNodeErrors.aggregateParentMustBeAnIndex);
      }

      if (isNothing(parent) && !isRoot(node)) { throw new BadRequestError(createNodeErrors.allNonRootNodesMustHaveParent); }

      return node;
    };

    const construct = parent => (node) => {
      node.nodeKey = nodeKeyMaker(node);
      node.pathRegx = pathRegxMaker(node);
      node.parent = _.constant(parent);
      node.isRoot = () => isNothing(parent)
                            && node.name === 'root'
                            && node.type === 'root';
      if (isCollectionRecord(node)) {
        node.collectionNodeKey = () => joinKey(
          parent.nodeKey(), node.collectionName,
        );
        node.collectionPathRegx = () => joinKey(
          parent.pathRegx(), node.collectionName,
        );
      }
      return node;
    };

    const addToParent = (obj) => {
      const parent = obj.parent();
      if (isSomething(parent)) {
        if (isIndex(obj))
        // Q: why are indexes not children ?
        // A: because they cannot have children of their own.
        { parent.indexes.push(obj); } else if (isaggregateGroup(obj)) { parent.aggregateGroups.push(obj); } else { parent.children.push(obj); }

        if (isRecord(obj)) {
          const defaultIndex = _.find(
            parent.indexes,
            i => i.name === `${parent.name}_index`,
          );
          if (defaultIndex) {
            defaultIndex.allowedRecordNodeIds.push(obj.nodeId);
          }
        }
      }
      return obj;
    };

    const constructNode = (parent, obj) => $(obj, [
      construct(parent),
      validate$1(parent),
      addToParent,
    ]);

    const getNodeId = (parentNode) => {
      // this case is handled better elsewhere
      if (!parentNode) return null;
      const findRoot = n => (isRoot(n) ? n : findRoot(n.parent()));
      const root = findRoot(parentNode);

      return ($(root, [
        getFlattenedHierarchy,
        fp.map(n => n.nodeId),
        fp.max]) + 1);
    };

    const constructHierarchy = (node, parent) => {
      construct(parent)(node);
      if (node.indexes) {
        _.each(node.indexes,
          child => constructHierarchy(child, node));
      }
      if (node.aggregateGroups) {
        _.each(node.aggregateGroups,
          child => constructHierarchy(child, node));
      }
      if (node.children && node.children.length > 0) {
        _.each(node.children,
          child => constructHierarchy(child, node));
      }
      if (node.fields) {
        _.each(node.fields,
          f => _.each(f.typeOptions, (val, key) => {
            const def = all$1[f.type].optionDefinitions[key];
            if (!def) {
              // unknown typeOption
              delete f.typeOptions[key];
            } else {
              f.typeOptions[key] = def.parse(val);
            }
          }));
      }
      return node;
    };


    const getNewRootLevel = () => construct()({
      name: 'root',
      type: 'root',
      children: [],
      pathMaps: [],
      indexes: [],
      nodeId: 0,
    });

    const _getNewRecordTemplate = (parent, name, createDefaultIndex, isSingle) => {
      const node = constructNode(parent, {
        name,
        type: 'record',
        fields: [],
        children: [],
        validationRules: [],
        nodeId: getNodeId(parent),
        indexes: [],
        allidsShardFactor: isRecord(parent) ? 1 : 64,
        collectionName: '',
        isSingle,
      });

      if (createDefaultIndex) {
        const defaultIndex = getNewIndexTemplate(parent);
        defaultIndex.name = `${name}_index`;
        defaultIndex.allowedRecordNodeIds.push(node.nodeId);
      }

      return node;
    };

    const getNewRecordTemplate = (parent, name = '', createDefaultIndex = true) => _getNewRecordTemplate(parent, name, createDefaultIndex, false);

    const getNewSingleRecordTemplate = parent => _getNewRecordTemplate(parent, '', false, true);

    const getNewIndexTemplate = (parent, type = 'ancestor') => constructNode(parent, {
      name: '',
      type: 'index',
      map: 'return {...record};',
      filter: '',
      indexType: type,
      getShardName: '',
      getSortKey: 'record.id',
      aggregateGroups: [],
      allowedRecordNodeIds: [],
      nodeId: getNodeId(parent),
    });

    const getNewAggregateGroupTemplate = index => constructNode(index, {
      name: '',
      type: 'aggregateGroup',
      groupBy: '',
      aggregates: [],
      condition: '',
      nodeId: getNodeId(index),
    });

    const getNewAggregateTemplate = (set) => {
      const aggregatedValue = {
        name: '',
        aggregatedValue: '',
      };
      set.aggregates.push(aggregatedValue);
      return aggregatedValue;
    };

    const fieldErrors = {
      AddFieldValidationFailed: 'Add field validation: ',
    };

    const allowedTypes = () => fp.keys(all$1);

    const getNewField = type => ({
      name: '', // how field is referenced internally
      type,
      typeOptions: getDefaultOptions$1(type),
      label: '', // how field is displayed
      getInitialValue: 'default', // function that gets value when initially created
      getUndefinedValue: 'default', // function that gets value when field undefined on record
    });

    const fieldRules = allFields => [
      makerule('name', 'field name is not set',
        f => isNonEmptyString(f.name)),
      makerule('type', 'field type is not set',
        f => isNonEmptyString(f.type)),
      makerule('label', 'field label is not set',
        f => isNonEmptyString(f.label)),
      makerule('getInitialValue', 'getInitialValue function is not set',
        f => isNonEmptyString(f.getInitialValue)),
      makerule('getUndefinedValue', 'getUndefinedValue function is not set',
        f => isNonEmptyString(f.getUndefinedValue)),
      makerule('name', 'field name is duplicated',
        f => isNothingOrEmpty(f.name)
                 || fp.countBy('name')(allFields)[f.name] === 1),
      makerule('type', 'type is unknown',
        f => isNothingOrEmpty(f.type)
                 || fp.some(t => f.type === t)(allowedTypes())),
    ];

    const typeOptionsRules = (field) => {
      const type = all$1[field.type];
      if (isNothing(type)) return [];

      const def = optName => type.optionDefinitions[optName];

      return $(field.typeOptions, [
        fp.keys,
        fp.filter(o => isSomething(def(o))
                        && isSomething(def(o).isValid)),
        fp.map(o => makerule(
          `typeOptions.${o}`,
          `${def(o).requirementDescription}`,
          field => def(o).isValid(field.typeOptions[o]),
        )),
      ]);
    };

    const validateField = allFields => (field) => {
      const everySingleField = fp.includes(field)(allFields) ? allFields : [...allFields, field];
      return applyRuleSet([...fieldRules(everySingleField), ...typeOptionsRules(field)])(field);
    };

    const validateAllFields = recordNode => $(recordNode.fields, [
      fp.map(validateField(recordNode.fields)),
      fp.flatten,
    ]);

    const addField = (recordTemplate, field) => {
      if (isNothingOrEmpty(field.label)) {
        field.label = field.name;
      }
      const validationMessages = validateField([...recordTemplate.fields, field])(field);
      if (validationMessages.length > 0) {
        const errors = fp.map(m => m.error)(validationMessages);
        throw new BadRequestError(`${fieldErrors.AddFieldValidationFailed} ${errors.join(', ')}`);
      }
      recordTemplate.fields.push(field);
    };

    const getNewRecordValidationRule = (invalidFields,
      messageWhenInvalid,
      expressionWhenValid) => ({
      invalidFields, messageWhenInvalid, expressionWhenValid,
    });

    const getStaticValue = switchCase(
      [fp.isNumber, v => v.toString()],
      [fp.isBoolean, v => v.toString()],
      [fp.defaultCase, v => `'${v}'`],
    );

    const commonRecordValidationRules = ({

      fieldNotEmpty: fieldName => getNewRecordValidationRule(
        [fieldName],
        `${fieldName} is empty`,
        `!_.isEmpty(record['${fieldName}'])`,
      ),

      fieldBetween: (fieldName, min, max) => getNewRecordValidationRule(
        [fieldName],
        `${fieldName} must be between ${min.toString()} and ${max.toString()}`,
        `record['${fieldName}'] >= ${getStaticValue(min)} &&  record['${fieldName}'] <= ${getStaticValue(max)} `,
      ),

      fieldGreaterThan: (fieldName, min, max) => getNewRecordValidationRule(
        [fieldName],
        `${fieldName} must be greater than ${min.toString()} and ${max.toString()}`,
        `record['${fieldName}'] >= ${getStaticValue(min)}  `,
      ),
    });

    const addRecordValidationRule = recordNode => rule => recordNode.validationRules.push(rule);

    const createTrigger = () => ({
      actionName: '',
      eventName: '',
      // function, has access to event context,
      // returns object that is used as parameter to action
      // only used if triggered by event
      optionsCreator: '',
      // action runs if true,
      // has access to event context
      condition: '',
    });

    const createAction = () => ({
      name: '',
      behaviourSource: '',
      // name of function in actionSource
      behaviourName: '',
      // parameter passed into behaviour.
      // any other parms passed at runtime e.g.
      // by trigger, or manually, will be merged into this
      initialOptions: {},
    });

    const aggregateRules = [
      makerule('name', 'choose a name for the aggregate',
        a => isNonEmptyString(a.name)),
      makerule('aggregatedValue', 'aggregatedValue does not compile',
        a => _.isEmpty(a.aggregatedValue)
                || executesWithoutException(
                  () => compilerUtil.compileCode(a.aggregatedValue),
                )),
    ];

    const validateAggregate = aggregate => applyRuleSet(aggregateRules)(aggregate);

    const validateAllAggregates = all => $(all, [
      fp.map(validateAggregate),
      fp.flatten,
    ]);

    const ruleSet = (...sets) => fp.constant(fp.flatten([...sets]));

    const commonRules = [
      makerule('name', 'node name is not set',
        node => stringNotEmpty(node.name)),
      makerule('type', 'node type not recognised',
        anyTrue(isRecord, isRoot, isIndex, isaggregateGroup)),
    ];

    const recordRules = [
      makerule('fields', 'no fields have been added to the record',
        node => isNonEmptyArray(node.fields)),
      makerule('validationRules', "validation rule is missing a 'messageWhenValid' member",
        node => fp.every(r => _.has(r, 'messageWhenInvalid'))(node.validationRules)),
      makerule('validationRules', "validation rule is missing a 'expressionWhenValid' member",
        node => fp.every(r => _.has(r, 'expressionWhenValid'))(node.validationRules)),
    ];


    const aggregateGroupRules = [
      makerule('condition', 'condition does not compile',
        a => fp.isEmpty(a.condition)
                 || executesWithoutException(
                   () => compilerUtil.compileExpression(a.condition),
                 )),
    ];

    const getRuleSet = node => switchCase(

      [isRecord, ruleSet(
        commonRules,
        recordRules,
      )],

      [isIndex, ruleSet(
        commonRules,
        indexRuleSet,
      )],

      [isaggregateGroup, ruleSet(
        commonRules,
        aggregateGroupRules,
      )],

      [defaultCase, ruleSet(commonRules, [])],
    )(node);

    const validateNode = node => applyRuleSet(getRuleSet(node))(node);

    const validateAll = (appHierarchy) => {
      const flattened = getFlattenedHierarchy(
        appHierarchy,
      );

      const duplicateNameRule = makerule(
        'name', 'node names must be unique under shared parent',
        n => fp.filter(f => f.parent() === n.parent()
                              && f.name === n.name)(flattened).length === 1,
      );

      const duplicateNodeKeyErrors = $(flattened, [
        fp.map(n => applyRuleSet([duplicateNameRule])(n)),
        fp.filter(isSomething),
        fp.flatten,
      ]);

      const fieldErrors = $(flattened, [
        fp.filter(isRecord),
        fp.map(validateAllFields),
        fp.flatten,
      ]);

      const aggregateErrors = $(flattened, [
        fp.filter(isaggregateGroup),
        fp.map(s => validateAllAggregates(
          s.aggregates,
        )),
        fp.flatten,
      ]);

      return $(flattened, [
        fp.map(validateNode),
        fp.flatten,
        fp.union(duplicateNodeKeyErrors),
        fp.union(fieldErrors),
        fp.union(aggregateErrors),
      ]);
    };

    const actionRules = [
      makerule('name', 'action must have a name',
        a => isNonEmptyString(a.name)),
      makerule('behaviourName', 'must supply a behaviour name to the action',
        a => isNonEmptyString(a.behaviourName)),
      makerule('behaviourSource', 'must supply a behaviour source for the action',
        a => isNonEmptyString(a.behaviourSource)),
    ];

    const duplicateActionRule = makerule('', 'action name must be unique', () => {});

    const validateAction = action => applyRuleSet(actionRules)(action);


    const validateActions = (allActions) => {
      const duplicateActions = $(allActions, [
        fp.filter(a => fp.filter(a2 => a2.name === a.name)(allActions).length > 1),
        fp.map(a => validationError(duplicateActionRule, a)),
      ]);

      const errors = $(allActions, [
        fp.map(validateAction),
        fp.flatten,
        fp.union(duplicateActions),
        fp.uniqBy('name'),
      ]);

      return errors;
    };

    const triggerRules = actions => ([
      makerule('actionName', 'must specify an action',
        t => isNonEmptyString(t.actionName)),
      makerule('eventName', 'must specify and event',
        t => isNonEmptyString(t.eventName)),
      makerule('actionName', 'specified action not supplied',
        t => !t.actionName
                 || fp.some(a => a.name === t.actionName)(actions)),
      makerule('eventName', 'invalid Event Name',
        t => !t.eventName
                 || fp.includes(t.eventName)(eventsList)),
      makerule('optionsCreator', 'Options Creator does not compile - check your expression',
        (t) => {
          if (!t.optionsCreator) return true;
          try {
            compilerUtil.compileCode(t.optionsCreator);
            return true;
          } catch (_) { return false; }
        }),
      makerule('condition', 'Trigger condition does not compile - check your expression',
        (t) => {
          if (!t.condition) return true;
          try {
            compilerUtil.compileExpression(t.condition);
            return true;
          } catch (_) { return false; }
        }),
    ]);

    const validateTrigger = (trigger, allActions) => {
      const errors = applyRuleSet(triggerRules(allActions))(trigger);

      return errors;
    };

    const validateTriggers = (triggers, allActions) => $(triggers, [
      fp.map(t => validateTrigger(t, allActions)),
      fp.flatten,
    ]);

    const getApplicationDefinition = datastore => async () => {
      const exists = await datastore.exists(appDefinitionFile);

      if (!exists) throw new Error('Application definition does not exist');

      const appDefinition = await datastore.loadJson(appDefinitionFile);
      appDefinition.hierarchy = constructHierarchy(
        appDefinition.hierarchy,
      );
      return appDefinition;
    };

    const saveApplicationHierarchy = app => async hierarchy => apiWrapper(
      app,
      events.templateApi.saveApplicationHierarchy,
      permission.writeTemplates.isAuthorized,
      { hierarchy },
      _saveApplicationHierarchy, app.datastore, hierarchy,
    );


    const _saveApplicationHierarchy = async (datastore, hierarchy) => {
      const validationErrors = await validateAll(hierarchy);
      if (validationErrors.length > 0) {
        throw new Error(`Hierarchy is invalid: ${_.join(
      validationErrors.map(e => `${e.item.nodeKey ? e.item.nodeKey() : ''} : ${e.error}`),
      ',',
    )}`);
      }

      if (await datastore.exists(appDefinitionFile)) {
        const appDefinition = await datastore.loadJson(appDefinitionFile);
        appDefinition.hierarchy = hierarchy;
        await datastore.updateJson(appDefinitionFile, appDefinition);
      } else {
        await datastore.createFolder('/.config');
        const appDefinition = { actions: [], triggers: [], hierarchy };
        await datastore.createJson(appDefinitionFile, appDefinition);
      }
    };

    const saveActionsAndTriggers = app => async (actions, triggers) => apiWrapper(
      app,
      events.templateApi.saveActionsAndTriggers,
      permission.writeTemplates.isAuthorized,
      { actions, triggers },
      _saveActionsAndTriggers, app.datastore, actions, triggers,
    );

    const _saveActionsAndTriggers = async (datastore, actions, triggers) => {
      if (await datastore.exists(appDefinitionFile)) {
        const appDefinition = await datastore.loadJson(appDefinitionFile);
        appDefinition.actions = actions;
        appDefinition.triggers = triggers;

        const actionValidErrs = fp.map(e => e.error)(validateActions(actions));

        if (actionValidErrs.length > 0) {
          throw new BadRequestError(`Actions are invalid: ${_.join(actionValidErrs, ', ')}`);
        }

        const triggerValidErrs = fp.map(e => e.error)(validateTriggers(triggers, actions));

        if (triggerValidErrs.length > 0) {
          throw new BadRequestError(`Triggers are invalid: ${_.join(triggerValidErrs, ', ')}`);
        }

        await datastore.updateJson(appDefinitionFile, appDefinition);
      } else {
        throw new BadRequestError('Cannot save actions: Application definition does not exist');
      }
    };

    const getBehaviourSources = async (datastore) => {
        await datastore.loadFile('/.config/behaviourSources.js');
    };

    const api$1 = app => ({

      getApplicationDefinition: getApplicationDefinition(app.datastore),
      saveApplicationHierarchy: saveApplicationHierarchy(app),
      saveActionsAndTriggers: saveActionsAndTriggers(app),
      getBehaviourSources: () => getBehaviourSources(app.datastore),
      getNewRootLevel,
      constructNode,
      getNewIndexTemplate,
      getNewRecordTemplate,
      getNewField,
      validateField,
      addField,
      fieldErrors,
      getNewRecordValidationRule,
      commonRecordValidationRules,
      addRecordValidationRule,
      createAction,
      createTrigger,
      validateActions,
      validateTrigger,
      getNewAggregateGroupTemplate,
      getNewAggregateTemplate,
      constructHierarchy,
      getNewSingleRecordTemplate,
      allTypes: all$1,
      validateNode,
      validateAll,
      validateTriggers,
    });


    const getTemplateApi = app => api$1(app);

    const getUsers = app => async () => apiWrapper(
      app,
      events.authApi.getUsers,
      permission.listUsers.isAuthorized,
      {},
      _getUsers, app,
    );

    const _getUsers = async app => $(await app.datastore.loadJson(USERS_LIST_FILE), [
      fp.map(stripUserOfSensitiveStuff),
    ]);

    const loadAccessLevels = app => async () => apiWrapper(
      app,
      events.authApi.loadAccessLevels,
      permission.listAccessLevels.isAuthorized,
      {},
      _loadAccessLevels, app,
    );

    const _loadAccessLevels = async app => await app.datastore.loadJson(ACCESS_LEVELS_FILE);

    const dummyHash = '$argon2i$v=19$m=4096,t=3,p=1$UZRo409UYBGjHJS3CV6Uxw$rU84qUqPeORFzKYmYY0ceBLDaPO+JWSH4PfNiKXfIKk';

    const authenticate = app => async (username, password) => apiWrapper(
      app,
      events.authApi.authenticate,
      alwaysAuthorized,
      { username, password },
      _authenticate, app, username, password,
    );

    const _authenticate = async (app, username, password) => {
      if (isNothingOrEmpty(username) || isNothingOrEmpty(password)) { return null; }

      const allUsers = await _getUsers(app);
      let user = getUserByName(
        allUsers,
        username,
      );

      const notAUser = 'not-a-user';
      // continue with non-user - so time to verify remains consistent
      // with verification of a valid user
      if (!user || !user.enabled) { user = notAUser; }

      let userAuth;
      try {
        userAuth = await app.datastore.loadJson(
          userAuthFile(username),
        );
      } catch (_) {
        userAuth = { accessLevels: [], passwordHash: dummyHash };
      }

      const permissions = await buildUserPermissions(app, user.accessLevels);

      const verified = await app.crypto.verify(
        userAuth.passwordHash,
        password,
      );

      if (user === notAUser) { return null; }

      return verified
        ? {
          ...user, permissions, temp: false, isUser: true,
        }
        : null;
    };

    const authenticateTemporaryAccess = app => async (tempAccessCode) => {
      if (isNothingOrEmpty(tempAccessCode)) { return null; }

      const temp = parseTemporaryCode(tempAccessCode);
      let user = $(await _getUsers(app), [
        fp.find(u => u.temporaryAccessId === temp.id),
      ]);

      const notAUser = 'not-a-user';
      if (!user || !user.enabled) { user = notAUser; }

      let userAuth;
      try {
        userAuth = await app.datastore.loadJson(
          userAuthFile(user.name),
        );
      } catch (e) {
        userAuth = {
          temporaryAccessHash: dummyHash,
          temporaryAccessExpiryEpoch: (await app.getEpochTime() + 10000),
        };
      }

      if (userAuth.temporaryAccessExpiryEpoch < await app.getEpochTime()) { user = notAUser; }

      const tempCode = !temp.code ? shortid.generate() : temp.code;
      const verified = await app.crypto.verify(
        userAuth.temporaryAccessHash,
        tempCode,
      );

      if (user === notAUser) { return null; }

      return verified
        ? {
          ...user,
          permissions: [],
          temp: true,
          isUser: true,
        }
        : null;
    };

    const buildUserPermissions = async (app, userAccessLevels) => {
      const allAccessLevels = await _loadAccessLevels(app);

      return $(allAccessLevels.levels, [
        fp.filter(l => fp.some(ua => l.name === ua)(userAccessLevels)),
        fp.map(l => l.permissions),
        fp.flatten,
      ]);
    };

    const createTemporaryAccess$1 = app => async userName => apiWrapper(
      app,
      events.authApi.createTemporaryAccess,
      alwaysAuthorized,
      { userName },
      _createTemporaryAccess, app, userName,
    );

    const _createTemporaryAccess = async (app, userName) => {
      const tempCode = await getTemporaryCode(app);

      const lock = await getLock(
        app, USERS_LOCK_FILE, 1000, 2,
      );

      if (isNolock(lock)) { throw new Error('Unable to create temporary access, could not get lock - try again'); }

      try {
        const users = await app.datastore.loadJson(USERS_LIST_FILE);

        const user = getUserByName(users, userName);
        user.temporaryAccessId = tempCode.temporaryAccessId;

        await app.datastore.updateJson(
          USERS_LIST_FILE,
          users,
        );
      } finally {
        await releaseLock(app, lock);
      }

      const userAuth = await app.datastore.loadJson(
        userAuthFile(userName),
      );
      userAuth.temporaryAccessHash = tempCode.temporaryAccessHash;

      userAuth.temporaryAccessExpiryEpoch = tempCode.temporaryAccessExpiryEpoch;

      await app.datastore.updateJson(
        userAuthFile(userName),
        userAuth,
      );

      return tempCode.tempCode;
    };

    const getTemporaryCode = async (app) => {
      const tempCode = shortid.generate()
            + shortid.generate()
            + shortid.generate()
            + shortid.generate();

      const tempId = shortid.generate();

      return {
        temporaryAccessHash: await app.crypto.hash(
          tempCode,
        ),
        temporaryAccessExpiryEpoch:
                (await app.getEpochTime()) + tempCodeExpiryLength,
        tempCode: `tmp:${tempId}:${tempCode}`,
        temporaryAccessId: tempId,
      };
    };

    const userRules = allUsers => [
      makerule('name', 'username must be set',
        u => isNonEmptyString(u.name)),
      makerule('accessLevels', 'user must have at least one access level',
        u => u.accessLevels.length > 0),
      makerule('name', 'username must be unique',
        u => fp.filter(u2 => insensitiveEquals(u2.name, u.name))(allUsers).length === 1),
      makerule('accessLevels', 'access levels must only contain stings',
        u => all(isNonEmptyString)(u.accessLevels)),
    ];

    const validateUser = () => (allusers, user) => applyRuleSet(userRules(allusers))(user);

    const getNewUser = app => () => apiWrapperSync(
      app,
      events.authApi.getNewUser,
      permission.createUser.isAuthorized,
      {},
      _getNewUser, app,
    );

    const _getNewUser = () => ({
      name: '',
      accessLevels: [],
      enabled: true,
      temporaryAccessId: '',
    });

    const getNewUserAuth = app => () => apiWrapperSync(
      app,
      events.authApi.getNewUserAuth,
      permission.createUser.isAuthorized,
      {},
      _getNewUserAuth, app,
    );

    const _getNewUserAuth = () => ({
      passwordHash: '',
      temporaryAccessHash: '',
      temporaryAccessExpiryEpoch: 0,
    });

    const isValidPassword = app => password => apiWrapperSync(
      app,
      events.authApi.isValidPassword,
      alwaysAuthorized,
      { password },
      _isValidPassword, app, password,
    );

    const _isValidPassword = (app, password) => scorePassword(password).score > 30;

    const changeMyPassword = app => async (currentPw, newpassword) => apiWrapper(
      app,
      events.authApi.changeMyPassword,
      alwaysAuthorized,
      { currentPw, newpassword },
      _changeMyPassword, app, currentPw, newpassword,
    );

    const _changeMyPassword = async (app, currentPw, newpassword) => {
      const existingAuth = await app.datastore.loadJson(
        userAuthFile(app.user.name),
      );

      if (isSomething(existingAuth.passwordHash)) {
        const verified = await app.crypto.verify(
          existingAuth.passwordHash,
          currentPw,
        );

        if (verified) {
          await await doSet(
            app, existingAuth,
            app.user.name, newpassword,
          );
          return true;
        }
      }

      return false;
    };

    const setPasswordFromTemporaryCode = app => async (tempCode, newpassword) => apiWrapper(
      app,
      events.authApi.setPasswordFromTemporaryCode,
      alwaysAuthorized,
      { tempCode, newpassword },
      _setPasswordFromTemporaryCode, app, tempCode, newpassword,
    );


    const _setPasswordFromTemporaryCode = async (app, tempCode, newpassword) => {
      const currentTime = await app.getEpochTime();

      const temp = parseTemporaryCode(tempCode);

      const user = $(await _getUsers(app), [
        fp.find(u => u.temporaryAccessId === temp.id),
      ]);

      if (!user) { return false; }

      const existingAuth = await app.datastore.loadJson(
        userAuthFile(user.name),
      );

      if (isSomething(existingAuth.temporaryAccessHash)
           && existingAuth.temporaryAccessExpiryEpoch > currentTime) {
        const verified = await app.crypto.verify(
          existingAuth.temporaryAccessHash,
          temp.code,
        );

        if (verified) {
          await doSet(
            app, existingAuth,
            user.name, newpassword,
          );
          return true;
        }
      }

      return false;
    };

    const doSet = async (app, auth, username, newpassword) => {
      auth.temporaryAccessHash = '';
      auth.temporaryAccessExpiryEpoch = 0;
      auth.passwordHash = await app.crypto.hash(
        newpassword,
      );
      await app.datastore.updateJson(
        userAuthFile(username),
        auth,
      );
    };

    const scorePassword = app => password => apiWrapperSync(
      app,
      events.authApi.scorePassword,
      alwaysAuthorized,
      { password },
      _scorePassword, password,
    );

    const _scorePassword = (password) => {
      // from https://stackoverflow.com/questions/948172/password-strength-meter
      // thank you https://stackoverflow.com/users/46617/tm-lv

      let score = 0;
      if (!password) { return score; }

      // award every unique letter until 5 repetitions
      const letters = new Object();
      for (let i = 0; i < password.length; i++) {
        letters[password[i]] = (letters[password[i]] || 0) + 1;
        score += 5.0 / letters[password[i]];
      }

      // bonus points for mixing it up
      const variations = {
        digits: /\d/.test(password),
        lower: /[a-z]/.test(password),
        upper: /[A-Z]/.test(password),
        nonWords: /\W/.test(password),
      };

      let variationCount = 0;
      for (const check in variations) {
        variationCount += (variations[check] == true) ? 1 : 0;
      }
      score += (variationCount - 1) * 10;

      const strengthText = score > 80
        ? 'strong'
        : score > 60
          ? 'good'
          : score >= 30
            ? 'weak'
            : 'very weak';

      return {
        score: parseInt(score),
        strengthText,
      };
    };

    const createUser$1 = app => async (user, password = null) => apiWrapper(
      app,
      events.authApi.createUser,
      permission.createUser.isAuthorized,
      { user, password },
      _createUser, app, user, password,
    );

    const _createUser = async (app, user, password = null) => {
      const lock = await getLock(
        app, USERS_LOCK_FILE, 1000, 2,
      );

      if (isNolock(lock)) { throw new Error('Unable to create user, could not get lock - try again'); }

      const users = await app.datastore.loadJson(USERS_LIST_FILE);

      const userErrors = validateUser()([...users, user], user);
      if (userErrors.length > 0) { throw new BadRequestError(`User is invalid. ${fp.join('; ')(userErrors)}`); }

      const { auth, tempCode, temporaryAccessId } = await getAccess(
        app, password,
      );
      user.tempCode = tempCode;
      user.temporaryAccessId = temporaryAccessId;

      if (fp.some(u => insensitiveEquals(u.name, user.name))(users)) { 
        throw new BadRequestError('User already exists'); 
      }

      users.push(
        stripUserOfSensitiveStuff(user),
      );

      await app.datastore.updateJson(
        USERS_LIST_FILE,
        users,
      );

      try {
        await app.datastore.createJson(
          userAuthFile(user.name),
          auth,
        );
      } catch (_) {
        await app.datastore.updateJson(
          userAuthFile(user.name),
          auth,
        );
      }

      await releaseLock(app, lock);

      return user;
    };

    const getAccess = async (app, password) => {
      const auth = getNewUserAuth(app)();

      if (isNonEmptyString(password)) {
        if (isValidPassword(password)) {
          auth.passwordHash = await app.crypto.hash(password);
          auth.temporaryAccessHash = '';
          auth.temporaryAccessId = '';
          auth.temporaryAccessExpiryEpoch = 0;
          return { auth };
        }
        throw new BadRequestError('Password does not meet requirements');
      } else {
        const tempAccess = await getTemporaryCode(app);
        auth.temporaryAccessHash = tempAccess.temporaryAccessHash;
        auth.temporaryAccessExpiryEpoch = tempAccess.temporaryAccessExpiryEpoch;
        auth.passwordHash = '';
        return ({
          auth,
          tempCode: tempAccess.tempCode,
          temporaryAccessId: tempAccess.temporaryAccessId,
        });
      }
    };

    const enableUser = app => async username => apiWrapper(
      app,
      events.authApi.enableUser,
      permission.enableDisableUser.isAuthorized,
      { username },
      _enableUser, app, username,
    );

    const disableUser = app => async username => apiWrapper(
      app,
      events.authApi.disableUser,
      permission.enableDisableUser.isAuthorized,
      { username },
      _disableUser, app, username,
    );

    const _enableUser = async (app, username) => await toggleUser(app, username, true);

    const _disableUser = async (app, username) => await toggleUser(app, username, false);

    const toggleUser = async (app, username, enabled) => {
      const lock = await getLock(app, USERS_LOCK_FILE, 1000, 1, 0);

      const actionName = enabled ? 'enable' : 'disable';

      if (isNolock(lock)) { throw new Error(`Could not ${actionName} user - cannot get lock`); }

      try {
        const users = await app.datastore.loadJson(USERS_LIST_FILE);
        const user = getUserByName(users, username);
        if (!user) { throw new NotFoundError(`Could not find user to ${actionName}`); }

        if (user.enabled === !enabled) {
          user.enabled = enabled;
          await app.datastore.updateJson(USERS_LIST_FILE, users);
        }
      } finally {
        releaseLock(app, lock);
      }
    };

    const getNewAccessLevel = () => () => ({
      name: '',
      permissions: [],
      default:false
    });

    const isAllowedType = t => $(permissionTypes, [
      fp.values,
      fp.includes(t),
    ]);

    const isRecordOrIndexType = t => fp.some(p => p === t)([
      permissionTypes.CREATE_RECORD,
      permissionTypes.UPDATE_RECORD,
      permissionTypes.DELETE_RECORD,
      permissionTypes.READ_RECORD,
      permissionTypes.READ_INDEX,
      permissionTypes.EXECUTE_ACTION,
    ]);


    const permissionRules = app => ([
      makerule('type', 'type must be one of allowed types',
        p => isAllowedType(p.type)),
      makerule('nodeKey', 'record and index permissions must include a valid nodeKey',
        p => (!isRecordOrIndexType(p.type))
                 || isSomething(getNode(app.hierarchy, p.nodeKey))),
    ]);

    const applyPermissionRules = app => applyRuleSet(permissionRules(app));

    const accessLevelRules = allLevels => ([
      makerule('name', 'name must be set',
        l => isNonEmptyString(l.name)),
      makerule('name', 'access level names must be unique',
        l => fp.isEmpty(l.name)
                 || fp.filter(a => insensitiveEquals(l.name, a.name))(allLevels).length === 1),
    ]);

    const applyLevelRules = allLevels => applyRuleSet(accessLevelRules(allLevels));

    const validateAccessLevel = app => (allLevels, level) => {
      const errs = $(level.permissions, [
        fp.map(applyPermissionRules(app)),
        fp.flatten,
        fp.concat(
          applyLevelRules(allLevels)(level),
        ),
      ]);

      return errs;
    };

    const validateAccessLevels = app => allLevels => apiWrapperSync(
      app,
      events.authApi.validateAccessLevels,
      alwaysAuthorized,
      { allLevels },
      _validateAccessLevels, app, allLevels,
    );

    const _validateAccessLevels = (app, allLevels) => $(allLevels, [
      fp.map(l => validateAccessLevel(app)(allLevels, l)),
      fp.flatten,
      fp.uniqWith((x, y) => x.field === y.field
                            && x.item === y.item
                            && x.error === y.error),
    ]);

    const saveAccessLevels = app => async accessLevels => apiWrapper(
      app,
      events.authApi.saveAccessLevels,
      permission.writeAccessLevels.isAuthorized,
      { accessLevels },
      _saveAccessLevels, app, accessLevels,
    );

    const _saveAccessLevels = async (app, accessLevels) => {
      const validationErrors = validateAccessLevels(app)(accessLevels.levels);
      if (validationErrors.length > 0) {
        const errs = $(validationErrors, [
          fp.map(e => e.error),
          fp.join(', '),
        ]);
        throw new Error(
          `Access Levels Invalid: ${errs}`,
        );
      }

      const lock = await getLock(
        app, ACCESS_LEVELS_LOCK_FILE, 2000, 2,
      );

      if (isNolock(lock)) { throw new Error('Could not get lock to save access levels'); }

      try {
        const existing = await app.datastore.loadJson(ACCESS_LEVELS_FILE);
        if (existing.version !== accessLevels.version) { throw new Error('Access levels have already been updated, since you loaded'); }

        accessLevels.version++;

        app.datastore.updateJson(ACCESS_LEVELS_FILE, accessLevels);
      } finally {
        await releaseLock(app, lock);
      }
    };

    const generateFullPermissions = (app) => {
      const allNodes = getFlattenedHierarchy(app.hierarchy);
      const accessLevel = { permissions: [] };

      const recordNodes = $(allNodes, [
        fp.filter(isRecord),
      ]);

      for (const n of recordNodes) {
        permission.createRecord.add(n.nodeKey(), accessLevel);
        permission.updateRecord.add(n.nodeKey(), accessLevel);
        permission.deleteRecord.add(n.nodeKey(), accessLevel);
        permission.readRecord.add(n.nodeKey(), accessLevel);
      }

      const indexNodes = $(allNodes, [
        fp.filter(isIndex),
      ]);

      for (const n of indexNodes) {
        permission.readIndex.add(n.nodeKey(), accessLevel);
      }

      for (const a of fp.keys(app.actions)) {
        permission.executeAction.add(a, accessLevel);
      }

      $(permission, [
        fp.values,
        fp.filter(p => !p.isNode),
        fp.each(p => p.add(accessLevel)),
      ]);

      return accessLevel.permissions;
    };

    const setUserAccessLevels$1 = app => async (userName, accessLevels) => apiWrapper(
      app,
      events.authApi.setUserAccessLevels,
      permission.setUserAccessLevels.isAuthorized,
      { userName, accessLevels },
      _setUserAccessLevels, app, userName, accessLevels,
    );

    const _setUserAccessLevels = async (app, username, accessLevels) => {
      const lock = await getLock(app, USERS_LOCK_FILE, 1000, 1, 0);

      const actualAccessLevels = $(
        await app.datastore.loadJson(ACCESS_LEVELS_FILE),
        [
          l => l.levels,
          fp.map(l => l.name),
        ],
      );

      const missing = fp.difference(accessLevels)(actualAccessLevels);
      if (missing.length > 0) {
        throw new Error(`Invalid access levels supplied: ${fp.join(', ', missing)}`);
      }

      if (isNolock(lock)) { throw new Error('Could set user access levels cannot get lock'); }

      try {
        const users = await app.datastore.loadJson(USERS_LIST_FILE);
        const user = getUserByName(users, username);
        if (!user) { throw new NotFoundError(`Could not find user with ${username}`); }

        user.accessLevels = accessLevels;
        await app.datastore.updateJson(USERS_LIST_FILE, users);
      } finally {
        releaseLock(app, lock);
      }
    };

    const getAuthApi = app => ({
      authenticate: authenticate(app),
      authenticateTemporaryAccess: authenticateTemporaryAccess(app),
      createTemporaryAccess: createTemporaryAccess$1(app),
      createUser: createUser$1(app),
      loadAccessLevels: loadAccessLevels(app),
      enableUser: enableUser(app),
      disableUser: disableUser(app),
      getNewAccessLevel: getNewAccessLevel(),
      getNewUser: getNewUser(app),
      getNewUserAuth: getNewUserAuth(app),
      getUsers: getUsers(app),
      saveAccessLevels: saveAccessLevels(app),
      isAuthorized: isAuthorized(app),
      changeMyPassword: changeMyPassword(app),
      setPasswordFromTemporaryCode: setPasswordFromTemporaryCode(app),
      scorePassword,
      isValidPassword: isValidPassword(app),
      validateUser: validateUser(),
      validateAccessLevels: validateAccessLevels(app),
      generateFullPermissions: () => generateFullPermissions(app),
      setUserAccessLevels: setUserAccessLevels$1(app),
    });

    const chain = index.$;

    const events$1 = index.eventsList;

    const getNode$1 = (hierarchy$1, nodeId) => 
        chain(hierarchy$1, [
            hierarchy.getFlattenedHierarchy,
            fp.find(n => n.nodeId === nodeId || n.nodeKey() === nodeId)
        ]);

    const constructHierarchy$1 = node => {
        if(!node) return node;
        return templateApi(node).constructHierarchy(node);
    };

    const templateApi = hierarchy => getTemplateApi({hierarchy});
    const authApi = (hierarchy, actions) => getAuthApi({
        hierarchy, actions: fp.keyBy("name")(actions), publish:()=>{}});

    const allTypes$1 = templateApi({}).allTypes;

    const validate = {
        all: templateApi({}).validateAll,
        node: templateApi({}).validateNode,
        field: templateApi({}).validateField
    };

    const getPotentialReverseReferenceIndexes = (hierarchy$1, refIndex) => {
        const res = chain(hierarchy$1, [
            hierarchy.getFlattenedHierarchy,
            fp.filter(n => hierarchy.isAncestor(refIndex)(n)
                        || hierarchy.isAncestor(refIndex)(n.parent())),
            fp.map(n => n.indexes),
            fp.flatten,
            fp.filter(hierarchy.isReferenceIndex)
        ]);

        return res;
    };

    const getPotentialReferenceIndexes = (hierarchy$1, record) =>
        chain(hierarchy$1, [
            hierarchy.getFlattenedHierarchy,
            fp.filter(hierarchy.isAncestorIndex),
            fp.filter(i => hierarchy.isAncestor(record)(i.parent())
                        || i.parent().nodeId === record.parent().nodeId
                        || hierarchy.isRoot(i.parent()))
        ]);

    const getDefaultTypeOptions = type => 
        !type ? {} : allTypes$1[type].getDefaultOptions();

    const getNewAction = () => templateApi({}).createAction();
    const getNewTrigger = () => templateApi({}).createTrigger();

    const validateActions$1 = actions => templateApi({}).validateActions(actions);
    const validateTriggers$1 = (triggers, actions) => templateApi({}).validateTriggers(triggers, actions);

    const generateFullPermissions$1 = (hierarchy, actions) => 
        authApi(hierarchy,actions).generateFullPermissions();

    const getNewAccessLevel$1 = () => 
        authApi().getNewAccessLevel();

    const validateAccessLevels$1 = (hierarchy, actions, accessLevels) => 
        authApi(hierarchy, actions).validateAccessLevels(accessLevels);

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    const defaultPagesObject = () => ({
        main: {
            index: {
                _component : "./components/indexHtml"
            },
            appBody: "bbapp.main.json"
        },
        unauthenticated: {
            index: {
                _component : "./components/indexHtml"
            },
            appBody: "bbapp.unauthenticated.json"
        },
        componentLibraries: ["./components"]
    });

    const apiCall = (method) => (url, body, returnResponse=false) => 
        fetch(url, {
            method: method,
            headers: {
                'Content-Type': 'application/json',
            },
            body: body && JSON.stringify(body), 
        }).then(r => returnResponse ? r : r.json());

    const post = apiCall("POST");
    const get = apiCall("GET");
    const patch = apiCall("PATCH");
    const del = apiCall("DELETE");

    var api = {
        post, get, patch, delete:del
    };

    const pipe = index.$;

    const getStore = () => {

        const initial = {
            apps:[],
            appname:"",
            hierarchy: {},
            actions: [],
            triggers: [],
            pages:defaultPagesObject(),
            mainUi:{},
            unauthenticatedUi:{},
            derivedComponents:[],
            rootComponents:[],
            currentNodeIsNew: false,
            errors: [],
            activeNav: "database",
            hasAppPackage: false,
            accessLevels: [],
            currentNode: null,
        };

        const store = writable(initial);

        store.initialise = initialise(store, initial);
        store.newChildRecord = newRecord(store, false);
        store.newRootRecord = newRecord(store, true);
        store.selectExistingNode = selectExistingNode(store);
        store.newChildIndex = newIndex(store, false);
        store.newRootIndex = newIndex(store, true);
        store.saveCurrentNode = saveCurrentNode(store);
        store.importAppDefinition = importAppDefinition(store);
        store.deleteCurrentNode = deleteCurrentNode(store);
        store.saveField = saveField(store);
        store.deleteField = deleteField(store);
        store.saveAction = saveAction(store);
        store.deleteAction = deleteAction(store);
        store.saveTrigger = saveTrigger(store);
        store.deleteTrigger = deleteTrigger(store);
        store.saveLevel = saveLevel(store);
        store.deleteLevel = deleteLevel(store);
        store.setActiveNav = setActiveNav(store);
        store.saveDerivedComponent = saveDerivedComponent(store);
        store.refreshComponents = refreshComponents(store);
        store.addComponentLibrary = addComponentLibrary(store);
        store.renameDerivedComponent = renameDerivedComponent(store);
        store.deleteDerivedComponent = deleteDerivedComponent(store);
        return store;
    }; 

    const initialise = (store, initial) => async () => {

        const appname = window.location.hash 
                    ? fp.last(window.location.hash.substr(1).split("/"))
                    : "";

        if(!appname) {
            initial.apps = await api.get(`/_builder/api/apps`);
            initial.hasAppPackage = false;
            store.set(initial);
            return initial;
        }

        const pkg = await api.get(`/_builder/api/${appname}/appPackage`);

        initial.appname = appname;
        initial.hasAppPackage = true;
        initial.hierarchy = pkg.appDefinition.hierarchy;
        initial.accessLevels = pkg.accessLevels;
        initial.derivedComponents = pkg.derivedComponents;
        initial.rootComponents = pkg.rootComponents;
        initial.actions = fp.reduce((arr, action) => {
            arr.push(action);
            return arr;
        })(pkg.appDefinition.actions, []);
        initial.triggers = pkg.appDefinition.triggers;

        if(!!initial.hierarchy && !fp.isEmpty(initial.hierarchy)) {
            initial.hierarchy = constructHierarchy$1(initial.hierarchy);
            const shadowHierarchy = createShadowHierarchy(initial.hierarchy);
            if(initial.currentNode !== null)
                initial.currentNode = getNode$1(
                    shadowHierarchy, initial.currentNode.nodeId
                );
        }
        store.set(initial);
        return initial;
    };

    const newRecord = (store, useRoot) => () => {
        store.update(s => {
            s.currentNodeIsNew = true;
            const shadowHierarchy = createShadowHierarchy(s.hierarchy);
            parent = useRoot ? shadowHierarchy
                     : getNode$1(
                        shadowHierarchy, 
                        s.currentNode.nodeId);
            s.errors = [];
            s.currentNode = templateApi(shadowHierarchy)
                             .getNewRecordTemplate(parent, "", true);
            return s;
        });
    };


    const selectExistingNode = (store) => (nodeId) => {
        store.update(s => {
            const shadowHierarchy = createShadowHierarchy(s.hierarchy);
            s.currentNode = getNode$1(
                shadowHierarchy, nodeId
            );
            s.currentNodeIsNew = false;
            s.errors = [];
            return s;
        });
    };

    const newIndex = (store, useRoot) => () => {
        store.update(s => {
            s.currentNodeIsNew = true;
            s.errors = [];
            const shadowHierarchy = createShadowHierarchy(s.hierarchy);
            parent = useRoot ? shadowHierarchy
                     : getNode$1(
                        shadowHierarchy, 
                        s.currentNode.nodeId);

            s.currentNode = templateApi(shadowHierarchy)
                             .getNewIndexTemplate(parent);
            return s;
        });
    };

    const saveCurrentNode = (store) => () => {
        store.update(s => {

            const errors = validate.node(s.currentNode);
            s.errors = errors;
            if(errors.length > 0) {
                return s;
            }

            const parentNode = getNode$1(
                s.hierarchy, s.currentNode.parent().nodeId);

            const existingNode = getNode$1(
                s.hierarchy, s.currentNode.nodeId);

            let index = parentNode.children.length;
            if(!!existingNode) {
                // remove existing
                index = existingNode.parent().children.indexOf(existingNode);
                existingNode.parent().children = chain(existingNode.parent().children, [
                    fp.filter(c => c.nodeId !== existingNode.nodeId)
                ]);
            }

            // should add node into existing hierarchy
            const cloned = fp.cloneDeep(s.currentNode);
            templateApi(s.hierarchy).constructNode(
                parentNode, 
                cloned
            );

            const newIndexOfchild = child => {
                if(child === cloned) return index;
                const currentIndex = parentNode.children.indexOf(child);
                return currentIndex >= index ? currentIndex + 1 : currentIndex;
            };

            parentNode.children = chain(parentNode.children, [
                fp.sortBy(newIndexOfchild)
            ]);

            s.currentNodeIsNew = false;
            
            savePackage(store, s);

            return s;
        });
    };

    const importAppDefinition = store => appDefinition => {
        store.update(s => {
            s.hierarchy = appDefinition.hierarchy;
            s.currentNode = appDefinition.hierarchy.children.length > 0
                             ? appDefinition.hierarchy.children[0] 
                             : null;
            s.actions = appDefinition.actions;
            s.triggers = appDefinition.triggers;
            s.currentNodeIsNew = false; 
            return s;
        });
    }; 

    const deleteCurrentNode = store => () => {
        store.update(s => {
            const nodeToDelete = getNode$1(s.hierarchy, s.currentNode.nodeId);
            s.currentNode = hierarchy.isRoot(nodeToDelete.parent())
                             ? fp.find(n => n != s.currentNode)
                                   (s.hierarchy.children)
                             : nodeToDelete.parent();
            if(hierarchy.isRecord(nodeToDelete)) {
                nodeToDelete.parent().children = fp.filter(c => c.nodeId !== nodeToDelete.nodeId)
                                                       (nodeToDelete.parent().children);
            } else {
                nodeToDelete.parent().indexes = fp.filter(c => c.nodeId !== nodeToDelete.nodeId)
                                                       (nodeToDelete.parent().indexes);
            }
            s.errors = [];
            savePackage(store, s);
            return s;
        });
    };

    const saveField = databaseStore => (field) => {
        databaseStore.update(db => {
            db.currentNode.fields = fp.filter(f => f.name !== field.name)
                                          (db.currentNode.fields);
                
            templateApi(db.hierarchy).addField(db.currentNode, field);
            return db;
        });
    };


    const deleteField = databaseStore => field => {
        databaseStore.update(db => {
            db.currentNode.fields = fp.filter(f => f.name !== field.name)
                                          (db.currentNode.fields);

            return db;
        });
    };


    const saveAction = store => (newAction, isNew, oldAction=null) => {
        store.update(s => {

            const existingAction = isNew 
                                   ? null
                                   : fp.find(a => a.name === oldAction.name)(s.actions);
                
            if(existingAction) {
                s.actions = chain(s.actions, [
                    fp.map(a => a === existingAction ? newAction : a)
                ]);
            } else {
                s.actions.push(newAction);
            }
            savePackage(store, s);
            return s;
        });
    };

    const deleteAction  = store => action => {
        store.update(s => {
            s.actions = fp.filter(a => a.name !== action.name)(s.actions);
            savePackage(store, s);
            return s;
        });
    };

    const saveTrigger = store => (newTrigger, isNew, oldTrigger=null) => {
        store.update(s => {

            const existingTrigger = isNew 
                                   ? null
                                   : fp.find(a => a.name === oldTrigger.name)(s.triggers);
                
            if(existingTrigger) {
                s.triggers = chain(s.triggers, [
                    fp.map(a => a === existingTrigger ? newTrigger : a)
                ]);
            } else {
                s.triggers.push(newTrigger);
            }
            savePackage(store, s);
            return s;
        });
    };

    const deleteTrigger  = store => trigger => {
        store.update(s => {
            s.triggers = fp.filter(t => t.name !== trigger.name)(s.triggers);
            return s;
        });
    };

    const saveLevel = store => (newLevel, isNew, oldLevel=null) => {
        store.update(s => {

            const existingLevel = isNew 
                                   ? null
                                   : fp.find(a => a.name === oldLevel.name)(s.accessLevels);
                
            if(existingLevel) {
                s.accessLevels = chain(s.accessLevels, [
                    fp.map(a => a === existingLevel ? newLevel : a)
                ]);
            } else {
                s.accessLevels.push(newLevel);
            }
            savePackage(store, s);
            return s;
        });
    };

    const deleteLevel = store => level => {
        store.update(s => {
            s.accessLevels = fp.filter(t => t.name !== level.name)(s.accessLevels);
            savePackage(store, s);
            return s;
        });
    };

    const setActiveNav = store => navName => {
        store.update(s => {
            s.activeNav = navName;
            return s;
        });
    };

    const createShadowHierarchy = hierarchy => 
        constructHierarchy$1(JSON.parse(JSON.stringify(hierarchy)));

    const saveDerivedComponent = store => (derivedComponent) => {

        store.update(s => {

            const derivedComponents = pipe(s.derivedComponents, [
                fp.filter(c => c._name !== derivedComponent._name)
            ]);

            s.derivedComponents = derivedComponents;

            api.post(`/_builder/api/${s.appname}/derivedcomponent`, derivedComponent);

            return s;
        });
    };

    const deleteDerivedComponent = store => name => {
        store.update(s => {

            const derivedComponents = pipe(s.derivedComponents, [
                fp.filter(c => c._name !== name)
            ]);

            s.derivedComponents = derivedComponents;

            api.delete(`/_builder/api/${s.appname}/derivedcomponent/${name}`);

            return s;
        });
    };

    const renameDerivedComponent = store => (oldname, newname) => {
        store.update(s => {

            const component = pipe(s.derivedComponents, [
                fp.find(c => c._name === name)
            ]);

            component._name = newname;

            const derivedComponents = pipe(s.derivedComponents, [
                fp.filter(c => c._name !== name),
                fp.concat(component)
            ]);

            s.derivedComponent = derivedComponents;

            api.patch(`/_builder/api/${s.appname}/derivedcomponent`, {
                oldname, newname
            });

            return s;
        });
    };

    const addComponentLibrary = store => async lib => {

        const response = 
            await api.get(`/_builder/api/${db.appname}/components?${encodeURI(lib)}`,undefined, true);

        const success = response.status === 200;

        const error = response.status === 404 
                      ? `Could not find library ${lib}`
                      : success
                      ? ""
                      : response.statusText;
        
        const components = success
                           ? await response.json()
                           : [];

        store.update(s => {
            s.componentsErrors.addComponent = error;
            if(success) {
                s.pages.componentLibraries.push(lib);
                s.rootComponents = [...s.rootComponents, components];
            }

            return s;
        });
        

    };

    const refreshComponents = store => async () => {

        const components = 
            await api.get(`/_builder/api/${db.appname}/components`);

        const rootComponents = pipe(components, [
            fp.keys,
            fp.map(k => ({...components[k], _name:k}))
        ]);

        store.update(s => {
            s.rootComponents = rootComponents;
            return s;
        });
    };

    const savePackage = (store, s) => {

        const appDefinition = {
            hierarchy:s.hierarchy,
            triggers:s.triggers,
            actions: fp.groupBy("name")(s.actions),
            pages:s.pages,
            mainUi: s.mainUi,
            unauthenticatedUi: s.unauthenticatedUi
        };

        const data = {
            appDefinition,
            accessLevels:s.accessLevels
        };

        api.post(`/_builder/api/${s.appname}/appPackage`, data);
    };

    const database = getStore();

    const initialise$1 = async () => {
        try {
            setupRouter(database);
            await database.initialise();
        } catch(err) {
            console.log(err);
        }

    }; 

    const setupRouter = (writable) => {
        const pushState = history.pushState;
        history.pushState = () => {
            pushState.apply(history, arguments);
            //fireEvents('pushState', arguments); 
            writable.initialise();
        };
        window.addEventListener('hashchange',()=>{
            writable.initialise();
        });
    };

    /* src\NoPackage.svelte generated by Svelte v3.6.9 */

    const file$2 = "src\\NoPackage.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.app = list[i];
    	return child_ctx;
    }

    // (17:16) {#each $database.apps as app}
    function create_each_block(ctx) {
    	var a, t_value = ctx.app, t, a_href_value;

    	return {
    		c: function create() {
    			a = element("a");
    			t = text(t_value);
    			attr(a, "href", a_href_value = `#/${ctx.app}`);
    			attr(a, "class", "app-link svelte-jymnqv");
    			add_location(a, file$2, 17, 16, 458);
    		},

    		m: function mount(target, anchor) {
    			insert(target, a, anchor);
    			append(a, t);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.$database) && t_value !== (t_value = ctx.app)) {
    				set_data(t, t_value);
    			}

    			if ((changed.$database) && a_href_value !== (a_href_value = `#/${ctx.app}`)) {
    				attr(a, "href", a_href_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(a);
    			}
    		}
    	};
    }

    function create_fragment$1(ctx) {
    	var div3, div2, img, t0, div1, div0, h4, t2;

    	var each_value = ctx.$database.apps;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			img = element("img");
    			t0 = space();
    			div1 = element("div");
    			div0 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Choose an Application";
    			t2 = space();

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			attr(img, "src", "/_builder/assets/budibase-logo.png");
    			attr(img, "class", "logo svelte-jymnqv");
    			attr(img, "alt", "budibase logo");
    			add_location(img, file$2, 11, 8, 189);
    			set_style(h4, "margin-bottom", "20px");
    			add_location(h4, file$2, 15, 16, 335);
    			add_location(div0, file$2, 14, 12, 312);
    			add_location(div1, file$2, 12, 8, 279);
    			attr(div2, "class", "inner svelte-jymnqv");
    			add_location(div2, file$2, 10, 4, 160);
    			attr(div3, "class", "root svelte-jymnqv");
    			add_location(div3, file$2, 9, 0, 136);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div3, anchor);
    			append(div3, div2);
    			append(div2, img);
    			append(div2, t0);
    			append(div2, div1);
    			append(div1, div0);
    			append(div0, h4);
    			append(div0, t2);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (changed.$database) {
    				each_value = ctx.$database.apps;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div3);
    			}

    			destroy_each(each_blocks, detaching);
    		}
    	};
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let $database;

    	validate_store(database, 'database');
    	subscribe($$self, database, $$value => { $database = $$value; $$invalidate('$database', $database); });

    	return { $database };
    }

    class NoPackage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, []);
    	}
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var feather = createCommonjsModule(function (module, exports) {
    (function webpackUniversalModuleDefinition(root, factory) {
    	module.exports = factory();
    })(typeof self !== 'undefined' ? self : commonjsGlobal, function() {
    return /******/ (function(modules) { // webpackBootstrap
    /******/ 	// The module cache
    /******/ 	var installedModules = {};
    /******/
    /******/ 	// The require function
    /******/ 	function __webpack_require__(moduleId) {
    /******/
    /******/ 		// Check if module is in cache
    /******/ 		if(installedModules[moduleId]) {
    /******/ 			return installedModules[moduleId].exports;
    /******/ 		}
    /******/ 		// Create a new module (and put it into the cache)
    /******/ 		var module = installedModules[moduleId] = {
    /******/ 			i: moduleId,
    /******/ 			l: false,
    /******/ 			exports: {}
    /******/ 		};
    /******/
    /******/ 		// Execute the module function
    /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/
    /******/ 		// Flag the module as loaded
    /******/ 		module.l = true;
    /******/
    /******/ 		// Return the exports of the module
    /******/ 		return module.exports;
    /******/ 	}
    /******/
    /******/
    /******/ 	// expose the modules object (__webpack_modules__)
    /******/ 	__webpack_require__.m = modules;
    /******/
    /******/ 	// expose the module cache
    /******/ 	__webpack_require__.c = installedModules;
    /******/
    /******/ 	// define getter function for harmony exports
    /******/ 	__webpack_require__.d = function(exports, name, getter) {
    /******/ 		if(!__webpack_require__.o(exports, name)) {
    /******/ 			Object.defineProperty(exports, name, {
    /******/ 				configurable: false,
    /******/ 				enumerable: true,
    /******/ 				get: getter
    /******/ 			});
    /******/ 		}
    /******/ 	};
    /******/
    /******/ 	// define __esModule on exports
    /******/ 	__webpack_require__.r = function(exports) {
    /******/ 		Object.defineProperty(exports, '__esModule', { value: true });
    /******/ 	};
    /******/
    /******/ 	// getDefaultExport function for compatibility with non-harmony modules
    /******/ 	__webpack_require__.n = function(module) {
    /******/ 		var getter = module && module.__esModule ?
    /******/ 			function getDefault() { return module['default']; } :
    /******/ 			function getModuleExports() { return module; };
    /******/ 		__webpack_require__.d(getter, 'a', getter);
    /******/ 		return getter;
    /******/ 	};
    /******/
    /******/ 	// Object.prototype.hasOwnProperty.call
    /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
    /******/
    /******/ 	// __webpack_public_path__
    /******/ 	__webpack_require__.p = "";
    /******/
    /******/
    /******/ 	// Load entry module and return exports
    /******/ 	return __webpack_require__(__webpack_require__.s = 0);
    /******/ })
    /************************************************************************/
    /******/ ({

    /***/ "./dist/icons.json":
    /*!*************************!*\
      !*** ./dist/icons.json ***!
      \*************************/
    /*! exports provided: activity, airplay, alert-circle, alert-octagon, alert-triangle, align-center, align-justify, align-left, align-right, anchor, aperture, archive, arrow-down-circle, arrow-down-left, arrow-down-right, arrow-down, arrow-left-circle, arrow-left, arrow-right-circle, arrow-right, arrow-up-circle, arrow-up-left, arrow-up-right, arrow-up, at-sign, award, bar-chart-2, bar-chart, battery-charging, battery, bell-off, bell, bluetooth, bold, book-open, book, bookmark, box, briefcase, calendar, camera-off, camera, cast, check-circle, check-square, check, chevron-down, chevron-left, chevron-right, chevron-up, chevrons-down, chevrons-left, chevrons-right, chevrons-up, chrome, circle, clipboard, clock, cloud-drizzle, cloud-lightning, cloud-off, cloud-rain, cloud-snow, cloud, code, codepen, codesandbox, coffee, columns, command, compass, copy, corner-down-left, corner-down-right, corner-left-down, corner-left-up, corner-right-down, corner-right-up, corner-up-left, corner-up-right, cpu, credit-card, crop, crosshair, database, delete, disc, dollar-sign, download-cloud, download, droplet, edit-2, edit-3, edit, external-link, eye-off, eye, facebook, fast-forward, feather, figma, file-minus, file-plus, file-text, file, film, filter, flag, folder-minus, folder-plus, folder, framer, frown, gift, git-branch, git-commit, git-merge, git-pull-request, github, gitlab, globe, grid, hard-drive, hash, headphones, heart, help-circle, hexagon, home, image, inbox, info, instagram, italic, key, layers, layout, life-buoy, link-2, link, linkedin, list, loader, lock, log-in, log-out, mail, map-pin, map, maximize-2, maximize, meh, menu, message-circle, message-square, mic-off, mic, minimize-2, minimize, minus-circle, minus-square, minus, monitor, moon, more-horizontal, more-vertical, mouse-pointer, move, music, navigation-2, navigation, octagon, package, paperclip, pause-circle, pause, pen-tool, percent, phone-call, phone-forwarded, phone-incoming, phone-missed, phone-off, phone-outgoing, phone, pie-chart, play-circle, play, plus-circle, plus-square, plus, pocket, power, printer, radio, refresh-ccw, refresh-cw, repeat, rewind, rotate-ccw, rotate-cw, rss, save, scissors, search, send, server, settings, share-2, share, shield-off, shield, shopping-bag, shopping-cart, shuffle, sidebar, skip-back, skip-forward, slack, slash, sliders, smartphone, smile, speaker, square, star, stop-circle, sun, sunrise, sunset, tablet, tag, target, terminal, thermometer, thumbs-down, thumbs-up, toggle-left, toggle-right, trash-2, trash, trello, trending-down, trending-up, triangle, truck, tv, twitter, type, umbrella, underline, unlock, upload-cloud, upload, user-check, user-minus, user-plus, user-x, user, users, video-off, video, voicemail, volume-1, volume-2, volume-x, volume, watch, wifi-off, wifi, wind, x-circle, x-octagon, x-square, x, youtube, zap-off, zap, zoom-in, zoom-out, default */
    /***/ (function(module) {

    module.exports = {"activity":"<polyline points=\"22 12 18 12 15 21 9 3 6 12 2 12\"></polyline>","airplay":"<path d=\"M5 17H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1\"></path><polygon points=\"12 15 17 21 7 21 12 15\"></polygon>","alert-circle":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><line x1=\"12\" y1=\"8\" x2=\"12\" y2=\"12\"></line><line x1=\"12\" y1=\"16\" x2=\"12\" y2=\"16\"></line>","alert-octagon":"<polygon points=\"7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2\"></polygon><line x1=\"12\" y1=\"8\" x2=\"12\" y2=\"12\"></line><line x1=\"12\" y1=\"16\" x2=\"12\" y2=\"16\"></line>","alert-triangle":"<path d=\"M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z\"></path><line x1=\"12\" y1=\"9\" x2=\"12\" y2=\"13\"></line><line x1=\"12\" y1=\"17\" x2=\"12\" y2=\"17\"></line>","align-center":"<line x1=\"18\" y1=\"10\" x2=\"6\" y2=\"10\"></line><line x1=\"21\" y1=\"6\" x2=\"3\" y2=\"6\"></line><line x1=\"21\" y1=\"14\" x2=\"3\" y2=\"14\"></line><line x1=\"18\" y1=\"18\" x2=\"6\" y2=\"18\"></line>","align-justify":"<line x1=\"21\" y1=\"10\" x2=\"3\" y2=\"10\"></line><line x1=\"21\" y1=\"6\" x2=\"3\" y2=\"6\"></line><line x1=\"21\" y1=\"14\" x2=\"3\" y2=\"14\"></line><line x1=\"21\" y1=\"18\" x2=\"3\" y2=\"18\"></line>","align-left":"<line x1=\"17\" y1=\"10\" x2=\"3\" y2=\"10\"></line><line x1=\"21\" y1=\"6\" x2=\"3\" y2=\"6\"></line><line x1=\"21\" y1=\"14\" x2=\"3\" y2=\"14\"></line><line x1=\"17\" y1=\"18\" x2=\"3\" y2=\"18\"></line>","align-right":"<line x1=\"21\" y1=\"10\" x2=\"7\" y2=\"10\"></line><line x1=\"21\" y1=\"6\" x2=\"3\" y2=\"6\"></line><line x1=\"21\" y1=\"14\" x2=\"3\" y2=\"14\"></line><line x1=\"21\" y1=\"18\" x2=\"7\" y2=\"18\"></line>","anchor":"<circle cx=\"12\" cy=\"5\" r=\"3\"></circle><line x1=\"12\" y1=\"22\" x2=\"12\" y2=\"8\"></line><path d=\"M5 12H2a10 10 0 0 0 20 0h-3\"></path>","aperture":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><line x1=\"14.31\" y1=\"8\" x2=\"20.05\" y2=\"17.94\"></line><line x1=\"9.69\" y1=\"8\" x2=\"21.17\" y2=\"8\"></line><line x1=\"7.38\" y1=\"12\" x2=\"13.12\" y2=\"2.06\"></line><line x1=\"9.69\" y1=\"16\" x2=\"3.95\" y2=\"6.06\"></line><line x1=\"14.31\" y1=\"16\" x2=\"2.83\" y2=\"16\"></line><line x1=\"16.62\" y1=\"12\" x2=\"10.88\" y2=\"21.94\"></line>","archive":"<polyline points=\"21 8 21 21 3 21 3 8\"></polyline><rect x=\"1\" y=\"3\" width=\"22\" height=\"5\"></rect><line x1=\"10\" y1=\"12\" x2=\"14\" y2=\"12\"></line>","arrow-down-circle":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><polyline points=\"8 12 12 16 16 12\"></polyline><line x1=\"12\" y1=\"8\" x2=\"12\" y2=\"16\"></line>","arrow-down-left":"<line x1=\"17\" y1=\"7\" x2=\"7\" y2=\"17\"></line><polyline points=\"17 17 7 17 7 7\"></polyline>","arrow-down-right":"<line x1=\"7\" y1=\"7\" x2=\"17\" y2=\"17\"></line><polyline points=\"17 7 17 17 7 17\"></polyline>","arrow-down":"<line x1=\"12\" y1=\"5\" x2=\"12\" y2=\"19\"></line><polyline points=\"19 12 12 19 5 12\"></polyline>","arrow-left-circle":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><polyline points=\"12 8 8 12 12 16\"></polyline><line x1=\"16\" y1=\"12\" x2=\"8\" y2=\"12\"></line>","arrow-left":"<line x1=\"19\" y1=\"12\" x2=\"5\" y2=\"12\"></line><polyline points=\"12 19 5 12 12 5\"></polyline>","arrow-right-circle":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><polyline points=\"12 16 16 12 12 8\"></polyline><line x1=\"8\" y1=\"12\" x2=\"16\" y2=\"12\"></line>","arrow-right":"<line x1=\"5\" y1=\"12\" x2=\"19\" y2=\"12\"></line><polyline points=\"12 5 19 12 12 19\"></polyline>","arrow-up-circle":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><polyline points=\"16 12 12 8 8 12\"></polyline><line x1=\"12\" y1=\"16\" x2=\"12\" y2=\"8\"></line>","arrow-up-left":"<line x1=\"17\" y1=\"17\" x2=\"7\" y2=\"7\"></line><polyline points=\"7 17 7 7 17 7\"></polyline>","arrow-up-right":"<line x1=\"7\" y1=\"17\" x2=\"17\" y2=\"7\"></line><polyline points=\"7 7 17 7 17 17\"></polyline>","arrow-up":"<line x1=\"12\" y1=\"19\" x2=\"12\" y2=\"5\"></line><polyline points=\"5 12 12 5 19 12\"></polyline>","at-sign":"<circle cx=\"12\" cy=\"12\" r=\"4\"></circle><path d=\"M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-3.92 7.94\"></path>","award":"<circle cx=\"12\" cy=\"8\" r=\"7\"></circle><polyline points=\"8.21 13.89 7 23 12 20 17 23 15.79 13.88\"></polyline>","bar-chart-2":"<line x1=\"18\" y1=\"20\" x2=\"18\" y2=\"10\"></line><line x1=\"12\" y1=\"20\" x2=\"12\" y2=\"4\"></line><line x1=\"6\" y1=\"20\" x2=\"6\" y2=\"14\"></line>","bar-chart":"<line x1=\"12\" y1=\"20\" x2=\"12\" y2=\"10\"></line><line x1=\"18\" y1=\"20\" x2=\"18\" y2=\"4\"></line><line x1=\"6\" y1=\"20\" x2=\"6\" y2=\"16\"></line>","battery-charging":"<path d=\"M5 18H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3.19M15 6h2a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-3.19\"></path><line x1=\"23\" y1=\"13\" x2=\"23\" y2=\"11\"></line><polyline points=\"11 6 7 12 13 12 9 18\"></polyline>","battery":"<rect x=\"1\" y=\"6\" width=\"18\" height=\"12\" rx=\"2\" ry=\"2\"></rect><line x1=\"23\" y1=\"13\" x2=\"23\" y2=\"11\"></line>","bell-off":"<path d=\"M13.73 21a2 2 0 0 1-3.46 0\"></path><path d=\"M18.63 13A17.89 17.89 0 0 1 18 8\"></path><path d=\"M6.26 6.26A5.86 5.86 0 0 0 6 8c0 7-3 9-3 9h14\"></path><path d=\"M18 8a6 6 0 0 0-9.33-5\"></path><line x1=\"1\" y1=\"1\" x2=\"23\" y2=\"23\"></line>","bell":"<path d=\"M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9\"></path><path d=\"M13.73 21a2 2 0 0 1-3.46 0\"></path>","bluetooth":"<polyline points=\"6.5 6.5 17.5 17.5 12 23 12 1 17.5 6.5 6.5 17.5\"></polyline>","bold":"<path d=\"M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z\"></path><path d=\"M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z\"></path>","book-open":"<path d=\"M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z\"></path><path d=\"M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z\"></path>","book":"<path d=\"M4 19.5A2.5 2.5 0 0 1 6.5 17H20\"></path><path d=\"M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z\"></path>","bookmark":"<path d=\"M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z\"></path>","box":"<path d=\"M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z\"></path><polyline points=\"3.27 6.96 12 12.01 20.73 6.96\"></polyline><line x1=\"12\" y1=\"22.08\" x2=\"12\" y2=\"12\"></line>","briefcase":"<rect x=\"2\" y=\"7\" width=\"20\" height=\"14\" rx=\"2\" ry=\"2\"></rect><path d=\"M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16\"></path>","calendar":"<rect x=\"3\" y=\"4\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"></rect><line x1=\"16\" y1=\"2\" x2=\"16\" y2=\"6\"></line><line x1=\"8\" y1=\"2\" x2=\"8\" y2=\"6\"></line><line x1=\"3\" y1=\"10\" x2=\"21\" y2=\"10\"></line>","camera-off":"<line x1=\"1\" y1=\"1\" x2=\"23\" y2=\"23\"></line><path d=\"M21 21H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3m3-3h6l2 3h4a2 2 0 0 1 2 2v9.34m-7.72-2.06a4 4 0 1 1-5.56-5.56\"></path>","camera":"<path d=\"M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z\"></path><circle cx=\"12\" cy=\"13\" r=\"4\"></circle>","cast":"<path d=\"M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6\"></path><line x1=\"2\" y1=\"20\" x2=\"2\" y2=\"20\"></line>","check-circle":"<path d=\"M22 11.08V12a10 10 0 1 1-5.93-9.14\"></path><polyline points=\"22 4 12 14.01 9 11.01\"></polyline>","check-square":"<polyline points=\"9 11 12 14 22 4\"></polyline><path d=\"M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11\"></path>","check":"<polyline points=\"20 6 9 17 4 12\"></polyline>","chevron-down":"<polyline points=\"6 9 12 15 18 9\"></polyline>","chevron-left":"<polyline points=\"15 18 9 12 15 6\"></polyline>","chevron-right":"<polyline points=\"9 18 15 12 9 6\"></polyline>","chevron-up":"<polyline points=\"18 15 12 9 6 15\"></polyline>","chevrons-down":"<polyline points=\"7 13 12 18 17 13\"></polyline><polyline points=\"7 6 12 11 17 6\"></polyline>","chevrons-left":"<polyline points=\"11 17 6 12 11 7\"></polyline><polyline points=\"18 17 13 12 18 7\"></polyline>","chevrons-right":"<polyline points=\"13 17 18 12 13 7\"></polyline><polyline points=\"6 17 11 12 6 7\"></polyline>","chevrons-up":"<polyline points=\"17 11 12 6 7 11\"></polyline><polyline points=\"17 18 12 13 7 18\"></polyline>","chrome":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><circle cx=\"12\" cy=\"12\" r=\"4\"></circle><line x1=\"21.17\" y1=\"8\" x2=\"12\" y2=\"8\"></line><line x1=\"3.95\" y1=\"6.06\" x2=\"8.54\" y2=\"14\"></line><line x1=\"10.88\" y1=\"21.94\" x2=\"15.46\" y2=\"14\"></line>","circle":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle>","clipboard":"<path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"></path><rect x=\"8\" y=\"2\" width=\"8\" height=\"4\" rx=\"1\" ry=\"1\"></rect>","clock":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><polyline points=\"12 6 12 12 16 14\"></polyline>","cloud-drizzle":"<line x1=\"8\" y1=\"19\" x2=\"8\" y2=\"21\"></line><line x1=\"8\" y1=\"13\" x2=\"8\" y2=\"15\"></line><line x1=\"16\" y1=\"19\" x2=\"16\" y2=\"21\"></line><line x1=\"16\" y1=\"13\" x2=\"16\" y2=\"15\"></line><line x1=\"12\" y1=\"21\" x2=\"12\" y2=\"23\"></line><line x1=\"12\" y1=\"15\" x2=\"12\" y2=\"17\"></line><path d=\"M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25\"></path>","cloud-lightning":"<path d=\"M19 16.9A5 5 0 0 0 18 7h-1.26a8 8 0 1 0-11.62 9\"></path><polyline points=\"13 11 9 17 15 17 11 23\"></polyline>","cloud-off":"<path d=\"M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 15h9a5 5 0 0 0 1.7-.3\"></path><line x1=\"1\" y1=\"1\" x2=\"23\" y2=\"23\"></line>","cloud-rain":"<line x1=\"16\" y1=\"13\" x2=\"16\" y2=\"21\"></line><line x1=\"8\" y1=\"13\" x2=\"8\" y2=\"21\"></line><line x1=\"12\" y1=\"15\" x2=\"12\" y2=\"23\"></line><path d=\"M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25\"></path>","cloud-snow":"<path d=\"M20 17.58A5 5 0 0 0 18 8h-1.26A8 8 0 1 0 4 16.25\"></path><line x1=\"8\" y1=\"16\" x2=\"8\" y2=\"16\"></line><line x1=\"8\" y1=\"20\" x2=\"8\" y2=\"20\"></line><line x1=\"12\" y1=\"18\" x2=\"12\" y2=\"18\"></line><line x1=\"12\" y1=\"22\" x2=\"12\" y2=\"22\"></line><line x1=\"16\" y1=\"16\" x2=\"16\" y2=\"16\"></line><line x1=\"16\" y1=\"20\" x2=\"16\" y2=\"20\"></line>","cloud":"<path d=\"M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z\"></path>","code":"<polyline points=\"16 18 22 12 16 6\"></polyline><polyline points=\"8 6 2 12 8 18\"></polyline>","codepen":"<polygon points=\"12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2\"></polygon><line x1=\"12\" y1=\"22\" x2=\"12\" y2=\"15.5\"></line><polyline points=\"22 8.5 12 15.5 2 8.5\"></polyline><polyline points=\"2 15.5 12 8.5 22 15.5\"></polyline><line x1=\"12\" y1=\"2\" x2=\"12\" y2=\"8.5\"></line>","codesandbox":"<path d=\"M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z\"></path><polyline points=\"7.5 4.21 12 6.81 16.5 4.21\"></polyline><polyline points=\"7.5 19.79 7.5 14.6 3 12\"></polyline><polyline points=\"21 12 16.5 14.6 16.5 19.79\"></polyline><polyline points=\"3.27 6.96 12 12.01 20.73 6.96\"></polyline><line x1=\"12\" y1=\"22.08\" x2=\"12\" y2=\"12\"></line>","coffee":"<path d=\"M18 8h1a4 4 0 0 1 0 8h-1\"></path><path d=\"M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z\"></path><line x1=\"6\" y1=\"1\" x2=\"6\" y2=\"4\"></line><line x1=\"10\" y1=\"1\" x2=\"10\" y2=\"4\"></line><line x1=\"14\" y1=\"1\" x2=\"14\" y2=\"4\"></line>","columns":"<path d=\"M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18\"></path>","command":"<path d=\"M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z\"></path>","compass":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><polygon points=\"16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76\"></polygon>","copy":"<rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect><path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path>","corner-down-left":"<polyline points=\"9 10 4 15 9 20\"></polyline><path d=\"M20 4v7a4 4 0 0 1-4 4H4\"></path>","corner-down-right":"<polyline points=\"15 10 20 15 15 20\"></polyline><path d=\"M4 4v7a4 4 0 0 0 4 4h12\"></path>","corner-left-down":"<polyline points=\"14 15 9 20 4 15\"></polyline><path d=\"M20 4h-7a4 4 0 0 0-4 4v12\"></path>","corner-left-up":"<polyline points=\"14 9 9 4 4 9\"></polyline><path d=\"M20 20h-7a4 4 0 0 1-4-4V4\"></path>","corner-right-down":"<polyline points=\"10 15 15 20 20 15\"></polyline><path d=\"M4 4h7a4 4 0 0 1 4 4v12\"></path>","corner-right-up":"<polyline points=\"10 9 15 4 20 9\"></polyline><path d=\"M4 20h7a4 4 0 0 0 4-4V4\"></path>","corner-up-left":"<polyline points=\"9 14 4 9 9 4\"></polyline><path d=\"M20 20v-7a4 4 0 0 0-4-4H4\"></path>","corner-up-right":"<polyline points=\"15 14 20 9 15 4\"></polyline><path d=\"M4 20v-7a4 4 0 0 1 4-4h12\"></path>","cpu":"<rect x=\"4\" y=\"4\" width=\"16\" height=\"16\" rx=\"2\" ry=\"2\"></rect><rect x=\"9\" y=\"9\" width=\"6\" height=\"6\"></rect><line x1=\"9\" y1=\"1\" x2=\"9\" y2=\"4\"></line><line x1=\"15\" y1=\"1\" x2=\"15\" y2=\"4\"></line><line x1=\"9\" y1=\"20\" x2=\"9\" y2=\"23\"></line><line x1=\"15\" y1=\"20\" x2=\"15\" y2=\"23\"></line><line x1=\"20\" y1=\"9\" x2=\"23\" y2=\"9\"></line><line x1=\"20\" y1=\"14\" x2=\"23\" y2=\"14\"></line><line x1=\"1\" y1=\"9\" x2=\"4\" y2=\"9\"></line><line x1=\"1\" y1=\"14\" x2=\"4\" y2=\"14\"></line>","credit-card":"<rect x=\"1\" y=\"4\" width=\"22\" height=\"16\" rx=\"2\" ry=\"2\"></rect><line x1=\"1\" y1=\"10\" x2=\"23\" y2=\"10\"></line>","crop":"<path d=\"M6.13 1L6 16a2 2 0 0 0 2 2h15\"></path><path d=\"M1 6.13L16 6a2 2 0 0 1 2 2v15\"></path>","crosshair":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><line x1=\"22\" y1=\"12\" x2=\"18\" y2=\"12\"></line><line x1=\"6\" y1=\"12\" x2=\"2\" y2=\"12\"></line><line x1=\"12\" y1=\"6\" x2=\"12\" y2=\"2\"></line><line x1=\"12\" y1=\"22\" x2=\"12\" y2=\"18\"></line>","database":"<ellipse cx=\"12\" cy=\"5\" rx=\"9\" ry=\"3\"></ellipse><path d=\"M21 12c0 1.66-4 3-9 3s-9-1.34-9-3\"></path><path d=\"M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5\"></path>","delete":"<path d=\"M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z\"></path><line x1=\"18\" y1=\"9\" x2=\"12\" y2=\"15\"></line><line x1=\"12\" y1=\"9\" x2=\"18\" y2=\"15\"></line>","disc":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><circle cx=\"12\" cy=\"12\" r=\"3\"></circle>","dollar-sign":"<line x1=\"12\" y1=\"1\" x2=\"12\" y2=\"23\"></line><path d=\"M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6\"></path>","download-cloud":"<polyline points=\"8 17 12 21 16 17\"></polyline><line x1=\"12\" y1=\"12\" x2=\"12\" y2=\"21\"></line><path d=\"M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29\"></path>","download":"<path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\"></path><polyline points=\"7 10 12 15 17 10\"></polyline><line x1=\"12\" y1=\"15\" x2=\"12\" y2=\"3\"></line>","droplet":"<path d=\"M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z\"></path>","edit-2":"<path d=\"M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z\"></path>","edit-3":"<path d=\"M12 20h9\"></path><path d=\"M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z\"></path>","edit":"<path d=\"M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7\"></path><path d=\"M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z\"></path>","external-link":"<path d=\"M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6\"></path><polyline points=\"15 3 21 3 21 9\"></polyline><line x1=\"10\" y1=\"14\" x2=\"21\" y2=\"3\"></line>","eye-off":"<path d=\"M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24\"></path><line x1=\"1\" y1=\"1\" x2=\"23\" y2=\"23\"></line>","eye":"<path d=\"M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z\"></path><circle cx=\"12\" cy=\"12\" r=\"3\"></circle>","facebook":"<path d=\"M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z\"></path>","fast-forward":"<polygon points=\"13 19 22 12 13 5 13 19\"></polygon><polygon points=\"2 19 11 12 2 5 2 19\"></polygon>","feather":"<path d=\"M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z\"></path><line x1=\"16\" y1=\"8\" x2=\"2\" y2=\"22\"></line><line x1=\"17.5\" y1=\"15\" x2=\"9\" y2=\"15\"></line>","figma":"<path d=\"M5 5.5A3.5 3.5 0 0 1 8.5 2H12v7H8.5A3.5 3.5 0 0 1 5 5.5z\"></path><path d=\"M12 2h3.5a3.5 3.5 0 1 1 0 7H12V2z\"></path><path d=\"M12 12.5a3.5 3.5 0 1 1 7 0 3.5 3.5 0 1 1-7 0z\"></path><path d=\"M5 19.5A3.5 3.5 0 0 1 8.5 16H12v3.5a3.5 3.5 0 1 1-7 0z\"></path><path d=\"M5 12.5A3.5 3.5 0 0 1 8.5 9H12v7H8.5A3.5 3.5 0 0 1 5 12.5z\"></path>","file-minus":"<path d=\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z\"></path><polyline points=\"14 2 14 8 20 8\"></polyline><line x1=\"9\" y1=\"15\" x2=\"15\" y2=\"15\"></line>","file-plus":"<path d=\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z\"></path><polyline points=\"14 2 14 8 20 8\"></polyline><line x1=\"12\" y1=\"18\" x2=\"12\" y2=\"12\"></line><line x1=\"9\" y1=\"15\" x2=\"15\" y2=\"15\"></line>","file-text":"<path d=\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z\"></path><polyline points=\"14 2 14 8 20 8\"></polyline><line x1=\"16\" y1=\"13\" x2=\"8\" y2=\"13\"></line><line x1=\"16\" y1=\"17\" x2=\"8\" y2=\"17\"></line><polyline points=\"10 9 9 9 8 9\"></polyline>","file":"<path d=\"M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z\"></path><polyline points=\"13 2 13 9 20 9\"></polyline>","film":"<rect x=\"2\" y=\"2\" width=\"20\" height=\"20\" rx=\"2.18\" ry=\"2.18\"></rect><line x1=\"7\" y1=\"2\" x2=\"7\" y2=\"22\"></line><line x1=\"17\" y1=\"2\" x2=\"17\" y2=\"22\"></line><line x1=\"2\" y1=\"12\" x2=\"22\" y2=\"12\"></line><line x1=\"2\" y1=\"7\" x2=\"7\" y2=\"7\"></line><line x1=\"2\" y1=\"17\" x2=\"7\" y2=\"17\"></line><line x1=\"17\" y1=\"17\" x2=\"22\" y2=\"17\"></line><line x1=\"17\" y1=\"7\" x2=\"22\" y2=\"7\"></line>","filter":"<polygon points=\"22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3\"></polygon>","flag":"<path d=\"M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z\"></path><line x1=\"4\" y1=\"22\" x2=\"4\" y2=\"15\"></line>","folder-minus":"<path d=\"M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z\"></path><line x1=\"9\" y1=\"14\" x2=\"15\" y2=\"14\"></line>","folder-plus":"<path d=\"M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z\"></path><line x1=\"12\" y1=\"11\" x2=\"12\" y2=\"17\"></line><line x1=\"9\" y1=\"14\" x2=\"15\" y2=\"14\"></line>","folder":"<path d=\"M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z\"></path>","framer":"<path d=\"M5 16V9h14V2H5l14 14h-7m-7 0l7 7v-7m-7 0h7\"></path>","frown":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><path d=\"M16 16s-1.5-2-4-2-4 2-4 2\"></path><line x1=\"9\" y1=\"9\" x2=\"9.01\" y2=\"9\"></line><line x1=\"15\" y1=\"9\" x2=\"15.01\" y2=\"9\"></line>","gift":"<polyline points=\"20 12 20 22 4 22 4 12\"></polyline><rect x=\"2\" y=\"7\" width=\"20\" height=\"5\"></rect><line x1=\"12\" y1=\"22\" x2=\"12\" y2=\"7\"></line><path d=\"M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z\"></path><path d=\"M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z\"></path>","git-branch":"<line x1=\"6\" y1=\"3\" x2=\"6\" y2=\"15\"></line><circle cx=\"18\" cy=\"6\" r=\"3\"></circle><circle cx=\"6\" cy=\"18\" r=\"3\"></circle><path d=\"M18 9a9 9 0 0 1-9 9\"></path>","git-commit":"<circle cx=\"12\" cy=\"12\" r=\"4\"></circle><line x1=\"1.05\" y1=\"12\" x2=\"7\" y2=\"12\"></line><line x1=\"17.01\" y1=\"12\" x2=\"22.96\" y2=\"12\"></line>","git-merge":"<circle cx=\"18\" cy=\"18\" r=\"3\"></circle><circle cx=\"6\" cy=\"6\" r=\"3\"></circle><path d=\"M6 21V9a9 9 0 0 0 9 9\"></path>","git-pull-request":"<circle cx=\"18\" cy=\"18\" r=\"3\"></circle><circle cx=\"6\" cy=\"6\" r=\"3\"></circle><path d=\"M13 6h3a2 2 0 0 1 2 2v7\"></path><line x1=\"6\" y1=\"9\" x2=\"6\" y2=\"21\"></line>","github":"<path d=\"M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22\"></path>","gitlab":"<path d=\"M22.65 14.39L12 22.13 1.35 14.39a.84.84 0 0 1-.3-.94l1.22-3.78 2.44-7.51A.42.42 0 0 1 4.82 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.49h8.1l2.44-7.51A.42.42 0 0 1 18.6 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.51L23 13.45a.84.84 0 0 1-.35.94z\"></path>","globe":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><line x1=\"2\" y1=\"12\" x2=\"22\" y2=\"12\"></line><path d=\"M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z\"></path>","grid":"<rect x=\"3\" y=\"3\" width=\"7\" height=\"7\"></rect><rect x=\"14\" y=\"3\" width=\"7\" height=\"7\"></rect><rect x=\"14\" y=\"14\" width=\"7\" height=\"7\"></rect><rect x=\"3\" y=\"14\" width=\"7\" height=\"7\"></rect>","hard-drive":"<line x1=\"22\" y1=\"12\" x2=\"2\" y2=\"12\"></line><path d=\"M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z\"></path><line x1=\"6\" y1=\"16\" x2=\"6\" y2=\"16\"></line><line x1=\"10\" y1=\"16\" x2=\"10\" y2=\"16\"></line>","hash":"<line x1=\"4\" y1=\"9\" x2=\"20\" y2=\"9\"></line><line x1=\"4\" y1=\"15\" x2=\"20\" y2=\"15\"></line><line x1=\"10\" y1=\"3\" x2=\"8\" y2=\"21\"></line><line x1=\"16\" y1=\"3\" x2=\"14\" y2=\"21\"></line>","headphones":"<path d=\"M3 18v-6a9 9 0 0 1 18 0v6\"></path><path d=\"M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z\"></path>","heart":"<path d=\"M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z\"></path>","help-circle":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><path d=\"M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3\"></path><line x1=\"12\" y1=\"17\" x2=\"12\" y2=\"17\"></line>","hexagon":"<path d=\"M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z\"></path>","home":"<path d=\"M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z\"></path><polyline points=\"9 22 9 12 15 12 15 22\"></polyline>","image":"<rect x=\"3\" y=\"3\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"></rect><circle cx=\"8.5\" cy=\"8.5\" r=\"1.5\"></circle><polyline points=\"21 15 16 10 5 21\"></polyline>","inbox":"<polyline points=\"22 12 16 12 14 15 10 15 8 12 2 12\"></polyline><path d=\"M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z\"></path>","info":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><line x1=\"12\" y1=\"16\" x2=\"12\" y2=\"12\"></line><line x1=\"12\" y1=\"8\" x2=\"12\" y2=\"8\"></line>","instagram":"<rect x=\"2\" y=\"2\" width=\"20\" height=\"20\" rx=\"5\" ry=\"5\"></rect><path d=\"M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z\"></path><line x1=\"17.5\" y1=\"6.5\" x2=\"17.5\" y2=\"6.5\"></line>","italic":"<line x1=\"19\" y1=\"4\" x2=\"10\" y2=\"4\"></line><line x1=\"14\" y1=\"20\" x2=\"5\" y2=\"20\"></line><line x1=\"15\" y1=\"4\" x2=\"9\" y2=\"20\"></line>","key":"<path d=\"M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4\"></path>","layers":"<polygon points=\"12 2 2 7 12 12 22 7 12 2\"></polygon><polyline points=\"2 17 12 22 22 17\"></polyline><polyline points=\"2 12 12 17 22 12\"></polyline>","layout":"<rect x=\"3\" y=\"3\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"></rect><line x1=\"3\" y1=\"9\" x2=\"21\" y2=\"9\"></line><line x1=\"9\" y1=\"21\" x2=\"9\" y2=\"9\"></line>","life-buoy":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><circle cx=\"12\" cy=\"12\" r=\"4\"></circle><line x1=\"4.93\" y1=\"4.93\" x2=\"9.17\" y2=\"9.17\"></line><line x1=\"14.83\" y1=\"14.83\" x2=\"19.07\" y2=\"19.07\"></line><line x1=\"14.83\" y1=\"9.17\" x2=\"19.07\" y2=\"4.93\"></line><line x1=\"14.83\" y1=\"9.17\" x2=\"18.36\" y2=\"5.64\"></line><line x1=\"4.93\" y1=\"19.07\" x2=\"9.17\" y2=\"14.83\"></line>","link-2":"<path d=\"M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3\"></path><line x1=\"8\" y1=\"12\" x2=\"16\" y2=\"12\"></line>","link":"<path d=\"M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71\"></path><path d=\"M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71\"></path>","linkedin":"<path d=\"M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z\"></path><rect x=\"2\" y=\"9\" width=\"4\" height=\"12\"></rect><circle cx=\"4\" cy=\"4\" r=\"2\"></circle>","list":"<line x1=\"8\" y1=\"6\" x2=\"21\" y2=\"6\"></line><line x1=\"8\" y1=\"12\" x2=\"21\" y2=\"12\"></line><line x1=\"8\" y1=\"18\" x2=\"21\" y2=\"18\"></line><line x1=\"3\" y1=\"6\" x2=\"3\" y2=\"6\"></line><line x1=\"3\" y1=\"12\" x2=\"3\" y2=\"12\"></line><line x1=\"3\" y1=\"18\" x2=\"3\" y2=\"18\"></line>","loader":"<line x1=\"12\" y1=\"2\" x2=\"12\" y2=\"6\"></line><line x1=\"12\" y1=\"18\" x2=\"12\" y2=\"22\"></line><line x1=\"4.93\" y1=\"4.93\" x2=\"7.76\" y2=\"7.76\"></line><line x1=\"16.24\" y1=\"16.24\" x2=\"19.07\" y2=\"19.07\"></line><line x1=\"2\" y1=\"12\" x2=\"6\" y2=\"12\"></line><line x1=\"18\" y1=\"12\" x2=\"22\" y2=\"12\"></line><line x1=\"4.93\" y1=\"19.07\" x2=\"7.76\" y2=\"16.24\"></line><line x1=\"16.24\" y1=\"7.76\" x2=\"19.07\" y2=\"4.93\"></line>","lock":"<rect x=\"3\" y=\"11\" width=\"18\" height=\"11\" rx=\"2\" ry=\"2\"></rect><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"></path>","log-in":"<path d=\"M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4\"></path><polyline points=\"10 17 15 12 10 7\"></polyline><line x1=\"15\" y1=\"12\" x2=\"3\" y2=\"12\"></line>","log-out":"<path d=\"M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4\"></path><polyline points=\"16 17 21 12 16 7\"></polyline><line x1=\"21\" y1=\"12\" x2=\"9\" y2=\"12\"></line>","mail":"<path d=\"M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z\"></path><polyline points=\"22,6 12,13 2,6\"></polyline>","map-pin":"<path d=\"M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z\"></path><circle cx=\"12\" cy=\"10\" r=\"3\"></circle>","map":"<polygon points=\"1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6\"></polygon><line x1=\"8\" y1=\"2\" x2=\"8\" y2=\"18\"></line><line x1=\"16\" y1=\"6\" x2=\"16\" y2=\"22\"></line>","maximize-2":"<polyline points=\"15 3 21 3 21 9\"></polyline><polyline points=\"9 21 3 21 3 15\"></polyline><line x1=\"21\" y1=\"3\" x2=\"14\" y2=\"10\"></line><line x1=\"3\" y1=\"21\" x2=\"10\" y2=\"14\"></line>","maximize":"<path d=\"M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3\"></path>","meh":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><line x1=\"8\" y1=\"15\" x2=\"16\" y2=\"15\"></line><line x1=\"9\" y1=\"9\" x2=\"9.01\" y2=\"9\"></line><line x1=\"15\" y1=\"9\" x2=\"15.01\" y2=\"9\"></line>","menu":"<line x1=\"3\" y1=\"12\" x2=\"21\" y2=\"12\"></line><line x1=\"3\" y1=\"6\" x2=\"21\" y2=\"6\"></line><line x1=\"3\" y1=\"18\" x2=\"21\" y2=\"18\"></line>","message-circle":"<path d=\"M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z\"></path>","message-square":"<path d=\"M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z\"></path>","mic-off":"<line x1=\"1\" y1=\"1\" x2=\"23\" y2=\"23\"></line><path d=\"M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6\"></path><path d=\"M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23\"></path><line x1=\"12\" y1=\"19\" x2=\"12\" y2=\"23\"></line><line x1=\"8\" y1=\"23\" x2=\"16\" y2=\"23\"></line>","mic":"<path d=\"M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z\"></path><path d=\"M19 10v2a7 7 0 0 1-14 0v-2\"></path><line x1=\"12\" y1=\"19\" x2=\"12\" y2=\"23\"></line><line x1=\"8\" y1=\"23\" x2=\"16\" y2=\"23\"></line>","minimize-2":"<polyline points=\"4 14 10 14 10 20\"></polyline><polyline points=\"20 10 14 10 14 4\"></polyline><line x1=\"14\" y1=\"10\" x2=\"21\" y2=\"3\"></line><line x1=\"3\" y1=\"21\" x2=\"10\" y2=\"14\"></line>","minimize":"<path d=\"M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3\"></path>","minus-circle":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><line x1=\"8\" y1=\"12\" x2=\"16\" y2=\"12\"></line>","minus-square":"<rect x=\"3\" y=\"3\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"></rect><line x1=\"8\" y1=\"12\" x2=\"16\" y2=\"12\"></line>","minus":"<line x1=\"5\" y1=\"12\" x2=\"19\" y2=\"12\"></line>","monitor":"<rect x=\"2\" y=\"3\" width=\"20\" height=\"14\" rx=\"2\" ry=\"2\"></rect><line x1=\"8\" y1=\"21\" x2=\"16\" y2=\"21\"></line><line x1=\"12\" y1=\"17\" x2=\"12\" y2=\"21\"></line>","moon":"<path d=\"M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z\"></path>","more-horizontal":"<circle cx=\"12\" cy=\"12\" r=\"1\"></circle><circle cx=\"19\" cy=\"12\" r=\"1\"></circle><circle cx=\"5\" cy=\"12\" r=\"1\"></circle>","more-vertical":"<circle cx=\"12\" cy=\"12\" r=\"1\"></circle><circle cx=\"12\" cy=\"5\" r=\"1\"></circle><circle cx=\"12\" cy=\"19\" r=\"1\"></circle>","mouse-pointer":"<path d=\"M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z\"></path><path d=\"M13 13l6 6\"></path>","move":"<polyline points=\"5 9 2 12 5 15\"></polyline><polyline points=\"9 5 12 2 15 5\"></polyline><polyline points=\"15 19 12 22 9 19\"></polyline><polyline points=\"19 9 22 12 19 15\"></polyline><line x1=\"2\" y1=\"12\" x2=\"22\" y2=\"12\"></line><line x1=\"12\" y1=\"2\" x2=\"12\" y2=\"22\"></line>","music":"<path d=\"M9 18V5l12-2v13\"></path><circle cx=\"6\" cy=\"18\" r=\"3\"></circle><circle cx=\"18\" cy=\"16\" r=\"3\"></circle>","navigation-2":"<polygon points=\"12 2 19 21 12 17 5 21 12 2\"></polygon>","navigation":"<polygon points=\"3 11 22 2 13 21 11 13 3 11\"></polygon>","octagon":"<polygon points=\"7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2\"></polygon>","package":"<line x1=\"16.5\" y1=\"9.4\" x2=\"7.5\" y2=\"4.21\"></line><path d=\"M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z\"></path><polyline points=\"3.27 6.96 12 12.01 20.73 6.96\"></polyline><line x1=\"12\" y1=\"22.08\" x2=\"12\" y2=\"12\"></line>","paperclip":"<path d=\"M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48\"></path>","pause-circle":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><line x1=\"10\" y1=\"15\" x2=\"10\" y2=\"9\"></line><line x1=\"14\" y1=\"15\" x2=\"14\" y2=\"9\"></line>","pause":"<rect x=\"6\" y=\"4\" width=\"4\" height=\"16\"></rect><rect x=\"14\" y=\"4\" width=\"4\" height=\"16\"></rect>","pen-tool":"<path d=\"M12 19l7-7 3 3-7 7-3-3z\"></path><path d=\"M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z\"></path><path d=\"M2 2l7.586 7.586\"></path><circle cx=\"11\" cy=\"11\" r=\"2\"></circle>","percent":"<line x1=\"19\" y1=\"5\" x2=\"5\" y2=\"19\"></line><circle cx=\"6.5\" cy=\"6.5\" r=\"2.5\"></circle><circle cx=\"17.5\" cy=\"17.5\" r=\"2.5\"></circle>","phone-call":"<path d=\"M15.05 5A5 5 0 0 1 19 8.95M15.05 1A9 9 0 0 1 23 8.94m-1 7.98v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\"></path>","phone-forwarded":"<polyline points=\"19 1 23 5 19 9\"></polyline><line x1=\"15\" y1=\"5\" x2=\"23\" y2=\"5\"></line><path d=\"M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\"></path>","phone-incoming":"<polyline points=\"16 2 16 8 22 8\"></polyline><line x1=\"23\" y1=\"1\" x2=\"16\" y2=\"8\"></line><path d=\"M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\"></path>","phone-missed":"<line x1=\"23\" y1=\"1\" x2=\"17\" y2=\"7\"></line><line x1=\"17\" y1=\"1\" x2=\"23\" y2=\"7\"></line><path d=\"M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\"></path>","phone-off":"<path d=\"M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91\"></path><line x1=\"23\" y1=\"1\" x2=\"1\" y2=\"23\"></line>","phone-outgoing":"<polyline points=\"23 7 23 1 17 1\"></polyline><line x1=\"16\" y1=\"8\" x2=\"23\" y2=\"1\"></line><path d=\"M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\"></path>","phone":"<path d=\"M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\"></path>","pie-chart":"<path d=\"M21.21 15.89A10 10 0 1 1 8 2.83\"></path><path d=\"M22 12A10 10 0 0 0 12 2v10z\"></path>","play-circle":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><polygon points=\"10 8 16 12 10 16 10 8\"></polygon>","play":"<polygon points=\"5 3 19 12 5 21 5 3\"></polygon>","plus-circle":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><line x1=\"12\" y1=\"8\" x2=\"12\" y2=\"16\"></line><line x1=\"8\" y1=\"12\" x2=\"16\" y2=\"12\"></line>","plus-square":"<rect x=\"3\" y=\"3\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"></rect><line x1=\"12\" y1=\"8\" x2=\"12\" y2=\"16\"></line><line x1=\"8\" y1=\"12\" x2=\"16\" y2=\"12\"></line>","plus":"<line x1=\"12\" y1=\"5\" x2=\"12\" y2=\"19\"></line><line x1=\"5\" y1=\"12\" x2=\"19\" y2=\"12\"></line>","pocket":"<path d=\"M4 3h16a2 2 0 0 1 2 2v6a10 10 0 0 1-10 10A10 10 0 0 1 2 11V5a2 2 0 0 1 2-2z\"></path><polyline points=\"8 10 12 14 16 10\"></polyline>","power":"<path d=\"M18.36 6.64a9 9 0 1 1-12.73 0\"></path><line x1=\"12\" y1=\"2\" x2=\"12\" y2=\"12\"></line>","printer":"<polyline points=\"6 9 6 2 18 2 18 9\"></polyline><path d=\"M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2\"></path><rect x=\"6\" y=\"14\" width=\"12\" height=\"8\"></rect>","radio":"<circle cx=\"12\" cy=\"12\" r=\"2\"></circle><path d=\"M16.24 7.76a6 6 0 0 1 0 8.49m-8.48-.01a6 6 0 0 1 0-8.49m11.31-2.82a10 10 0 0 1 0 14.14m-14.14 0a10 10 0 0 1 0-14.14\"></path>","refresh-ccw":"<polyline points=\"1 4 1 10 7 10\"></polyline><polyline points=\"23 20 23 14 17 14\"></polyline><path d=\"M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15\"></path>","refresh-cw":"<polyline points=\"23 4 23 10 17 10\"></polyline><polyline points=\"1 20 1 14 7 14\"></polyline><path d=\"M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15\"></path>","repeat":"<polyline points=\"17 1 21 5 17 9\"></polyline><path d=\"M3 11V9a4 4 0 0 1 4-4h14\"></path><polyline points=\"7 23 3 19 7 15\"></polyline><path d=\"M21 13v2a4 4 0 0 1-4 4H3\"></path>","rewind":"<polygon points=\"11 19 2 12 11 5 11 19\"></polygon><polygon points=\"22 19 13 12 22 5 22 19\"></polygon>","rotate-ccw":"<polyline points=\"1 4 1 10 7 10\"></polyline><path d=\"M3.51 15a9 9 0 1 0 2.13-9.36L1 10\"></path>","rotate-cw":"<polyline points=\"23 4 23 10 17 10\"></polyline><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"></path>","rss":"<path d=\"M4 11a9 9 0 0 1 9 9\"></path><path d=\"M4 4a16 16 0 0 1 16 16\"></path><circle cx=\"5\" cy=\"19\" r=\"1\"></circle>","save":"<path d=\"M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z\"></path><polyline points=\"17 21 17 13 7 13 7 21\"></polyline><polyline points=\"7 3 7 8 15 8\"></polyline>","scissors":"<circle cx=\"6\" cy=\"6\" r=\"3\"></circle><circle cx=\"6\" cy=\"18\" r=\"3\"></circle><line x1=\"20\" y1=\"4\" x2=\"8.12\" y2=\"15.88\"></line><line x1=\"14.47\" y1=\"14.48\" x2=\"20\" y2=\"20\"></line><line x1=\"8.12\" y1=\"8.12\" x2=\"12\" y2=\"12\"></line>","search":"<circle cx=\"11\" cy=\"11\" r=\"8\"></circle><line x1=\"21\" y1=\"21\" x2=\"16.65\" y2=\"16.65\"></line>","send":"<line x1=\"22\" y1=\"2\" x2=\"11\" y2=\"13\"></line><polygon points=\"22 2 15 22 11 13 2 9 22 2\"></polygon>","server":"<rect x=\"2\" y=\"2\" width=\"20\" height=\"8\" rx=\"2\" ry=\"2\"></rect><rect x=\"2\" y=\"14\" width=\"20\" height=\"8\" rx=\"2\" ry=\"2\"></rect><line x1=\"6\" y1=\"6\" x2=\"6\" y2=\"6\"></line><line x1=\"6\" y1=\"18\" x2=\"6\" y2=\"18\"></line>","settings":"<circle cx=\"12\" cy=\"12\" r=\"3\"></circle><path d=\"M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z\"></path>","share-2":"<circle cx=\"18\" cy=\"5\" r=\"3\"></circle><circle cx=\"6\" cy=\"12\" r=\"3\"></circle><circle cx=\"18\" cy=\"19\" r=\"3\"></circle><line x1=\"8.59\" y1=\"13.51\" x2=\"15.42\" y2=\"17.49\"></line><line x1=\"15.41\" y1=\"6.51\" x2=\"8.59\" y2=\"10.49\"></line>","share":"<path d=\"M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8\"></path><polyline points=\"16 6 12 2 8 6\"></polyline><line x1=\"12\" y1=\"2\" x2=\"12\" y2=\"15\"></line>","shield-off":"<path d=\"M19.69 14a6.9 6.9 0 0 0 .31-2V5l-8-3-3.16 1.18\"></path><path d=\"M4.73 4.73L4 5v7c0 6 8 10 8 10a20.29 20.29 0 0 0 5.62-4.38\"></path><line x1=\"1\" y1=\"1\" x2=\"23\" y2=\"23\"></line>","shield":"<path d=\"M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z\"></path>","shopping-bag":"<path d=\"M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z\"></path><line x1=\"3\" y1=\"6\" x2=\"21\" y2=\"6\"></line><path d=\"M16 10a4 4 0 0 1-8 0\"></path>","shopping-cart":"<circle cx=\"9\" cy=\"21\" r=\"1\"></circle><circle cx=\"20\" cy=\"21\" r=\"1\"></circle><path d=\"M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6\"></path>","shuffle":"<polyline points=\"16 3 21 3 21 8\"></polyline><line x1=\"4\" y1=\"20\" x2=\"21\" y2=\"3\"></line><polyline points=\"21 16 21 21 16 21\"></polyline><line x1=\"15\" y1=\"15\" x2=\"21\" y2=\"21\"></line><line x1=\"4\" y1=\"4\" x2=\"9\" y2=\"9\"></line>","sidebar":"<rect x=\"3\" y=\"3\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"></rect><line x1=\"9\" y1=\"3\" x2=\"9\" y2=\"21\"></line>","skip-back":"<polygon points=\"19 20 9 12 19 4 19 20\"></polygon><line x1=\"5\" y1=\"19\" x2=\"5\" y2=\"5\"></line>","skip-forward":"<polygon points=\"5 4 15 12 5 20 5 4\"></polygon><line x1=\"19\" y1=\"5\" x2=\"19\" y2=\"19\"></line>","slack":"<path d=\"M14.5 10c-.83 0-1.5-.67-1.5-1.5v-5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5z\"></path><path d=\"M20.5 10H19V8.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z\"></path><path d=\"M9.5 14c.83 0 1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5S8 21.33 8 20.5v-5c0-.83.67-1.5 1.5-1.5z\"></path><path d=\"M3.5 14H5v1.5c0 .83-.67 1.5-1.5 1.5S2 16.33 2 15.5 2.67 14 3.5 14z\"></path><path d=\"M14 14.5c0-.83.67-1.5 1.5-1.5h5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-5c-.83 0-1.5-.67-1.5-1.5z\"></path><path d=\"M15.5 19H14v1.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z\"></path><path d=\"M10 9.5C10 8.67 9.33 8 8.5 8h-5C2.67 8 2 8.67 2 9.5S2.67 11 3.5 11h5c.83 0 1.5-.67 1.5-1.5z\"></path><path d=\"M8.5 5H10V3.5C10 2.67 9.33 2 8.5 2S7 2.67 7 3.5 7.67 5 8.5 5z\"></path>","slash":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><line x1=\"4.93\" y1=\"4.93\" x2=\"19.07\" y2=\"19.07\"></line>","sliders":"<line x1=\"4\" y1=\"21\" x2=\"4\" y2=\"14\"></line><line x1=\"4\" y1=\"10\" x2=\"4\" y2=\"3\"></line><line x1=\"12\" y1=\"21\" x2=\"12\" y2=\"12\"></line><line x1=\"12\" y1=\"8\" x2=\"12\" y2=\"3\"></line><line x1=\"20\" y1=\"21\" x2=\"20\" y2=\"16\"></line><line x1=\"20\" y1=\"12\" x2=\"20\" y2=\"3\"></line><line x1=\"1\" y1=\"14\" x2=\"7\" y2=\"14\"></line><line x1=\"9\" y1=\"8\" x2=\"15\" y2=\"8\"></line><line x1=\"17\" y1=\"16\" x2=\"23\" y2=\"16\"></line>","smartphone":"<rect x=\"5\" y=\"2\" width=\"14\" height=\"20\" rx=\"2\" ry=\"2\"></rect><line x1=\"12\" y1=\"18\" x2=\"12\" y2=\"18\"></line>","smile":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><path d=\"M8 14s1.5 2 4 2 4-2 4-2\"></path><line x1=\"9\" y1=\"9\" x2=\"9.01\" y2=\"9\"></line><line x1=\"15\" y1=\"9\" x2=\"15.01\" y2=\"9\"></line>","speaker":"<rect x=\"4\" y=\"2\" width=\"16\" height=\"20\" rx=\"2\" ry=\"2\"></rect><circle cx=\"12\" cy=\"14\" r=\"4\"></circle><line x1=\"12\" y1=\"6\" x2=\"12\" y2=\"6\"></line>","square":"<rect x=\"3\" y=\"3\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"></rect>","star":"<polygon points=\"12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2\"></polygon>","stop-circle":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><rect x=\"9\" y=\"9\" width=\"6\" height=\"6\"></rect>","sun":"<circle cx=\"12\" cy=\"12\" r=\"5\"></circle><line x1=\"12\" y1=\"1\" x2=\"12\" y2=\"3\"></line><line x1=\"12\" y1=\"21\" x2=\"12\" y2=\"23\"></line><line x1=\"4.22\" y1=\"4.22\" x2=\"5.64\" y2=\"5.64\"></line><line x1=\"18.36\" y1=\"18.36\" x2=\"19.78\" y2=\"19.78\"></line><line x1=\"1\" y1=\"12\" x2=\"3\" y2=\"12\"></line><line x1=\"21\" y1=\"12\" x2=\"23\" y2=\"12\"></line><line x1=\"4.22\" y1=\"19.78\" x2=\"5.64\" y2=\"18.36\"></line><line x1=\"18.36\" y1=\"5.64\" x2=\"19.78\" y2=\"4.22\"></line>","sunrise":"<path d=\"M17 18a5 5 0 0 0-10 0\"></path><line x1=\"12\" y1=\"2\" x2=\"12\" y2=\"9\"></line><line x1=\"4.22\" y1=\"10.22\" x2=\"5.64\" y2=\"11.64\"></line><line x1=\"1\" y1=\"18\" x2=\"3\" y2=\"18\"></line><line x1=\"21\" y1=\"18\" x2=\"23\" y2=\"18\"></line><line x1=\"18.36\" y1=\"11.64\" x2=\"19.78\" y2=\"10.22\"></line><line x1=\"23\" y1=\"22\" x2=\"1\" y2=\"22\"></line><polyline points=\"8 6 12 2 16 6\"></polyline>","sunset":"<path d=\"M17 18a5 5 0 0 0-10 0\"></path><line x1=\"12\" y1=\"9\" x2=\"12\" y2=\"2\"></line><line x1=\"4.22\" y1=\"10.22\" x2=\"5.64\" y2=\"11.64\"></line><line x1=\"1\" y1=\"18\" x2=\"3\" y2=\"18\"></line><line x1=\"21\" y1=\"18\" x2=\"23\" y2=\"18\"></line><line x1=\"18.36\" y1=\"11.64\" x2=\"19.78\" y2=\"10.22\"></line><line x1=\"23\" y1=\"22\" x2=\"1\" y2=\"22\"></line><polyline points=\"16 5 12 9 8 5\"></polyline>","tablet":"<rect x=\"4\" y=\"2\" width=\"16\" height=\"20\" rx=\"2\" ry=\"2\" transform=\"rotate(180 12 12)\"></rect><line x1=\"12\" y1=\"18\" x2=\"12\" y2=\"18\"></line>","tag":"<path d=\"M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z\"></path><line x1=\"7\" y1=\"7\" x2=\"7\" y2=\"7\"></line>","target":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><circle cx=\"12\" cy=\"12\" r=\"6\"></circle><circle cx=\"12\" cy=\"12\" r=\"2\"></circle>","terminal":"<polyline points=\"4 17 10 11 4 5\"></polyline><line x1=\"12\" y1=\"19\" x2=\"20\" y2=\"19\"></line>","thermometer":"<path d=\"M14 14.76V3.5a2.5 2.5 0 0 0-5 0v11.26a4.5 4.5 0 1 0 5 0z\"></path>","thumbs-down":"<path d=\"M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17\"></path>","thumbs-up":"<path d=\"M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3\"></path>","toggle-left":"<rect x=\"1\" y=\"5\" width=\"22\" height=\"14\" rx=\"7\" ry=\"7\"></rect><circle cx=\"8\" cy=\"12\" r=\"3\"></circle>","toggle-right":"<rect x=\"1\" y=\"5\" width=\"22\" height=\"14\" rx=\"7\" ry=\"7\"></rect><circle cx=\"16\" cy=\"12\" r=\"3\"></circle>","trash-2":"<polyline points=\"3 6 5 6 21 6\"></polyline><path d=\"M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2\"></path><line x1=\"10\" y1=\"11\" x2=\"10\" y2=\"17\"></line><line x1=\"14\" y1=\"11\" x2=\"14\" y2=\"17\"></line>","trash":"<polyline points=\"3 6 5 6 21 6\"></polyline><path d=\"M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2\"></path>","trello":"<rect x=\"3\" y=\"3\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"></rect><rect x=\"7\" y=\"7\" width=\"3\" height=\"9\"></rect><rect x=\"14\" y=\"7\" width=\"3\" height=\"5\"></rect>","trending-down":"<polyline points=\"23 18 13.5 8.5 8.5 13.5 1 6\"></polyline><polyline points=\"17 18 23 18 23 12\"></polyline>","trending-up":"<polyline points=\"23 6 13.5 15.5 8.5 10.5 1 18\"></polyline><polyline points=\"17 6 23 6 23 12\"></polyline>","triangle":"<path d=\"M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z\"></path>","truck":"<rect x=\"1\" y=\"3\" width=\"15\" height=\"13\"></rect><polygon points=\"16 8 20 8 23 11 23 16 16 16 16 8\"></polygon><circle cx=\"5.5\" cy=\"18.5\" r=\"2.5\"></circle><circle cx=\"18.5\" cy=\"18.5\" r=\"2.5\"></circle>","tv":"<rect x=\"2\" y=\"7\" width=\"20\" height=\"15\" rx=\"2\" ry=\"2\"></rect><polyline points=\"17 2 12 7 7 2\"></polyline>","twitter":"<path d=\"M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z\"></path>","type":"<polyline points=\"4 7 4 4 20 4 20 7\"></polyline><line x1=\"9\" y1=\"20\" x2=\"15\" y2=\"20\"></line><line x1=\"12\" y1=\"4\" x2=\"12\" y2=\"20\"></line>","umbrella":"<path d=\"M23 12a11.05 11.05 0 0 0-22 0zm-5 7a3 3 0 0 1-6 0v-7\"></path>","underline":"<path d=\"M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3\"></path><line x1=\"4\" y1=\"21\" x2=\"20\" y2=\"21\"></line>","unlock":"<rect x=\"3\" y=\"11\" width=\"18\" height=\"11\" rx=\"2\" ry=\"2\"></rect><path d=\"M7 11V7a5 5 0 0 1 9.9-1\"></path>","upload-cloud":"<polyline points=\"16 16 12 12 8 16\"></polyline><line x1=\"12\" y1=\"12\" x2=\"12\" y2=\"21\"></line><path d=\"M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3\"></path><polyline points=\"16 16 12 12 8 16\"></polyline>","upload":"<path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\"></path><polyline points=\"17 8 12 3 7 8\"></polyline><line x1=\"12\" y1=\"3\" x2=\"12\" y2=\"15\"></line>","user-check":"<path d=\"M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\"></path><circle cx=\"8.5\" cy=\"7\" r=\"4\"></circle><polyline points=\"17 11 19 13 23 9\"></polyline>","user-minus":"<path d=\"M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\"></path><circle cx=\"8.5\" cy=\"7\" r=\"4\"></circle><line x1=\"23\" y1=\"11\" x2=\"17\" y2=\"11\"></line>","user-plus":"<path d=\"M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\"></path><circle cx=\"8.5\" cy=\"7\" r=\"4\"></circle><line x1=\"20\" y1=\"8\" x2=\"20\" y2=\"14\"></line><line x1=\"23\" y1=\"11\" x2=\"17\" y2=\"11\"></line>","user-x":"<path d=\"M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\"></path><circle cx=\"8.5\" cy=\"7\" r=\"4\"></circle><line x1=\"18\" y1=\"8\" x2=\"23\" y2=\"13\"></line><line x1=\"23\" y1=\"8\" x2=\"18\" y2=\"13\"></line>","user":"<path d=\"M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2\"></path><circle cx=\"12\" cy=\"7\" r=\"4\"></circle>","users":"<path d=\"M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\"></path><circle cx=\"9\" cy=\"7\" r=\"4\"></circle><path d=\"M23 21v-2a4 4 0 0 0-3-3.87\"></path><path d=\"M16 3.13a4 4 0 0 1 0 7.75\"></path>","video-off":"<path d=\"M16 16v1a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2m5.66 0H14a2 2 0 0 1 2 2v3.34l1 1L23 7v10\"></path><line x1=\"1\" y1=\"1\" x2=\"23\" y2=\"23\"></line>","video":"<polygon points=\"23 7 16 12 23 17 23 7\"></polygon><rect x=\"1\" y=\"5\" width=\"15\" height=\"14\" rx=\"2\" ry=\"2\"></rect>","voicemail":"<circle cx=\"5.5\" cy=\"11.5\" r=\"4.5\"></circle><circle cx=\"18.5\" cy=\"11.5\" r=\"4.5\"></circle><line x1=\"5.5\" y1=\"16\" x2=\"18.5\" y2=\"16\"></line>","volume-1":"<polygon points=\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\"></polygon><path d=\"M15.54 8.46a5 5 0 0 1 0 7.07\"></path>","volume-2":"<polygon points=\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\"></polygon><path d=\"M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07\"></path>","volume-x":"<polygon points=\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\"></polygon><line x1=\"23\" y1=\"9\" x2=\"17\" y2=\"15\"></line><line x1=\"17\" y1=\"9\" x2=\"23\" y2=\"15\"></line>","volume":"<polygon points=\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\"></polygon>","watch":"<circle cx=\"12\" cy=\"12\" r=\"7\"></circle><polyline points=\"12 9 12 12 13.5 13.5\"></polyline><path d=\"M16.51 17.35l-.35 3.83a2 2 0 0 1-2 1.82H9.83a2 2 0 0 1-2-1.82l-.35-3.83m.01-10.7l.35-3.83A2 2 0 0 1 9.83 1h4.35a2 2 0 0 1 2 1.82l.35 3.83\"></path>","wifi-off":"<line x1=\"1\" y1=\"1\" x2=\"23\" y2=\"23\"></line><path d=\"M16.72 11.06A10.94 10.94 0 0 1 19 12.55\"></path><path d=\"M5 12.55a10.94 10.94 0 0 1 5.17-2.39\"></path><path d=\"M10.71 5.05A16 16 0 0 1 22.58 9\"></path><path d=\"M1.42 9a15.91 15.91 0 0 1 4.7-2.88\"></path><path d=\"M8.53 16.11a6 6 0 0 1 6.95 0\"></path><line x1=\"12\" y1=\"20\" x2=\"12\" y2=\"20\"></line>","wifi":"<path d=\"M5 12.55a11 11 0 0 1 14.08 0\"></path><path d=\"M1.42 9a16 16 0 0 1 21.16 0\"></path><path d=\"M8.53 16.11a6 6 0 0 1 6.95 0\"></path><line x1=\"12\" y1=\"20\" x2=\"12\" y2=\"20\"></line>","wind":"<path d=\"M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2\"></path>","x-circle":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><line x1=\"15\" y1=\"9\" x2=\"9\" y2=\"15\"></line><line x1=\"9\" y1=\"9\" x2=\"15\" y2=\"15\"></line>","x-octagon":"<polygon points=\"7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2\"></polygon><line x1=\"15\" y1=\"9\" x2=\"9\" y2=\"15\"></line><line x1=\"9\" y1=\"9\" x2=\"15\" y2=\"15\"></line>","x-square":"<rect x=\"3\" y=\"3\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"></rect><line x1=\"9\" y1=\"9\" x2=\"15\" y2=\"15\"></line><line x1=\"15\" y1=\"9\" x2=\"9\" y2=\"15\"></line>","x":"<line x1=\"18\" y1=\"6\" x2=\"6\" y2=\"18\"></line><line x1=\"6\" y1=\"6\" x2=\"18\" y2=\"18\"></line>","youtube":"<path d=\"M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z\"></path><polygon points=\"9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02\"></polygon>","zap-off":"<polyline points=\"12.41 6.75 13 2 10.57 4.92\"></polyline><polyline points=\"18.57 12.91 21 10 15.66 10\"></polyline><polyline points=\"8 8 3 14 12 14 11 22 16 16\"></polyline><line x1=\"1\" y1=\"1\" x2=\"23\" y2=\"23\"></line>","zap":"<polygon points=\"13 2 3 14 12 14 11 22 21 10 12 10 13 2\"></polygon>","zoom-in":"<circle cx=\"11\" cy=\"11\" r=\"8\"></circle><line x1=\"21\" y1=\"21\" x2=\"16.65\" y2=\"16.65\"></line><line x1=\"11\" y1=\"8\" x2=\"11\" y2=\"14\"></line><line x1=\"8\" y1=\"11\" x2=\"14\" y2=\"11\"></line>","zoom-out":"<circle cx=\"11\" cy=\"11\" r=\"8\"></circle><line x1=\"21\" y1=\"21\" x2=\"16.65\" y2=\"16.65\"></line><line x1=\"8\" y1=\"11\" x2=\"14\" y2=\"11\"></line>"};

    /***/ }),

    /***/ "./node_modules/classnames/dedupe.js":
    /*!*******************************************!*\
      !*** ./node_modules/classnames/dedupe.js ***!
      \*******************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
      Copyright (c) 2016 Jed Watson.
      Licensed under the MIT License (MIT), see
      http://jedwatson.github.io/classnames
    */
    /* global define */

    (function () {

    	var classNames = (function () {
    		// don't inherit from Object so we can skip hasOwnProperty check later
    		// http://stackoverflow.com/questions/15518328/creating-js-object-with-object-createnull#answer-21079232
    		function StorageObject() {}
    		StorageObject.prototype = Object.create(null);

    		function _parseArray (resultSet, array) {
    			var length = array.length;

    			for (var i = 0; i < length; ++i) {
    				_parse(resultSet, array[i]);
    			}
    		}

    		var hasOwn = {}.hasOwnProperty;

    		function _parseNumber (resultSet, num) {
    			resultSet[num] = true;
    		}

    		function _parseObject (resultSet, object) {
    			for (var k in object) {
    				if (hasOwn.call(object, k)) {
    					// set value to false instead of deleting it to avoid changing object structure
    					// https://www.smashingmagazine.com/2012/11/writing-fast-memory-efficient-javascript/#de-referencing-misconceptions
    					resultSet[k] = !!object[k];
    				}
    			}
    		}

    		var SPACE = /\s+/;
    		function _parseString (resultSet, str) {
    			var array = str.split(SPACE);
    			var length = array.length;

    			for (var i = 0; i < length; ++i) {
    				resultSet[array[i]] = true;
    			}
    		}

    		function _parse (resultSet, arg) {
    			if (!arg) return;
    			var argType = typeof arg;

    			// 'foo bar'
    			if (argType === 'string') {
    				_parseString(resultSet, arg);

    			// ['foo', 'bar', ...]
    			} else if (Array.isArray(arg)) {
    				_parseArray(resultSet, arg);

    			// { 'foo': true, ... }
    			} else if (argType === 'object') {
    				_parseObject(resultSet, arg);

    			// '130'
    			} else if (argType === 'number') {
    				_parseNumber(resultSet, arg);
    			}
    		}

    		function _classNames () {
    			// don't leak arguments
    			// https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
    			var len = arguments.length;
    			var args = Array(len);
    			for (var i = 0; i < len; i++) {
    				args[i] = arguments[i];
    			}

    			var classSet = new StorageObject();
    			_parseArray(classSet, args);

    			var list = [];

    			for (var k in classSet) {
    				if (classSet[k]) {
    					list.push(k);
    				}
    			}

    			return list.join(' ');
    		}

    		return _classNames;
    	})();

    	if (typeof module !== 'undefined' && module.exports) {
    		module.exports = classNames;
    	} else {
    		// register as 'classnames', consistent with npm package name
    		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
    			return classNames;
    		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
    				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    	}
    }());


    /***/ }),

    /***/ "./node_modules/core-js/es/array/from.js":
    /*!***********************************************!*\
      !*** ./node_modules/core-js/es/array/from.js ***!
      \***********************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    __webpack_require__(/*! ../../modules/es.string.iterator */ "./node_modules/core-js/modules/es.string.iterator.js");
    __webpack_require__(/*! ../../modules/es.array.from */ "./node_modules/core-js/modules/es.array.from.js");
    var path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js/internals/path.js");

    module.exports = path.Array.from;


    /***/ }),

    /***/ "./node_modules/core-js/internals/a-function.js":
    /*!******************************************************!*\
      !*** ./node_modules/core-js/internals/a-function.js ***!
      \******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports) {

    module.exports = function (it) {
      if (typeof it != 'function') {
        throw TypeError(String(it) + ' is not a function');
      } return it;
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/an-object.js":
    /*!*****************************************************!*\
      !*** ./node_modules/core-js/internals/an-object.js ***!
      \*****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

    module.exports = function (it) {
      if (!isObject(it)) {
        throw TypeError(String(it) + ' is not an object');
      } return it;
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/array-from.js":
    /*!******************************************************!*\
      !*** ./node_modules/core-js/internals/array-from.js ***!
      \******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var bind = __webpack_require__(/*! ../internals/bind-context */ "./node_modules/core-js/internals/bind-context.js");
    var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
    var callWithSafeIterationClosing = __webpack_require__(/*! ../internals/call-with-safe-iteration-closing */ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js");
    var isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "./node_modules/core-js/internals/is-array-iterator-method.js");
    var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
    var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
    var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");

    // `Array.from` method
    // https://tc39.github.io/ecma262/#sec-array.from
    module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
      var O = toObject(arrayLike);
      var C = typeof this == 'function' ? this : Array;
      var argumentsLength = arguments.length;
      var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
      var mapping = mapfn !== undefined;
      var index = 0;
      var iteratorMethod = getIteratorMethod(O);
      var length, result, step, iterator;
      if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
      // if the target is not iterable or it's an array with the default iterator - use a simple case
      if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
        iterator = iteratorMethod.call(O);
        result = new C();
        for (;!(step = iterator.next()).done; index++) {
          createProperty(result, index, mapping
            ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true)
            : step.value
          );
        }
      } else {
        length = toLength(O.length);
        result = new C(length);
        for (;length > index; index++) {
          createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
        }
      }
      result.length = index;
      return result;
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/array-includes.js":
    /*!**********************************************************!*\
      !*** ./node_modules/core-js/internals/array-includes.js ***!
      \**********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
    var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
    var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");

    // `Array.prototype.{ indexOf, includes }` methods implementation
    // false -> Array#indexOf
    // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
    // true  -> Array#includes
    // https://tc39.github.io/ecma262/#sec-array.prototype.includes
    module.exports = function (IS_INCLUDES) {
      return function ($this, el, fromIndex) {
        var O = toIndexedObject($this);
        var length = toLength(O.length);
        var index = toAbsoluteIndex(fromIndex, length);
        var value;
        // Array#includes uses SameValueZero equality algorithm
        // eslint-disable-next-line no-self-compare
        if (IS_INCLUDES && el != el) while (length > index) {
          value = O[index++];
          // eslint-disable-next-line no-self-compare
          if (value != value) return true;
        // Array#indexOf ignores holes, Array#includes - not
        } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
          if (O[index] === el) return IS_INCLUDES || index || 0;
        } return !IS_INCLUDES && -1;
      };
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/bind-context.js":
    /*!********************************************************!*\
      !*** ./node_modules/core-js/internals/bind-context.js ***!
      \********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");

    // optional / simple context binding
    module.exports = function (fn, that, length) {
      aFunction(fn);
      if (that === undefined) return fn;
      switch (length) {
        case 0: return function () {
          return fn.call(that);
        };
        case 1: return function (a) {
          return fn.call(that, a);
        };
        case 2: return function (a, b) {
          return fn.call(that, a, b);
        };
        case 3: return function (a, b, c) {
          return fn.call(that, a, b, c);
        };
      }
      return function (/* ...args */) {
        return fn.apply(that, arguments);
      };
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js":
    /*!****************************************************************************!*\
      !*** ./node_modules/core-js/internals/call-with-safe-iteration-closing.js ***!
      \****************************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

    // call something on iterator step with safe closing on error
    module.exports = function (iterator, fn, value, ENTRIES) {
      try {
        return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
      // 7.4.6 IteratorClose(iterator, completion)
      } catch (error) {
        var returnMethod = iterator['return'];
        if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
        throw error;
      }
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/check-correctness-of-iteration.js":
    /*!**************************************************************************!*\
      !*** ./node_modules/core-js/internals/check-correctness-of-iteration.js ***!
      \**************************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

    var ITERATOR = wellKnownSymbol('iterator');
    var SAFE_CLOSING = false;

    try {
      var called = 0;
      var iteratorWithReturn = {
        next: function () {
          return { done: !!called++ };
        },
        'return': function () {
          SAFE_CLOSING = true;
        }
      };
      iteratorWithReturn[ITERATOR] = function () {
        return this;
      };
      // eslint-disable-next-line no-throw-literal
      Array.from(iteratorWithReturn, function () { throw 2; });
    } catch (error) { /* empty */ }

    module.exports = function (exec, SKIP_CLOSING) {
      if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
      var ITERATION_SUPPORT = false;
      try {
        var object = {};
        object[ITERATOR] = function () {
          return {
            next: function () {
              return { done: ITERATION_SUPPORT = true };
            }
          };
        };
        exec(object);
      } catch (error) { /* empty */ }
      return ITERATION_SUPPORT;
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/classof-raw.js":
    /*!*******************************************************!*\
      !*** ./node_modules/core-js/internals/classof-raw.js ***!
      \*******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports) {

    var toString = {}.toString;

    module.exports = function (it) {
      return toString.call(it).slice(8, -1);
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/classof.js":
    /*!***************************************************!*\
      !*** ./node_modules/core-js/internals/classof.js ***!
      \***************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
    var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

    var TO_STRING_TAG = wellKnownSymbol('toStringTag');
    // ES3 wrong here
    var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

    // fallback for IE11 Script Access Denied error
    var tryGet = function (it, key) {
      try {
        return it[key];
      } catch (error) { /* empty */ }
    };

    // getting tag from ES6+ `Object.prototype.toString`
    module.exports = function (it) {
      var O, tag, result;
      return it === undefined ? 'Undefined' : it === null ? 'Null'
        // @@toStringTag case
        : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
        // builtinTag case
        : CORRECT_ARGUMENTS ? classofRaw(O)
        // ES3 arguments fallback
        : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/copy-constructor-properties.js":
    /*!***********************************************************************!*\
      !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!
      \***********************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
    var ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");
    var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
    var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

    module.exports = function (target, source) {
      var keys = ownKeys(source);
      var defineProperty = definePropertyModule.f;
      var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
      }
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/correct-prototype-getter.js":
    /*!********************************************************************!*\
      !*** ./node_modules/core-js/internals/correct-prototype-getter.js ***!
      \********************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

    module.exports = !fails(function () {
      function F() { /* empty */ }
      F.prototype.constructor = null;
      return Object.getPrototypeOf(new F()) !== F.prototype;
    });


    /***/ }),

    /***/ "./node_modules/core-js/internals/create-iterator-constructor.js":
    /*!***********************************************************************!*\
      !*** ./node_modules/core-js/internals/create-iterator-constructor.js ***!
      \***********************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var IteratorPrototype = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js").IteratorPrototype;
    var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
    var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
    var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
    var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

    var returnThis = function () { return this; };

    module.exports = function (IteratorConstructor, NAME, next) {
      var TO_STRING_TAG = NAME + ' Iterator';
      IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
      setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
      Iterators[TO_STRING_TAG] = returnThis;
      return IteratorConstructor;
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/create-property-descriptor.js":
    /*!**********************************************************************!*\
      !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!
      \**********************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports) {

    module.exports = function (bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value: value
      };
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/create-property.js":
    /*!***********************************************************!*\
      !*** ./node_modules/core-js/internals/create-property.js ***!
      \***********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
    var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
    var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

    module.exports = function (object, key, value) {
      var propertyKey = toPrimitive(key);
      if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
      else object[propertyKey] = value;
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/define-iterator.js":
    /*!***********************************************************!*\
      !*** ./node_modules/core-js/internals/define-iterator.js ***!
      \***********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
    var createIteratorConstructor = __webpack_require__(/*! ../internals/create-iterator-constructor */ "./node_modules/core-js/internals/create-iterator-constructor.js");
    var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
    var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");
    var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
    var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
    var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
    var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
    var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
    var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
    var IteratorsCore = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js");

    var IteratorPrototype = IteratorsCore.IteratorPrototype;
    var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
    var ITERATOR = wellKnownSymbol('iterator');
    var KEYS = 'keys';
    var VALUES = 'values';
    var ENTRIES = 'entries';

    var returnThis = function () { return this; };

    module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
      createIteratorConstructor(IteratorConstructor, NAME, next);

      var getIterationMethod = function (KIND) {
        if (KIND === DEFAULT && defaultIterator) return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
        switch (KIND) {
          case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
          case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
          case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
        } return function () { return new IteratorConstructor(this); };
      };

      var TO_STRING_TAG = NAME + ' Iterator';
      var INCORRECT_VALUES_NAME = false;
      var IterablePrototype = Iterable.prototype;
      var nativeIterator = IterablePrototype[ITERATOR]
        || IterablePrototype['@@iterator']
        || DEFAULT && IterablePrototype[DEFAULT];
      var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
      var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
      var CurrentIteratorPrototype, methods, KEY;

      // fix native
      if (anyNativeIterator) {
        CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
        if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
          if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
            if (setPrototypeOf) {
              setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
            } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
              hide(CurrentIteratorPrototype, ITERATOR, returnThis);
            }
          }
          // Set @@toStringTag to native iterators
          setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
          if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
        }
      }

      // fix Array#{values, @@iterator}.name in V8 / FF
      if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
        INCORRECT_VALUES_NAME = true;
        defaultIterator = function values() { return nativeIterator.call(this); };
      }

      // define iterator
      if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
        hide(IterablePrototype, ITERATOR, defaultIterator);
      }
      Iterators[NAME] = defaultIterator;

      // export additional methods
      if (DEFAULT) {
        methods = {
          values: getIterationMethod(VALUES),
          keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
          entries: getIterationMethod(ENTRIES)
        };
        if (FORCED) for (KEY in methods) {
          if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
            redefine(IterablePrototype, KEY, methods[KEY]);
          }
        } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
      }

      return methods;
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/descriptors.js":
    /*!*******************************************************!*\
      !*** ./node_modules/core-js/internals/descriptors.js ***!
      \*******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

    // Thank's IE8 for his funny defineProperty
    module.exports = !fails(function () {
      return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
    });


    /***/ }),

    /***/ "./node_modules/core-js/internals/document-create-element.js":
    /*!*******************************************************************!*\
      !*** ./node_modules/core-js/internals/document-create-element.js ***!
      \*******************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
    var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

    var document = global.document;
    // typeof document.createElement is 'object' in old IE
    var exist = isObject(document) && isObject(document.createElement);

    module.exports = function (it) {
      return exist ? document.createElement(it) : {};
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/enum-bug-keys.js":
    /*!*********************************************************!*\
      !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!
      \*********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports) {

    // IE8- don't enum bug keys
    module.exports = [
      'constructor',
      'hasOwnProperty',
      'isPrototypeOf',
      'propertyIsEnumerable',
      'toLocaleString',
      'toString',
      'valueOf'
    ];


    /***/ }),

    /***/ "./node_modules/core-js/internals/export.js":
    /*!**************************************************!*\
      !*** ./node_modules/core-js/internals/export.js ***!
      \**************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
    var getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;
    var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
    var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
    var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");
    var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");
    var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");

    /*
      options.target      - name of the target object
      options.global      - target is the global object
      options.stat        - export as static methods of target
      options.proto       - export as prototype methods of target
      options.real        - real prototype method for the `pure` version
      options.forced      - export even if the native feature is available
      options.bind        - bind methods to the target, required for the `pure` version
      options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
      options.unsafe      - use the simple assignment of property instead of delete + defineProperty
      options.sham        - add a flag to not completely full polyfills
      options.enumerable  - export as enumerable property
      options.noTargetGet - prevent calling a getter on target
    */
    module.exports = function (options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var FORCED, target, key, targetProperty, sourceProperty, descriptor;
      if (GLOBAL) {
        target = global;
      } else if (STATIC) {
        target = global[TARGET] || setGlobal(TARGET, {});
      } else {
        target = (global[TARGET] || {}).prototype;
      }
      if (target) for (key in source) {
        sourceProperty = source[key];
        if (options.noTargetGet) {
          descriptor = getOwnPropertyDescriptor(target, key);
          targetProperty = descriptor && descriptor.value;
        } else targetProperty = target[key];
        FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
        // contained in target
        if (!FORCED && targetProperty !== undefined) {
          if (typeof sourceProperty === typeof targetProperty) continue;
          copyConstructorProperties(sourceProperty, targetProperty);
        }
        // add a flag to not completely full polyfills
        if (options.sham || (targetProperty && targetProperty.sham)) {
          hide(sourceProperty, 'sham', true);
        }
        // extend global
        redefine(target, key, sourceProperty, options);
      }
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/fails.js":
    /*!*************************************************!*\
      !*** ./node_modules/core-js/internals/fails.js ***!
      \*************************************************/
    /*! no static exports found */
    /***/ (function(module, exports) {

    module.exports = function (exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/function-to-string.js":
    /*!**************************************************************!*\
      !*** ./node_modules/core-js/internals/function-to-string.js ***!
      \**************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");

    module.exports = shared('native-function-to-string', Function.toString);


    /***/ }),

    /***/ "./node_modules/core-js/internals/get-iterator-method.js":
    /*!***************************************************************!*\
      !*** ./node_modules/core-js/internals/get-iterator-method.js ***!
      \***************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
    var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
    var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

    var ITERATOR = wellKnownSymbol('iterator');

    module.exports = function (it) {
      if (it != undefined) return it[ITERATOR]
        || it['@@iterator']
        || Iterators[classof(it)];
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/global.js":
    /*!**************************************************!*\
      !*** ./node_modules/core-js/internals/global.js ***!
      \**************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    /* WEBPACK VAR INJECTION */(function(global) {var O = 'object';
    var check = function (it) {
      return it && it.Math == Math && it;
    };

    // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
    module.exports =
      // eslint-disable-next-line no-undef
      check(typeof globalThis == O && globalThis) ||
      check(typeof window == O && window) ||
      check(typeof self == O && self) ||
      check(typeof global == O && global) ||
      // eslint-disable-next-line no-new-func
      Function('return this')();

    /* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")));

    /***/ }),

    /***/ "./node_modules/core-js/internals/has.js":
    /*!***********************************************!*\
      !*** ./node_modules/core-js/internals/has.js ***!
      \***********************************************/
    /*! no static exports found */
    /***/ (function(module, exports) {

    var hasOwnProperty = {}.hasOwnProperty;

    module.exports = function (it, key) {
      return hasOwnProperty.call(it, key);
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/hidden-keys.js":
    /*!*******************************************************!*\
      !*** ./node_modules/core-js/internals/hidden-keys.js ***!
      \*******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports) {

    module.exports = {};


    /***/ }),

    /***/ "./node_modules/core-js/internals/hide.js":
    /*!************************************************!*\
      !*** ./node_modules/core-js/internals/hide.js ***!
      \************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
    var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
    var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

    module.exports = DESCRIPTORS ? function (object, key, value) {
      return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
    } : function (object, key, value) {
      object[key] = value;
      return object;
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/html.js":
    /*!************************************************!*\
      !*** ./node_modules/core-js/internals/html.js ***!
      \************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

    var document = global.document;

    module.exports = document && document.documentElement;


    /***/ }),

    /***/ "./node_modules/core-js/internals/ie8-dom-define.js":
    /*!**********************************************************!*\
      !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!
      \**********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
    var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
    var createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");

    // Thank's IE8 for his funny defineProperty
    module.exports = !DESCRIPTORS && !fails(function () {
      return Object.defineProperty(createElement('div'), 'a', {
        get: function () { return 7; }
      }).a != 7;
    });


    /***/ }),

    /***/ "./node_modules/core-js/internals/indexed-object.js":
    /*!**********************************************************!*\
      !*** ./node_modules/core-js/internals/indexed-object.js ***!
      \**********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    // fallback for non-array-like ES3 and non-enumerable old V8 strings
    var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
    var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

    var split = ''.split;

    module.exports = fails(function () {
      // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
      // eslint-disable-next-line no-prototype-builtins
      return !Object('z').propertyIsEnumerable(0);
    }) ? function (it) {
      return classof(it) == 'String' ? split.call(it, '') : Object(it);
    } : Object;


    /***/ }),

    /***/ "./node_modules/core-js/internals/internal-state.js":
    /*!**********************************************************!*\
      !*** ./node_modules/core-js/internals/internal-state.js ***!
      \**********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/native-weak-map */ "./node_modules/core-js/internals/native-weak-map.js");
    var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
    var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
    var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
    var objectHas = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
    var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
    var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

    var WeakMap = global.WeakMap;
    var set, get, has;

    var enforce = function (it) {
      return has(it) ? get(it) : set(it, {});
    };

    var getterFor = function (TYPE) {
      return function (it) {
        var state;
        if (!isObject(it) || (state = get(it)).type !== TYPE) {
          throw TypeError('Incompatible receiver, ' + TYPE + ' required');
        } return state;
      };
    };

    if (NATIVE_WEAK_MAP) {
      var store = new WeakMap();
      var wmget = store.get;
      var wmhas = store.has;
      var wmset = store.set;
      set = function (it, metadata) {
        wmset.call(store, it, metadata);
        return metadata;
      };
      get = function (it) {
        return wmget.call(store, it) || {};
      };
      has = function (it) {
        return wmhas.call(store, it);
      };
    } else {
      var STATE = sharedKey('state');
      hiddenKeys[STATE] = true;
      set = function (it, metadata) {
        hide(it, STATE, metadata);
        return metadata;
      };
      get = function (it) {
        return objectHas(it, STATE) ? it[STATE] : {};
      };
      has = function (it) {
        return objectHas(it, STATE);
      };
    }

    module.exports = {
      set: set,
      get: get,
      has: has,
      enforce: enforce,
      getterFor: getterFor
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/is-array-iterator-method.js":
    /*!********************************************************************!*\
      !*** ./node_modules/core-js/internals/is-array-iterator-method.js ***!
      \********************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
    var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

    var ITERATOR = wellKnownSymbol('iterator');
    var ArrayPrototype = Array.prototype;

    // check on default Array iterator
    module.exports = function (it) {
      return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/is-forced.js":
    /*!*****************************************************!*\
      !*** ./node_modules/core-js/internals/is-forced.js ***!
      \*****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

    var replacement = /#|\.prototype\./;

    var isForced = function (feature, detection) {
      var value = data[normalize(feature)];
      return value == POLYFILL ? true
        : value == NATIVE ? false
        : typeof detection == 'function' ? fails(detection)
        : !!detection;
    };

    var normalize = isForced.normalize = function (string) {
      return String(string).replace(replacement, '.').toLowerCase();
    };

    var data = isForced.data = {};
    var NATIVE = isForced.NATIVE = 'N';
    var POLYFILL = isForced.POLYFILL = 'P';

    module.exports = isForced;


    /***/ }),

    /***/ "./node_modules/core-js/internals/is-object.js":
    /*!*****************************************************!*\
      !*** ./node_modules/core-js/internals/is-object.js ***!
      \*****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports) {

    module.exports = function (it) {
      return typeof it === 'object' ? it !== null : typeof it === 'function';
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/is-pure.js":
    /*!***************************************************!*\
      !*** ./node_modules/core-js/internals/is-pure.js ***!
      \***************************************************/
    /*! no static exports found */
    /***/ (function(module, exports) {

    module.exports = false;


    /***/ }),

    /***/ "./node_modules/core-js/internals/iterators-core.js":
    /*!**********************************************************!*\
      !*** ./node_modules/core-js/internals/iterators-core.js ***!
      \**********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
    var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
    var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
    var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
    var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

    var ITERATOR = wellKnownSymbol('iterator');
    var BUGGY_SAFARI_ITERATORS = false;

    var returnThis = function () { return this; };

    // `%IteratorPrototype%` object
    // https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
    var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

    if ([].keys) {
      arrayIterator = [].keys();
      // Safari 8 has buggy iterators w/o `next`
      if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
      else {
        PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
        if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
      }
    }

    if (IteratorPrototype == undefined) IteratorPrototype = {};

    // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
    if (!IS_PURE && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);

    module.exports = {
      IteratorPrototype: IteratorPrototype,
      BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/iterators.js":
    /*!*****************************************************!*\
      !*** ./node_modules/core-js/internals/iterators.js ***!
      \*****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports) {

    module.exports = {};


    /***/ }),

    /***/ "./node_modules/core-js/internals/native-symbol.js":
    /*!*********************************************************!*\
      !*** ./node_modules/core-js/internals/native-symbol.js ***!
      \*********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

    module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
      // Chrome 38 Symbol has incorrect toString conversion
      // eslint-disable-next-line no-undef
      return !String(Symbol());
    });


    /***/ }),

    /***/ "./node_modules/core-js/internals/native-weak-map.js":
    /*!***********************************************************!*\
      !*** ./node_modules/core-js/internals/native-weak-map.js ***!
      \***********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
    var nativeFunctionToString = __webpack_require__(/*! ../internals/function-to-string */ "./node_modules/core-js/internals/function-to-string.js");

    var WeakMap = global.WeakMap;

    module.exports = typeof WeakMap === 'function' && /native code/.test(nativeFunctionToString.call(WeakMap));


    /***/ }),

    /***/ "./node_modules/core-js/internals/object-create.js":
    /*!*********************************************************!*\
      !*** ./node_modules/core-js/internals/object-create.js ***!
      \*********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
    var defineProperties = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js");
    var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");
    var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
    var html = __webpack_require__(/*! ../internals/html */ "./node_modules/core-js/internals/html.js");
    var documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");
    var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
    var IE_PROTO = sharedKey('IE_PROTO');

    var PROTOTYPE = 'prototype';
    var Empty = function () { /* empty */ };

    // Create object with fake `null` prototype: use iframe Object with cleared prototype
    var createDict = function () {
      // Thrash, waste and sodomy: IE GC bug
      var iframe = documentCreateElement('iframe');
      var length = enumBugKeys.length;
      var lt = '<';
      var script = 'script';
      var gt = '>';
      var js = 'java' + script + ':';
      var iframeDocument;
      iframe.style.display = 'none';
      html.appendChild(iframe);
      iframe.src = String(js);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(lt + script + gt + 'document.F=Object' + lt + '/' + script + gt);
      iframeDocument.close();
      createDict = iframeDocument.F;
      while (length--) delete createDict[PROTOTYPE][enumBugKeys[length]];
      return createDict();
    };

    // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
    module.exports = Object.create || function create(O, Properties) {
      var result;
      if (O !== null) {
        Empty[PROTOTYPE] = anObject(O);
        result = new Empty();
        Empty[PROTOTYPE] = null;
        // add "__proto__" for Object.getPrototypeOf polyfill
        result[IE_PROTO] = O;
      } else result = createDict();
      return Properties === undefined ? result : defineProperties(result, Properties);
    };

    hiddenKeys[IE_PROTO] = true;


    /***/ }),

    /***/ "./node_modules/core-js/internals/object-define-properties.js":
    /*!********************************************************************!*\
      !*** ./node_modules/core-js/internals/object-define-properties.js ***!
      \********************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
    var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
    var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
    var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");

    module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
      anObject(O);
      var keys = objectKeys(Properties);
      var length = keys.length;
      var i = 0;
      var key;
      while (length > i) definePropertyModule.f(O, key = keys[i++], Properties[key]);
      return O;
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/object-define-property.js":
    /*!******************************************************************!*\
      !*** ./node_modules/core-js/internals/object-define-property.js ***!
      \******************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
    var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");
    var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
    var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");

    var nativeDefineProperty = Object.defineProperty;

    exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPrimitive(P, true);
      anObject(Attributes);
      if (IE8_DOM_DEFINE) try {
        return nativeDefineProperty(O, P, Attributes);
      } catch (error) { /* empty */ }
      if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
      if ('value' in Attributes) O[P] = Attributes.value;
      return O;
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/object-get-own-property-descriptor.js":
    /*!******************************************************************************!*\
      !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
      \******************************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
    var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
    var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
    var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
    var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
    var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
    var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");

    var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

    exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
      O = toIndexedObject(O);
      P = toPrimitive(P, true);
      if (IE8_DOM_DEFINE) try {
        return nativeGetOwnPropertyDescriptor(O, P);
      } catch (error) { /* empty */ }
      if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/object-get-own-property-names.js":
    /*!*************************************************************************!*\
      !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!
      \*************************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
    var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
    var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

    var hiddenKeys = enumBugKeys.concat('length', 'prototype');

    exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
      return internalObjectKeys(O, hiddenKeys);
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/object-get-own-property-symbols.js":
    /*!***************************************************************************!*\
      !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!
      \***************************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports) {

    exports.f = Object.getOwnPropertySymbols;


    /***/ }),

    /***/ "./node_modules/core-js/internals/object-get-prototype-of.js":
    /*!*******************************************************************!*\
      !*** ./node_modules/core-js/internals/object-get-prototype-of.js ***!
      \*******************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
    var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
    var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
    var CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "./node_modules/core-js/internals/correct-prototype-getter.js");

    var IE_PROTO = sharedKey('IE_PROTO');
    var ObjectPrototype = Object.prototype;

    // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
    module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
      O = toObject(O);
      if (has(O, IE_PROTO)) return O[IE_PROTO];
      if (typeof O.constructor == 'function' && O instanceof O.constructor) {
        return O.constructor.prototype;
      } return O instanceof Object ? ObjectPrototype : null;
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/object-keys-internal.js":
    /*!****************************************************************!*\
      !*** ./node_modules/core-js/internals/object-keys-internal.js ***!
      \****************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
    var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
    var arrayIncludes = __webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js");
    var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

    var arrayIndexOf = arrayIncludes(false);

    module.exports = function (object, names) {
      var O = toIndexedObject(object);
      var i = 0;
      var result = [];
      var key;
      for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
      // Don't enum bug & hidden keys
      while (names.length > i) if (has(O, key = names[i++])) {
        ~arrayIndexOf(result, key) || result.push(key);
      }
      return result;
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/object-keys.js":
    /*!*******************************************************!*\
      !*** ./node_modules/core-js/internals/object-keys.js ***!
      \*******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
    var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

    // 19.1.2.14 / 15.2.3.14 Object.keys(O)
    module.exports = Object.keys || function keys(O) {
      return internalObjectKeys(O, enumBugKeys);
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/object-property-is-enumerable.js":
    /*!*************************************************************************!*\
      !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!
      \*************************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

    // Nashorn ~ JDK8 bug
    var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

    exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
      var descriptor = getOwnPropertyDescriptor(this, V);
      return !!descriptor && descriptor.enumerable;
    } : nativePropertyIsEnumerable;


    /***/ }),

    /***/ "./node_modules/core-js/internals/object-set-prototype-of.js":
    /*!*******************************************************************!*\
      !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!
      \*******************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var validateSetPrototypeOfArguments = __webpack_require__(/*! ../internals/validate-set-prototype-of-arguments */ "./node_modules/core-js/internals/validate-set-prototype-of-arguments.js");

    // Works with __proto__ only. Old v8 can't work with null proto objects.
    /* eslint-disable no-proto */
    module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
      var correctSetter = false;
      var test = {};
      var setter;
      try {
        setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
        setter.call(test, []);
        correctSetter = test instanceof Array;
      } catch (error) { /* empty */ }
      return function setPrototypeOf(O, proto) {
        validateSetPrototypeOfArguments(O, proto);
        if (correctSetter) setter.call(O, proto);
        else O.__proto__ = proto;
        return O;
      };
    }() : undefined);


    /***/ }),

    /***/ "./node_modules/core-js/internals/own-keys.js":
    /*!****************************************************!*\
      !*** ./node_modules/core-js/internals/own-keys.js ***!
      \****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
    var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");
    var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
    var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

    var Reflect = global.Reflect;

    // all object keys, includes non-enumerable and symbols
    module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
      var keys = getOwnPropertyNamesModule.f(anObject(it));
      var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
      return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/path.js":
    /*!************************************************!*\
      !*** ./node_modules/core-js/internals/path.js ***!
      \************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    module.exports = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");


    /***/ }),

    /***/ "./node_modules/core-js/internals/redefine.js":
    /*!****************************************************!*\
      !*** ./node_modules/core-js/internals/redefine.js ***!
      \****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
    var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
    var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
    var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
    var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");
    var nativeFunctionToString = __webpack_require__(/*! ../internals/function-to-string */ "./node_modules/core-js/internals/function-to-string.js");
    var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

    var getInternalState = InternalStateModule.get;
    var enforceInternalState = InternalStateModule.enforce;
    var TEMPLATE = String(nativeFunctionToString).split('toString');

    shared('inspectSource', function (it) {
      return nativeFunctionToString.call(it);
    });

    (module.exports = function (O, key, value, options) {
      var unsafe = options ? !!options.unsafe : false;
      var simple = options ? !!options.enumerable : false;
      var noTargetGet = options ? !!options.noTargetGet : false;
      if (typeof value == 'function') {
        if (typeof key == 'string' && !has(value, 'name')) hide(value, 'name', key);
        enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
      }
      if (O === global) {
        if (simple) O[key] = value;
        else setGlobal(key, value);
        return;
      } else if (!unsafe) {
        delete O[key];
      } else if (!noTargetGet && O[key]) {
        simple = true;
      }
      if (simple) O[key] = value;
      else hide(O, key, value);
    // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
    })(Function.prototype, 'toString', function toString() {
      return typeof this == 'function' && getInternalState(this).source || nativeFunctionToString.call(this);
    });


    /***/ }),

    /***/ "./node_modules/core-js/internals/require-object-coercible.js":
    /*!********************************************************************!*\
      !*** ./node_modules/core-js/internals/require-object-coercible.js ***!
      \********************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports) {

    // `RequireObjectCoercible` abstract operation
    // https://tc39.github.io/ecma262/#sec-requireobjectcoercible
    module.exports = function (it) {
      if (it == undefined) throw TypeError("Can't call method on " + it);
      return it;
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/set-global.js":
    /*!******************************************************!*\
      !*** ./node_modules/core-js/internals/set-global.js ***!
      \******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
    var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");

    module.exports = function (key, value) {
      try {
        hide(global, key, value);
      } catch (error) {
        global[key] = value;
      } return value;
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/set-to-string-tag.js":
    /*!*************************************************************!*\
      !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!
      \*************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;
    var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
    var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

    var TO_STRING_TAG = wellKnownSymbol('toStringTag');

    module.exports = function (it, TAG, STATIC) {
      if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
        defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
      }
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/shared-key.js":
    /*!******************************************************!*\
      !*** ./node_modules/core-js/internals/shared-key.js ***!
      \******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
    var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");

    var keys = shared('keys');

    module.exports = function (key) {
      return keys[key] || (keys[key] = uid(key));
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/shared.js":
    /*!**************************************************!*\
      !*** ./node_modules/core-js/internals/shared.js ***!
      \**************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
    var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");
    var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

    var SHARED = '__core-js_shared__';
    var store = global[SHARED] || setGlobal(SHARED, {});

    (module.exports = function (key, value) {
      return store[key] || (store[key] = value !== undefined ? value : {});
    })('versions', []).push({
      version: '3.1.3',
      mode: IS_PURE ? 'pure' : 'global',
      copyright: ' 2019 Denis Pushkarev (zloirock.ru)'
    });


    /***/ }),

    /***/ "./node_modules/core-js/internals/string-at.js":
    /*!*****************************************************!*\
      !*** ./node_modules/core-js/internals/string-at.js ***!
      \*****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
    var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

    // CONVERT_TO_STRING: true  -> String#at
    // CONVERT_TO_STRING: false -> String#codePointAt
    module.exports = function (that, pos, CONVERT_TO_STRING) {
      var S = String(requireObjectCoercible(that));
      var position = toInteger(pos);
      var size = S.length;
      var first, second;
      if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
      first = S.charCodeAt(position);
      return first < 0xD800 || first > 0xDBFF || position + 1 === size
        || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
          ? CONVERT_TO_STRING ? S.charAt(position) : first
          : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/to-absolute-index.js":
    /*!*************************************************************!*\
      !*** ./node_modules/core-js/internals/to-absolute-index.js ***!
      \*************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");

    var max = Math.max;
    var min = Math.min;

    // Helper for a popular repeating case of the spec:
    // Let integer be ? ToInteger(index).
    // If integer < 0, let result be max((length + integer), 0); else let result be min(length, length).
    module.exports = function (index, length) {
      var integer = toInteger(index);
      return integer < 0 ? max(integer + length, 0) : min(integer, length);
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/to-indexed-object.js":
    /*!*************************************************************!*\
      !*** ./node_modules/core-js/internals/to-indexed-object.js ***!
      \*************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    // toObject with fallback for non-array-like ES3 strings
    var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
    var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

    module.exports = function (it) {
      return IndexedObject(requireObjectCoercible(it));
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/to-integer.js":
    /*!******************************************************!*\
      !*** ./node_modules/core-js/internals/to-integer.js ***!
      \******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports) {

    var ceil = Math.ceil;
    var floor = Math.floor;

    // `ToInteger` abstract operation
    // https://tc39.github.io/ecma262/#sec-tointeger
    module.exports = function (argument) {
      return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/to-length.js":
    /*!*****************************************************!*\
      !*** ./node_modules/core-js/internals/to-length.js ***!
      \*****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");

    var min = Math.min;

    // `ToLength` abstract operation
    // https://tc39.github.io/ecma262/#sec-tolength
    module.exports = function (argument) {
      return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/to-object.js":
    /*!*****************************************************!*\
      !*** ./node_modules/core-js/internals/to-object.js ***!
      \*****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

    // `ToObject` abstract operation
    // https://tc39.github.io/ecma262/#sec-toobject
    module.exports = function (argument) {
      return Object(requireObjectCoercible(argument));
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/to-primitive.js":
    /*!********************************************************!*\
      !*** ./node_modules/core-js/internals/to-primitive.js ***!
      \********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

    // 7.1.1 ToPrimitive(input [, PreferredType])
    // instead of the ES6 spec version, we didn't implement @@toPrimitive case
    // and the second argument - flag - preferred type is a string
    module.exports = function (it, S) {
      if (!isObject(it)) return it;
      var fn, val;
      if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
      if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
      if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
      throw TypeError("Can't convert object to primitive value");
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/uid.js":
    /*!***********************************************!*\
      !*** ./node_modules/core-js/internals/uid.js ***!
      \***********************************************/
    /*! no static exports found */
    /***/ (function(module, exports) {

    var id = 0;
    var postfix = Math.random();

    module.exports = function (key) {
      return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + postfix).toString(36));
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/validate-set-prototype-of-arguments.js":
    /*!*******************************************************************************!*\
      !*** ./node_modules/core-js/internals/validate-set-prototype-of-arguments.js ***!
      \*******************************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
    var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

    module.exports = function (O, proto) {
      anObject(O);
      if (!isObject(proto) && proto !== null) {
        throw TypeError("Can't set " + String(proto) + ' as a prototype');
      }
    };


    /***/ }),

    /***/ "./node_modules/core-js/internals/well-known-symbol.js":
    /*!*************************************************************!*\
      !*** ./node_modules/core-js/internals/well-known-symbol.js ***!
      \*************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
    var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
    var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
    var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");

    var Symbol = global.Symbol;
    var store = shared('wks');

    module.exports = function (name) {
      return store[name] || (store[name] = NATIVE_SYMBOL && Symbol[name]
        || (NATIVE_SYMBOL ? Symbol : uid)('Symbol.' + name));
    };


    /***/ }),

    /***/ "./node_modules/core-js/modules/es.array.from.js":
    /*!*******************************************************!*\
      !*** ./node_modules/core-js/modules/es.array.from.js ***!
      \*******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
    var from = __webpack_require__(/*! ../internals/array-from */ "./node_modules/core-js/internals/array-from.js");
    var checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "./node_modules/core-js/internals/check-correctness-of-iteration.js");

    var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
    });

    // `Array.from` method
    // https://tc39.github.io/ecma262/#sec-array.from
    $({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
      from: from
    });


    /***/ }),

    /***/ "./node_modules/core-js/modules/es.string.iterator.js":
    /*!************************************************************!*\
      !*** ./node_modules/core-js/modules/es.string.iterator.js ***!
      \************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    var codePointAt = __webpack_require__(/*! ../internals/string-at */ "./node_modules/core-js/internals/string-at.js");
    var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
    var defineIterator = __webpack_require__(/*! ../internals/define-iterator */ "./node_modules/core-js/internals/define-iterator.js");

    var STRING_ITERATOR = 'String Iterator';
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

    // `String.prototype[@@iterator]` method
    // https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator
    defineIterator(String, 'String', function (iterated) {
      setInternalState(this, {
        type: STRING_ITERATOR,
        string: String(iterated),
        index: 0
      });
    // `%StringIteratorPrototype%.next` method
    // https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
    }, function next() {
      var state = getInternalState(this);
      var string = state.string;
      var index = state.index;
      var point;
      if (index >= string.length) return { value: undefined, done: true };
      point = codePointAt(string, index, true);
      state.index += point.length;
      return { value: point, done: false };
    });


    /***/ }),

    /***/ "./node_modules/webpack/buildin/global.js":
    /*!***********************************!*\
      !*** (webpack)/buildin/global.js ***!
      \***********************************/
    /*! no static exports found */
    /***/ (function(module, exports) {

    var g;

    // This works in non-strict mode
    g = (function() {
    	return this;
    })();

    try {
    	// This works if eval is allowed (see CSP)
    	g = g || Function("return this")() || (1, eval)("this");
    } catch (e) {
    	// This works if the window reference is available
    	if (typeof window === "object") g = window;
    }

    // g can still be undefined, but nothing to do about it...
    // We return undefined, instead of nothing here, so it's
    // easier to handle this case. if(!global) { ...}

    module.exports = g;


    /***/ }),

    /***/ "./src/default-attrs.json":
    /*!********************************!*\
      !*** ./src/default-attrs.json ***!
      \********************************/
    /*! exports provided: xmlns, width, height, viewBox, fill, stroke, stroke-width, stroke-linecap, stroke-linejoin, default */
    /***/ (function(module) {

    module.exports = {"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","stroke-width":2,"stroke-linecap":"round","stroke-linejoin":"round"};

    /***/ }),

    /***/ "./src/icon.js":
    /*!*********************!*\
      !*** ./src/icon.js ***!
      \*********************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _dedupe = __webpack_require__(/*! classnames/dedupe */ "./node_modules/classnames/dedupe.js");

    var _dedupe2 = _interopRequireDefault(_dedupe);

    var _defaultAttrs = __webpack_require__(/*! ./default-attrs.json */ "./src/default-attrs.json");

    var _defaultAttrs2 = _interopRequireDefault(_defaultAttrs);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var Icon = function () {
      function Icon(name, contents) {
        var tags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

        _classCallCheck(this, Icon);

        this.name = name;
        this.contents = contents;
        this.tags = tags;
        this.attrs = _extends({}, _defaultAttrs2.default, { class: 'feather feather-' + name });
      }

      /**
       * Create an SVG string.
       * @param {Object} attrs
       * @returns {string}
       */


      _createClass(Icon, [{
        key: 'toSvg',
        value: function toSvg() {
          var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          var combinedAttrs = _extends({}, this.attrs, attrs, { class: (0, _dedupe2.default)(this.attrs.class, attrs.class) });

          return '<svg ' + attrsToString(combinedAttrs) + '>' + this.contents + '</svg>';
        }

        /**
         * Return string representation of an `Icon`.
         *
         * Added for backward compatibility. If old code expects `feather.icons.<name>`
         * to be a string, `toString()` will get implicitly called.
         *
         * @returns {string}
         */

      }, {
        key: 'toString',
        value: function toString() {
          return this.contents;
        }
      }]);

      return Icon;
    }();

    /**
     * Convert attributes object to string of HTML attributes.
     * @param {Object} attrs
     * @returns {string}
     */


    function attrsToString(attrs) {
      return Object.keys(attrs).map(function (key) {
        return key + '="' + attrs[key] + '"';
      }).join(' ');
    }

    exports.default = Icon;

    /***/ }),

    /***/ "./src/icons.js":
    /*!**********************!*\
      !*** ./src/icons.js ***!
      \**********************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _icon = __webpack_require__(/*! ./icon */ "./src/icon.js");

    var _icon2 = _interopRequireDefault(_icon);

    var _icons = __webpack_require__(/*! ../dist/icons.json */ "./dist/icons.json");

    var _icons2 = _interopRequireDefault(_icons);

    var _tags = __webpack_require__(/*! ./tags.json */ "./src/tags.json");

    var _tags2 = _interopRequireDefault(_tags);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    exports.default = Object.keys(_icons2.default).map(function (key) {
      return new _icon2.default(key, _icons2.default[key], _tags2.default[key]);
    }).reduce(function (object, icon) {
      object[icon.name] = icon;
      return object;
    }, {});

    /***/ }),

    /***/ "./src/index.js":
    /*!**********************!*\
      !*** ./src/index.js ***!
      \**********************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {


    var _icons = __webpack_require__(/*! ./icons */ "./src/icons.js");

    var _icons2 = _interopRequireDefault(_icons);

    var _toSvg = __webpack_require__(/*! ./to-svg */ "./src/to-svg.js");

    var _toSvg2 = _interopRequireDefault(_toSvg);

    var _replace = __webpack_require__(/*! ./replace */ "./src/replace.js");

    var _replace2 = _interopRequireDefault(_replace);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    module.exports = { icons: _icons2.default, toSvg: _toSvg2.default, replace: _replace2.default };

    /***/ }),

    /***/ "./src/replace.js":
    /*!************************!*\
      !*** ./src/replace.js ***!
      \************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* eslint-env browser */


    var _dedupe = __webpack_require__(/*! classnames/dedupe */ "./node_modules/classnames/dedupe.js");

    var _dedupe2 = _interopRequireDefault(_dedupe);

    var _icons = __webpack_require__(/*! ./icons */ "./src/icons.js");

    var _icons2 = _interopRequireDefault(_icons);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    /**
     * Replace all HTML elements that have a `data-feather` attribute with SVG markup
     * corresponding to the element's `data-feather` attribute value.
     * @param {Object} attrs
     */
    function replace() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (typeof document === 'undefined') {
        throw new Error('`feather.replace()` only works in a browser environment.');
      }

      var elementsToReplace = document.querySelectorAll('[data-feather]');

      Array.from(elementsToReplace).forEach(function (element) {
        return replaceElement(element, attrs);
      });
    }

    /**
     * Replace a single HTML element with SVG markup
     * corresponding to the element's `data-feather` attribute value.
     * @param {HTMLElement} element
     * @param {Object} attrs
     */
    function replaceElement(element) {
      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var elementAttrs = getAttrs(element);
      var name = elementAttrs['data-feather'];
      delete elementAttrs['data-feather'];

      var svgString = _icons2.default[name].toSvg(_extends({}, attrs, elementAttrs, { class: (0, _dedupe2.default)(attrs.class, elementAttrs.class) }));
      var svgDocument = new DOMParser().parseFromString(svgString, 'image/svg+xml');
      var svgElement = svgDocument.querySelector('svg');

      element.parentNode.replaceChild(svgElement, element);
    }

    /**
     * Get the attributes of an HTML element.
     * @param {HTMLElement} element
     * @returns {Object}
     */
    function getAttrs(element) {
      return Array.from(element.attributes).reduce(function (attrs, attr) {
        attrs[attr.name] = attr.value;
        return attrs;
      }, {});
    }

    exports.default = replace;

    /***/ }),

    /***/ "./src/tags.json":
    /*!***********************!*\
      !*** ./src/tags.json ***!
      \***********************/
    /*! exports provided: activity, airplay, alert-circle, alert-octagon, alert-triangle, at-sign, award, aperture, bell, bell-off, bluetooth, book-open, book, bookmark, briefcase, clipboard, clock, cloud-drizzle, cloud-lightning, cloud-rain, cloud-snow, cloud, codepen, codesandbox, coffee, command, compass, copy, corner-down-left, corner-down-right, corner-left-down, corner-left-up, corner-right-down, corner-right-up, corner-up-left, corner-up-right, credit-card, crop, crosshair, database, delete, disc, dollar-sign, droplet, edit, edit-2, edit-3, eye, eye-off, external-link, facebook, fast-forward, figma, film, folder-minus, folder-plus, folder, framer, frown, gift, git-branch, git-commit, git-merge, git-pull-request, github, gitlab, global, hard-drive, hash, headphones, heart, help-circle, hexagon, home, image, inbox, instagram, key, life-bouy, linkedin, lock, log-in, log-out, mail, map-pin, map, maximize, maximize-2, meh, menu, message-circle, message-square, mic-off, mic, minimize, minimize-2, monitor, moon, more-horizontal, more-vertical, mouse-pointer, move, navigation, navigation-2, octagon, package, paperclip, pause, pause-circle, pen-tool, play, play-circle, plus, plus-circle, plus-square, pocket, power, radio, rewind, rss, save, search, send, settings, shield, shield-off, shopping-bag, shopping-cart, shuffle, skip-back, skip-forward, slash, sliders, smile, speaker, star, sun, sunrise, sunset, tag, target, terminal, thumbs-down, thumbs-up, toggle-left, toggle-right, trash, trash-2, triangle, truck, twitter, umbrella, video-off, video, voicemail, volume, volume-1, volume-2, volume-x, watch, wind, x-circle, x-octagon, x-square, x, youtube, zap-off, zap, default */
    /***/ (function(module) {

    module.exports = {"activity":["pulse","health","action","motion"],"airplay":["stream","cast","mirroring"],"alert-circle":["warning"],"alert-octagon":["warning"],"alert-triangle":["warning"],"at-sign":["mention"],"award":["achievement","badge"],"aperture":["camera","photo"],"bell":["alarm","notification"],"bell-off":["alarm","notification","silent"],"bluetooth":["wireless"],"book-open":["read"],"book":["read","dictionary","booklet","magazine"],"bookmark":["read","clip","marker","tag"],"briefcase":["work","bag","baggage","folder"],"clipboard":["copy"],"clock":["time","watch","alarm"],"cloud-drizzle":["weather","shower"],"cloud-lightning":["weather","bolt"],"cloud-rain":["weather"],"cloud-snow":["weather","blizzard"],"cloud":["weather"],"codepen":["logo"],"codesandbox":["logo"],"coffee":["drink","cup","mug","tea","cafe","hot","beverage"],"command":["keyboard","cmd"],"compass":["navigation","safari","travel"],"copy":["clone","duplicate"],"corner-down-left":["arrow"],"corner-down-right":["arrow"],"corner-left-down":["arrow"],"corner-left-up":["arrow"],"corner-right-down":["arrow"],"corner-right-up":["arrow"],"corner-up-left":["arrow"],"corner-up-right":["arrow"],"credit-card":["purchase","payment","cc"],"crop":["photo","image"],"crosshair":["aim","target"],"database":["storage"],"delete":["remove"],"disc":["album","cd","dvd","music"],"dollar-sign":["currency","money","payment"],"droplet":["water"],"edit":["pencil","change"],"edit-2":["pencil","change"],"edit-3":["pencil","change"],"eye":["view","watch"],"eye-off":["view","watch"],"external-link":["outbound"],"facebook":["logo"],"fast-forward":["music"],"figma":["logo","design","tool"],"film":["movie","video"],"folder-minus":["directory"],"folder-plus":["directory"],"folder":["directory"],"framer":["logo","design","tool"],"frown":["emoji","face","bad","sad","emotion"],"gift":["present","box","birthday","party"],"git-branch":["code","version control"],"git-commit":["code","version control"],"git-merge":["code","version control"],"git-pull-request":["code","version control"],"github":["logo","version control"],"gitlab":["logo","version control"],"global":["world","browser","language","translate"],"hard-drive":["computer","server"],"hash":["hashtag","number","pound"],"headphones":["music","audio"],"heart":["like","love"],"help-circle":["question mark"],"hexagon":["shape","node.js","logo"],"home":["house"],"image":["picture"],"inbox":["email"],"instagram":["logo","camera"],"key":["password","login","authentication"],"life-bouy":["help","life ring","support"],"linkedin":["logo"],"lock":["security","password"],"log-in":["sign in","arrow"],"log-out":["sign out","arrow"],"mail":["email"],"map-pin":["location","navigation","travel","marker"],"map":["location","navigation","travel"],"maximize":["fullscreen"],"maximize-2":["fullscreen","arrows"],"meh":["emoji","face","neutral","emotion"],"menu":["bars","navigation","hamburger"],"message-circle":["comment","chat"],"message-square":["comment","chat"],"mic-off":["record"],"mic":["record"],"minimize":["exit fullscreen"],"minimize-2":["exit fullscreen","arrows"],"monitor":["tv"],"moon":["dark","night"],"more-horizontal":["ellipsis"],"more-vertical":["ellipsis"],"mouse-pointer":["arrow","cursor"],"move":["arrows"],"navigation":["location","travel"],"navigation-2":["location","travel"],"octagon":["stop"],"package":["box"],"paperclip":["attachment"],"pause":["music","stop"],"pause-circle":["music","stop"],"pen-tool":["vector","drawing"],"play":["music","start"],"play-circle":["music","start"],"plus":["add","new"],"plus-circle":["add","new"],"plus-square":["add","new"],"pocket":["logo","save"],"power":["on","off"],"radio":["signal"],"rewind":["music"],"rss":["feed","subscribe"],"save":["floppy disk"],"search":["find","magnifier","magnifying glass"],"send":["message","mail","paper airplane"],"settings":["cog","edit","gear","preferences"],"shield":["security"],"shield-off":["security"],"shopping-bag":["ecommerce","cart","purchase","store"],"shopping-cart":["ecommerce","cart","purchase","store"],"shuffle":["music"],"skip-back":["music"],"skip-forward":["music"],"slash":["ban","no"],"sliders":["settings","controls"],"smile":["emoji","face","happy","good","emotion"],"speaker":["music"],"star":["bookmark","favorite","like"],"sun":["brightness","weather","light"],"sunrise":["weather"],"sunset":["weather"],"tag":["label"],"target":["bullseye"],"terminal":["code","command line"],"thumbs-down":["dislike","bad"],"thumbs-up":["like","good"],"toggle-left":["on","off","switch"],"toggle-right":["on","off","switch"],"trash":["garbage","delete","remove"],"trash-2":["garbage","delete","remove"],"triangle":["delta"],"truck":["delivery","van","shipping"],"twitter":["logo"],"umbrella":["rain","weather"],"video-off":["camera","movie","film"],"video":["camera","movie","film"],"voicemail":["phone"],"volume":["music","sound","mute"],"volume-1":["music","sound"],"volume-2":["music","sound"],"volume-x":["music","sound","mute"],"watch":["clock","time"],"wind":["weather","air"],"x-circle":["cancel","close","delete","remove","times"],"x-octagon":["delete","stop","alert","warning","times"],"x-square":["cancel","close","delete","remove","times"],"x":["cancel","close","delete","remove","times"],"youtube":["logo","video","play"],"zap-off":["flash","camera","lightning"],"zap":["flash","camera","lightning"]};

    /***/ }),

    /***/ "./src/to-svg.js":
    /*!***********************!*\
      !*** ./src/to-svg.js ***!
      \***********************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _icons = __webpack_require__(/*! ./icons */ "./src/icons.js");

    var _icons2 = _interopRequireDefault(_icons);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    /**
     * Create an SVG string.
     * @deprecated
     * @param {string} name
     * @param {Object} attrs
     * @returns {string}
     */
    function toSvg(name) {
      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      console.warn('feather.toSvg() is deprecated. Please use feather.icons[name].toSvg() instead.');

      if (!name) {
        throw new Error('The required `key` (icon name) parameter is missing.');
      }

      if (!_icons2.default[name]) {
        throw new Error('No icon matching \'' + name + '\'. See the complete list of icons at https://feathericons.com');
      }

      return _icons2.default[name].toSvg(attrs);
    }

    exports.default = toSvg;

    /***/ }),

    /***/ 0:
    /*!**************************************************!*\
      !*** multi core-js/es/array/from ./src/index.js ***!
      \**************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {

    __webpack_require__(/*! core-js/es/array/from */"./node_modules/core-js/es/array/from.js");
    module.exports = __webpack_require__(/*! /home/travis/build/feathericons/feather/src/index.js */"./src/index.js");


    /***/ })

    /******/ });
    });

    });

    var feather$1 = unwrapExports(feather);

    var getIcon = icon => feather$1.toSvg(icon);

    /* src\nav\NavItem.svelte generated by Svelte v3.6.9 */

    const file$3 = "src\\nav\\NavItem.svelte";

    function create_fragment$2(ctx) {
    	var div3, div2, div1, div0, raw_value = getIcon(ctx.icon), dispose;

    	return {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			attr(div0, "class", "icon svelte-td9xyr");
    			add_location(div0, file$3, 24, 12, 485);
    			attr(div1, "class", "inner svelte-td9xyr");
    			add_location(div1, file$3, 23, 8, 452);
    			attr(div2, "class", "nav-item svelte-td9xyr");
    			add_location(div2, file$3, 21, 4, 389);
    			attr(div3, "class", "" + ctx.navActive + " svelte-td9xyr");
    			add_location(div3, file$3, 20, 0, 358);
    			dispose = listen(div2, "click", ctx.setActive);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div3, anchor);
    			append(div3, div2);
    			append(div2, div1);
    			append(div1, div0);
    			div0.innerHTML = raw_value;
    		},

    		p: function update(changed, ctx) {
    			if ((changed.icon) && raw_value !== (raw_value = getIcon(ctx.icon))) {
    				div0.innerHTML = raw_value;
    			}

    			if (changed.navActive) {
    				attr(div3, "class", "" + ctx.navActive + " svelte-td9xyr");
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div3);
    			}

    			dispose();
    		}
    	};
    }

    function instance$2($$self, $$props, $$invalidate) {
    	

    let { name = "", label = "", icon = "" } = $$props;

    let navActive = "";

    database.subscribe(db => {
        $$invalidate('navActive', navActive = (db.activeNav === name ? "active" : ""));
    });

    const setActive = () => 
        database.setActiveNav(name);

    	const writable_props = ['name', 'label', 'icon'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<NavItem> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('name' in $$props) $$invalidate('name', name = $$props.name);
    		if ('label' in $$props) $$invalidate('label', label = $$props.label);
    		if ('icon' in $$props) $$invalidate('icon', icon = $$props.icon);
    	};

    	return { name, label, icon, navActive, setActive };
    }

    class NavItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, ["name", "label", "icon"]);
    	}

    	get name() {
    		throw new Error("<NavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<NavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<NavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<NavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get icon() {
    		throw new Error("<NavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set icon(value) {
    		throw new Error("<NavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\nav\Nav.svelte generated by Svelte v3.6.9 */

    const file$4 = "src\\nav\\Nav.svelte";

    function create_fragment$3(ctx) {
    	var nav, img, t0, t1, t2, t3, t4, current;

    	var navitem0 = new NavItem({
    		props: {
    		name: "database",
    		label: "Database",
    		icon: "database"
    	},
    		$$inline: true
    	});

    	var navitem1 = new NavItem({
    		props: {
    		name: "actions",
    		label: "Actions",
    		icon: "zap"
    	},
    		$$inline: true
    	});

    	var navitem2 = new NavItem({
    		props: {
    		name: "access levels",
    		label: "Access Levels",
    		icon: "user"
    	},
    		$$inline: true
    	});

    	var navitem3 = new NavItem({
    		props: {
    		name: "user interface",
    		label: "User Interface",
    		icon: "monitor"
    	},
    		$$inline: true
    	});

    	var navitem4 = new NavItem({
    		props: {
    		name: "package",
    		label: "Package",
    		icon: "package"
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			nav = element("nav");
    			img = element("img");
    			t0 = space();
    			navitem0.$$.fragment.c();
    			t1 = space();
    			navitem1.$$.fragment.c();
    			t2 = space();
    			navitem2.$$.fragment.c();
    			t3 = space();
    			navitem3.$$.fragment.c();
    			t4 = space();
    			navitem4.$$.fragment.c();
    			attr(img, "src", "/_builder/assets/budibase-logo-only.png");
    			attr(img, "class", "logo svelte-n1ql72");
    			attr(img, "alt", "budibase logo");
    			add_location(img, file$4, 10, 4, 145);
    			attr(nav, "class", "nav svelte-n1ql72");
    			set_style(nav, "width", ctx.width);
    			add_location(nav, file$4, 8, 0, 92);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, nav, anchor);
    			append(nav, img);
    			append(nav, t0);
    			mount_component(navitem0, nav, null);
    			append(nav, t1);
    			mount_component(navitem1, nav, null);
    			append(nav, t2);
    			mount_component(navitem2, nav, null);
    			append(nav, t3);
    			mount_component(navitem3, nav, null);
    			append(nav, t4);
    			mount_component(navitem4, nav, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (!current || changed.width) {
    				set_style(nav, "width", ctx.width);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(navitem0.$$.fragment, local);

    			transition_in(navitem1.$$.fragment, local);

    			transition_in(navitem2.$$.fragment, local);

    			transition_in(navitem3.$$.fragment, local);

    			transition_in(navitem4.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(navitem0.$$.fragment, local);
    			transition_out(navitem1.$$.fragment, local);
    			transition_out(navitem2.$$.fragment, local);
    			transition_out(navitem3.$$.fragment, local);
    			transition_out(navitem4.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(nav);
    			}

    			destroy_component(navitem0);

    			destroy_component(navitem1);

    			destroy_component(navitem2);

    			destroy_component(navitem3);

    			destroy_component(navitem4);
    		}
    	};
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { width=50 } = $$props;

    	const writable_props = ['width'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Nav> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('width' in $$props) $$invalidate('width', width = $$props.width);
    	};

    	return { width };
    }

    class Nav extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, ["width"]);
    	}

    	get width() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\database\HierarchyRow.svelte generated by Svelte v3.6.9 */

    const file$5 = "src\\database\\HierarchyRow.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.child = list[i];
    	return child_ctx;
    }

    // (14:4) {#if node.children}
    function create_if_block(ctx) {
    	var each_1_anchor, current;

    	var each_value = ctx.node.children;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	return {
    		c: function create() {
    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert(target, each_1_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (changed.node || changed.level) {
    				each_value = ctx.node.children;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();
    				for (i = each_value.length; i < each_blocks.length; i += 1) out(i);
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);
    			for (let i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);

    			if (detaching) {
    				detach(each_1_anchor);
    			}
    		}
    	};
    }

    // (15:4) {#each node.children as child}
    function create_each_block$1(ctx) {
    	var current;

    	var hierarchyrow = new HierarchyRow({
    		props: { node: ctx.child, level: ctx.level+1 },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			hierarchyrow.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(hierarchyrow, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var hierarchyrow_changes = {};
    			if (changed.node) hierarchyrow_changes.node = ctx.child;
    			if (changed.level) hierarchyrow_changes.level = ctx.level+1;
    			hierarchyrow.$set(hierarchyrow_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(hierarchyrow.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(hierarchyrow.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(hierarchyrow, detaching);
    		}
    	};
    }

    function create_fragment$4(ctx) {
    	var div1, div0, t0_value = ctx.node.name, t0, t1, current, dispose;

    	var if_block = (ctx.node.children) && create_if_block(ctx);

    	return {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (if_block) if_block.c();
    			attr(div0, "class", "title svelte-1rctf7f");
    			set_style(div0, "padding-left", "" + (20 + (ctx.level * 20)) + "px");
    			add_location(div0, file$5, 10, 4, 170);
    			attr(div1, "class", "root svelte-1rctf7f");
    			add_location(div1, file$5, 9, 0, 146);
    			dispose = listen(div0, "click", ctx.click_handler);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);
    			append(div0, t0);
    			append(div1, t1);
    			if (if_block) if_block.m(div1, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.node) && t0_value !== (t0_value = ctx.node.name)) {
    				set_data(t0, t0_value);
    			}

    			if (!current || changed.level) {
    				set_style(div0, "padding-left", "" + (20 + (ctx.level * 20)) + "px");
    			}

    			if (ctx.node.children) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div1);
    			}

    			if (if_block) if_block.d();
    			dispose();
    		}
    	};
    }

    function instance$4($$self, $$props, $$invalidate) {
    	
    let { level = 0, node } = $$props;

    	const writable_props = ['level', 'node'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<HierarchyRow> was created with unknown prop '${key}'`);
    	});

    	function click_handler() {
    		return database.selectExistingNode(node.nodeId);
    	}

    	$$self.$set = $$props => {
    		if ('level' in $$props) $$invalidate('level', level = $$props.level);
    		if ('node' in $$props) $$invalidate('node', node = $$props.node);
    	};

    	return { level, node, click_handler };
    }

    class HierarchyRow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, ["level", "node"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.node === undefined && !('node' in props)) {
    			console.warn("<HierarchyRow> was created without expected prop 'node'");
    		}
    	}

    	get level() {
    		throw new Error("<HierarchyRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set level(value) {
    		throw new Error("<HierarchyRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get node() {
    		throw new Error("<HierarchyRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set node(value) {
    		throw new Error("<HierarchyRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\common\Textbox.svelte generated by Svelte v3.6.9 */

    const file$6 = "src\\common\\Textbox.svelte";

    function create_fragment$5(ctx) {
    	var div1, div0, t0, t1, input, dispose;

    	return {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(ctx.label);
    			t1 = space();
    			input = element("input");
    			attr(div0, "class", "label svelte-umifqh");
    			add_location(div0, file$6, 6, 4, 99);
    			attr(input, "class", "control uk-input svelte-umifqh");
    			add_location(input, file$6, 7, 4, 137);
    			attr(div1, "class", "container svelte-umifqh");
    			add_location(div1, file$6, 5, 0, 70);
    			dispose = listen(input, "input", ctx.input_input_handler);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);
    			append(div0, t0);
    			append(div1, t1);
    			append(div1, input);

    			input.value = ctx.text;
    		},

    		p: function update(changed, ctx) {
    			if (changed.label) {
    				set_data(t0, ctx.label);
    			}

    			if (changed.text && (input.value !== ctx.text)) input.value = ctx.text;
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div1);
    			}

    			dispose();
    		}
    	};
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { text = "", label = "" } = $$props;

    	const writable_props = ['text', 'label'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Textbox> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		text = this.value;
    		$$invalidate('text', text);
    	}

    	$$self.$set = $$props => {
    		if ('text' in $$props) $$invalidate('text', text = $$props.text);
    		if ('label' in $$props) $$invalidate('label', label = $$props.label);
    	};

    	return { text, label, input_input_handler };
    }

    class Textbox extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, ["text", "label"]);
    	}

    	get text() {
    		throw new Error("<Textbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<Textbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Textbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Textbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\common\Dropdown.svelte generated by Svelte v3.6.9 */

    const file$7 = "src\\common\\Dropdown.svelte";

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.option = list[i];
    	return child_ctx;
    }

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.option = list[i];
    	return child_ctx;
    }

    // (27:4) {:else}
    function create_else_block(ctx) {
    	var select, dispose;

    	var each_value_1 = ctx.options;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	return {
    		c: function create() {
    			select = element("select");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			if (ctx.selected === void 0) add_render_callback(() => ctx.select_change_handler_1.call(select));
    			attr(select, "class", "control uk-select svelte-bm0783");
    			add_location(select, file$7, 28, 4, 641);

    			dispose = [
    				listen(select, "change", ctx.select_change_handler_1),
    				listen(select, "change", ctx.change_handler_1)
    			];
    		},

    		m: function mount(target, anchor) {
    			insert(target, select, anchor);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			select_option(select, ctx.selected);
    		},

    		p: function update(changed, ctx) {
    			if (changed.valueMember || changed.options || changed.textMember) {
    				each_value_1 = ctx.options;

    				for (var i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value_1.length;
    			}

    			if (changed.selected) select_option(select, ctx.selected);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(select);
    			}

    			destroy_each(each_blocks, detaching);

    			run_all(dispose);
    		}
    	};
    }

    // (19:4) {#if multiple}
    function create_if_block$1(ctx) {
    	var select, dispose;

    	var each_value = ctx.options;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			select = element("select");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			if (ctx.selected === void 0) add_render_callback(() => ctx.select_change_handler.call(select));
    			attr(select, "class", "control uk-select svelte-bm0783");
    			select.multiple = true;
    			add_location(select, file$7, 20, 4, 354);

    			dispose = [
    				listen(select, "change", ctx.select_change_handler),
    				listen(select, "change", ctx.change_handler)
    			];
    		},

    		m: function mount(target, anchor) {
    			insert(target, select, anchor);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			select_options(select, ctx.selected);
    		},

    		p: function update(changed, ctx) {
    			if (changed.valueMember || changed.options || changed.textMember) {
    				each_value = ctx.options;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}

    			if (changed.selected) select_options(select, ctx.selected);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(select);
    			}

    			destroy_each(each_blocks, detaching);

    			run_all(dispose);
    		}
    	};
    }

    // (30:8) {#each options as option}
    function create_each_block_1(ctx) {
    	var option, t_value = !ctx.textMember ? ctx.option : ctx.textMember(ctx.option), t, option_value_value;

    	return {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = !ctx.valueMember ? ctx.option : ctx.valueMember(ctx.option);
    			option.value = option.__value;
    			add_location(option, file$7, 30, 8, 752);
    		},

    		m: function mount(target, anchor) {
    			insert(target, option, anchor);
    			append(option, t);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.textMember || changed.options) && t_value !== (t_value = !ctx.textMember ? ctx.option : ctx.textMember(ctx.option))) {
    				set_data(t, t_value);
    			}

    			if ((changed.valueMember || changed.options) && option_value_value !== (option_value_value = !ctx.valueMember ? ctx.option : ctx.valueMember(ctx.option))) {
    				option.__value = option_value_value;
    			}

    			option.value = option.__value;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(option);
    			}
    		}
    	};
    }

    // (22:8) {#each options as option}
    function create_each_block$2(ctx) {
    	var option, t_value = !ctx.textMember ? ctx.option : ctx.textMember(ctx.option), t, option_value_value;

    	return {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = !ctx.valueMember ? ctx.option : ctx.valueMember(ctx.option);
    			option.value = option.__value;
    			add_location(option, file$7, 22, 8, 474);
    		},

    		m: function mount(target, anchor) {
    			insert(target, option, anchor);
    			append(option, t);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.textMember || changed.options) && t_value !== (t_value = !ctx.textMember ? ctx.option : ctx.textMember(ctx.option))) {
    				set_data(t, t_value);
    			}

    			if ((changed.valueMember || changed.options) && option_value_value !== (option_value_value = !ctx.valueMember ? ctx.option : ctx.valueMember(ctx.option))) {
    				option.__value = option_value_value;
    			}

    			option.value = option.__value;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(option);
    			}
    		}
    	};
    }

    function create_fragment$6(ctx) {
    	var div1, div0, t0, t1;

    	function select_block_type(ctx) {
    		if (ctx.multiple) return create_if_block$1;
    		return create_else_block;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(ctx);

    	return {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(ctx.label);
    			t1 = space();
    			if_block.c();
    			attr(div0, "class", "label svelte-bm0783");
    			add_location(div0, file$7, 16, 4, 288);
    			attr(div1, "class", "container svelte-bm0783");
    			add_location(div1, file$7, 15, 0, 259);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);
    			append(div0, t0);
    			append(div1, t1);
    			if_block.m(div1, null);
    		},

    		p: function update(changed, ctx) {
    			if (changed.label) {
    				set_data(t0, ctx.label);
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);
    				if (if_block) {
    					if_block.c();
    					if_block.m(div1, null);
    				}
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div1);
    			}

    			if_block.d();
    		}
    	};
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { selected, label, options, valueMember, textMember, multiple=false } = $$props;

    	const writable_props = ['selected', 'label', 'options', 'valueMember', 'textMember', 'multiple'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Dropdown> was created with unknown prop '${key}'`);
    	});

    	function change_handler(event) {
    		bubble($$self, event);
    	}

    	function change_handler_1(event) {
    		bubble($$self, event);
    	}

    	function select_change_handler() {
    		selected = select_multiple_value(this);
    		$$invalidate('selected', selected);
    		$$invalidate('valueMember', valueMember);
    		$$invalidate('options', options);
    	}

    	function select_change_handler_1() {
    		selected = select_value(this);
    		$$invalidate('selected', selected);
    		$$invalidate('valueMember', valueMember);
    		$$invalidate('options', options);
    	}

    	$$self.$set = $$props => {
    		if ('selected' in $$props) $$invalidate('selected', selected = $$props.selected);
    		if ('label' in $$props) $$invalidate('label', label = $$props.label);
    		if ('options' in $$props) $$invalidate('options', options = $$props.options);
    		if ('valueMember' in $$props) $$invalidate('valueMember', valueMember = $$props.valueMember);
    		if ('textMember' in $$props) $$invalidate('textMember', textMember = $$props.textMember);
    		if ('multiple' in $$props) $$invalidate('multiple', multiple = $$props.multiple);
    	};

    	return {
    		selected,
    		label,
    		options,
    		valueMember,
    		textMember,
    		multiple,
    		change_handler,
    		change_handler_1,
    		select_change_handler,
    		select_change_handler_1
    	};
    }

    class Dropdown extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, ["selected", "label", "options", "valueMember", "textMember", "multiple"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.selected === undefined && !('selected' in props)) {
    			console.warn("<Dropdown> was created without expected prop 'selected'");
    		}
    		if (ctx.label === undefined && !('label' in props)) {
    			console.warn("<Dropdown> was created without expected prop 'label'");
    		}
    		if (ctx.options === undefined && !('options' in props)) {
    			console.warn("<Dropdown> was created without expected prop 'options'");
    		}
    		if (ctx.valueMember === undefined && !('valueMember' in props)) {
    			console.warn("<Dropdown> was created without expected prop 'valueMember'");
    		}
    		if (ctx.textMember === undefined && !('textMember' in props)) {
    			console.warn("<Dropdown> was created without expected prop 'textMember'");
    		}
    	}

    	get selected() {
    		throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get options() {
    		throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get valueMember() {
    		throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set valueMember(value) {
    		throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get textMember() {
    		throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set textMember(value) {
    		throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get multiple() {
    		throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set multiple(value) {
    		throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\common\ButtonGroup.svelte generated by Svelte v3.6.9 */

    const file$8 = "src\\common\\ButtonGroup.svelte";

    function create_fragment$7(ctx) {
    	var div, current;

    	const default_slot_1 = ctx.$$slots.default;
    	const default_slot = create_slot(default_slot_1, ctx, null);

    	return {
    		c: function create() {
    			div = element("div");

    			if (default_slot) default_slot.c();

    			attr(div, "class", "root svelte-d6wwkb");
    			attr(div, "style", ctx.style);
    			add_location(div, file$8, 4, 0, 45);
    		},

    		l: function claim(nodes) {
    			if (default_slot) default_slot.l(div_nodes);
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (default_slot && default_slot.p && changed.$$scope) {
    				default_slot.p(get_slot_changes(default_slot_1, ctx, changed, null), get_slot_context(default_slot_1, ctx, null));
    			}

    			if (!current || changed.style) {
    				attr(div, "style", ctx.style);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			if (default_slot) default_slot.d(detaching);
    		}
    	};
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { style="" } = $$props;

    	const writable_props = ['style'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<ButtonGroup> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;

    	$$self.$set = $$props => {
    		if ('style' in $$props) $$invalidate('style', style = $$props.style);
    		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
    	};

    	return { style, $$slots, $$scope };
    }

    class ButtonGroup extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, ["style"]);
    	}

    	get style() {
    		throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\common\NumberBox.svelte generated by Svelte v3.6.9 */

    const file$9 = "src\\common\\NumberBox.svelte";

    function create_fragment$8(ctx) {
    	var div1, div0, t0, t1, input, dispose;

    	return {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(ctx.label);
    			t1 = space();
    			input = element("input");
    			attr(div0, "class", "label svelte-umifqh");
    			add_location(div0, file$9, 20, 4, 333);
    			attr(input, "class", "control svelte-umifqh");
    			attr(input, "type", "text");
    			input.value = ctx.value;
    			add_location(input, file$9, 21, 4, 371);
    			attr(div1, "class", "container svelte-umifqh");
    			add_location(div1, file$9, 19, 0, 304);
    			dispose = listen(input, "change", ctx.inputChanged);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);
    			append(div0, t0);
    			append(div1, t1);
    			append(div1, input);
    		},

    		p: function update(changed, ctx) {
    			if (changed.label) {
    				set_data(t0, ctx.label);
    			}

    			if (changed.value) {
    				input.value = ctx.value;
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div1);
    			}

    			dispose();
    		}
    	};
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { value, label } = $$props;

    const inputChanged = ev => {
        try {
            $$invalidate('value', value = Number(ev.target.value));
        } catch(_) {
            $$invalidate('value', value = null);
        }
    };

    let numberText = value === null || value === undefined
                     ? "" : value.toString();

    	const writable_props = ['value', 'label'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<NumberBox> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('value' in $$props) $$invalidate('value', value = $$props.value);
    		if ('label' in $$props) $$invalidate('label', label = $$props.label);
    	};

    	return { value, label, inputChanged };
    }

    class NumberBox extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, ["value", "label"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.value === undefined && !('value' in props)) {
    			console.warn("<NumberBox> was created without expected prop 'value'");
    		}
    		if (ctx.label === undefined && !('label' in props)) {
    			console.warn("<NumberBox> was created without expected prop 'label'");
    		}
    	}

    	get value() {
    		throw new Error("<NumberBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<NumberBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<NumberBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<NumberBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\common\ValuesList.svelte generated by Svelte v3.6.9 */

    const file$a = "src\\common\\ValuesList.svelte";

    function create_fragment$9(ctx) {
    	var div1, div0, t0, t1, textarea, dispose;

    	return {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(ctx.label);
    			t1 = space();
    			textarea = element("textarea");
    			attr(div0, "class", "label svelte-85b8gk");
    			add_location(div0, file$a, 20, 4, 309);
    			attr(textarea, "class", "control svelte-85b8gk");
    			textarea.value = ctx.valuesText;
    			add_location(textarea, file$a, 21, 4, 347);
    			attr(div1, "class", "container svelte-85b8gk");
    			add_location(div1, file$a, 19, 0, 280);
    			dispose = listen(textarea, "change", ctx.inputChanged);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);
    			append(div0, t0);
    			append(div1, t1);
    			append(div1, textarea);
    		},

    		p: function update(changed, ctx) {
    			if (changed.label) {
    				set_data(t0, ctx.label);
    			}

    			if (changed.valuesText) {
    				textarea.value = ctx.valuesText;
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div1);
    			}

    			dispose();
    		}
    	};
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { values, label } = $$props;

    const inputChanged = ev => {
        try {
            $$invalidate('values', values = ev.target.value.split("\n"));
        } catch(_) {
            $$invalidate('values', values = []);
        }
    };

    	const writable_props = ['values', 'label'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<ValuesList> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('values' in $$props) $$invalidate('values', values = $$props.values);
    		if ('label' in $$props) $$invalidate('label', label = $$props.label);
    	};

    	let valuesText;

    	$$self.$$.update = ($$dirty = { values: 1 }) => {
    		if ($$dirty.values) { $$invalidate('valuesText', valuesText = fp.join("\n")(values)); }
    	};

    	return { values, label, inputChanged, valuesText };
    }

    class ValuesList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, ["values", "label"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.values === undefined && !('values' in props)) {
    			console.warn("<ValuesList> was created without expected prop 'values'");
    		}
    		if (ctx.label === undefined && !('label' in props)) {
    			console.warn("<ValuesList> was created without expected prop 'label'");
    		}
    	}

    	get values() {
    		throw new Error("<ValuesList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set values(value) {
    		throw new Error("<ValuesList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<ValuesList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<ValuesList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\common\ErrorsBox.svelte generated by Svelte v3.6.9 */

    const file$b = "src\\common\\ErrorsBox.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.error = list[i];
    	return child_ctx;
    }

    // (7:0) {#if hasErrors}
    function create_if_block$2(ctx) {
    	var div;

    	var each_value = ctx.errors;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			div = element("div");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			attr(div, "class", "error-container svelte-jwy920");
    			add_location(div, file$b, 7, 0, 101);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (changed.errors) {
    				each_value = ctx.errors;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			destroy_each(each_blocks, detaching);
    		}
    	};
    }

    // (9:4) {#each errors as error}
    function create_each_block$3(ctx) {
    	var div, t0_value = ctx.error.field ? `${ctx.error.field}: ` : "", t0, t1_value = ctx.error.error, t1;

    	return {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			attr(div, "class", "error-row svelte-jwy920");
    			add_location(div, file$b, 9, 4, 165);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, t0);
    			append(div, t1);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.errors) && t0_value !== (t0_value = ctx.error.field ? `${ctx.error.field}: ` : "")) {
    				set_data(t0, t0_value);
    			}

    			if ((changed.errors) && t1_value !== (t1_value = ctx.error.error)) {
    				set_data(t1, t1_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}
    		}
    	};
    }

    function create_fragment$a(ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.hasErrors) && create_if_block$2(ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.hasErrors) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$2(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let { errors = [] } = $$props;

    	const writable_props = ['errors'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<ErrorsBox> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('errors' in $$props) $$invalidate('errors', errors = $$props.errors);
    	};

    	let hasErrors;

    	$$self.$$.update = ($$dirty = { errors: 1 }) => {
    		if ($$dirty.errors) { $$invalidate('hasErrors', hasErrors = errors.length > 0); }
    	};

    	return { errors, hasErrors };
    }

    class ErrorsBox extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, ["errors"]);
    	}

    	get errors() {
    		throw new Error("<ErrorsBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set errors(value) {
    		throw new Error("<ErrorsBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\common\Checkbox.svelte generated by Svelte v3.6.9 */

    const file$c = "src\\common\\Checkbox.svelte";

    function create_fragment$b(ctx) {
    	var input, t, dispose;

    	return {
    		c: function create() {
    			input = element("input");
    			t = text(ctx.label);
    			attr(input, "class", "uk-checkbox svelte-66516k");
    			attr(input, "type", "checkbox");
    			add_location(input, file$c, 7, 0, 76);

    			dispose = [
    				listen(input, "change", ctx.input_change_handler),
    				listen(input, "change", ctx.change_handler)
    			];
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, input, anchor);

    			input.checked = ctx.checked;

    			insert(target, t, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (changed.checked) input.checked = ctx.checked;

    			if (changed.label) {
    				set_data(t, ctx.label);
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(input);
    				detach(t);
    			}

    			run_all(dispose);
    		}
    	};
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { checked=false, label="" } = $$props;

    	const writable_props = ['checked', 'label'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Checkbox> was created with unknown prop '${key}'`);
    	});

    	function change_handler(event) {
    		bubble($$self, event);
    	}

    	function input_change_handler() {
    		checked = this.checked;
    		$$invalidate('checked', checked);
    	}

    	$$self.$set = $$props => {
    		if ('checked' in $$props) $$invalidate('checked', checked = $$props.checked);
    		if ('label' in $$props) $$invalidate('label', label = $$props.label);
    	};

    	return {
    		checked,
    		label,
    		change_handler,
    		input_change_handler
    	};
    }

    class Checkbox extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, ["checked", "label"]);
    	}

    	get checked() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set checked(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var flatpickr = createCommonjsModule(function (module, exports) {
    /* flatpickr v4.6.2, @license MIT */
    (function (global, factory) {
         module.exports = factory() ;
    }(commonjsGlobal, function () {
        /*! *****************************************************************************
        Copyright (c) Microsoft Corporation. All rights reserved.
        Licensed under the Apache License, Version 2.0 (the "License"); you may not use
        this file except in compliance with the License. You may obtain a copy of the
        License at http://www.apache.org/licenses/LICENSE-2.0

        THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
        KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
        WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
        MERCHANTABLITY OR NON-INFRINGEMENT.

        See the Apache Version 2.0 License for specific language governing permissions
        and limitations under the License.
        ***************************************************************************** */

        var __assign = function() {
            __assign = Object.assign || function __assign(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
            };
            return __assign.apply(this, arguments);
        };

        var HOOKS = [
            "onChange",
            "onClose",
            "onDayCreate",
            "onDestroy",
            "onKeyDown",
            "onMonthChange",
            "onOpen",
            "onParseConfig",
            "onReady",
            "onValueUpdate",
            "onYearChange",
            "onPreCalendarPosition",
        ];
        var defaults = {
            _disable: [],
            _enable: [],
            allowInput: false,
            altFormat: "F j, Y",
            altInput: false,
            altInputClass: "form-control input",
            animate: typeof window === "object" &&
                window.navigator.userAgent.indexOf("MSIE") === -1,
            ariaDateFormat: "F j, Y",
            clickOpens: true,
            closeOnSelect: true,
            conjunction: ", ",
            dateFormat: "Y-m-d",
            defaultHour: 12,
            defaultMinute: 0,
            defaultSeconds: 0,
            disable: [],
            disableMobile: false,
            enable: [],
            enableSeconds: false,
            enableTime: false,
            errorHandler: function (err) {
                return typeof console !== "undefined" && console.warn(err);
            },
            getWeek: function (givenDate) {
                var date = new Date(givenDate.getTime());
                date.setHours(0, 0, 0, 0);
                // Thursday in current week decides the year.
                date.setDate(date.getDate() + 3 - ((date.getDay() + 6) % 7));
                // January 4 is always in week 1.
                var week1 = new Date(date.getFullYear(), 0, 4);
                // Adjust to Thursday in week 1 and count number of weeks from date to week1.
                return (1 +
                    Math.round(((date.getTime() - week1.getTime()) / 86400000 -
                        3 +
                        ((week1.getDay() + 6) % 7)) /
                        7));
            },
            hourIncrement: 1,
            ignoredFocusElements: [],
            inline: false,
            locale: "default",
            minuteIncrement: 5,
            mode: "single",
            monthSelectorType: "dropdown",
            nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
            noCalendar: false,
            now: new Date(),
            onChange: [],
            onClose: [],
            onDayCreate: [],
            onDestroy: [],
            onKeyDown: [],
            onMonthChange: [],
            onOpen: [],
            onParseConfig: [],
            onReady: [],
            onValueUpdate: [],
            onYearChange: [],
            onPreCalendarPosition: [],
            plugins: [],
            position: "auto",
            positionElement: undefined,
            prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
            shorthandCurrentMonth: false,
            showMonths: 1,
            static: false,
            time_24hr: false,
            weekNumbers: false,
            wrap: false
        };

        var english = {
            weekdays: {
                shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                longhand: [
                    "Sunday",
                    "Monday",
                    "Tuesday",
                    "Wednesday",
                    "Thursday",
                    "Friday",
                    "Saturday",
                ]
            },
            months: {
                shorthand: [
                    "Jan",
                    "Feb",
                    "Mar",
                    "Apr",
                    "May",
                    "Jun",
                    "Jul",
                    "Aug",
                    "Sep",
                    "Oct",
                    "Nov",
                    "Dec",
                ],
                longhand: [
                    "January",
                    "February",
                    "March",
                    "April",
                    "May",
                    "June",
                    "July",
                    "August",
                    "September",
                    "October",
                    "November",
                    "December",
                ]
            },
            daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
            firstDayOfWeek: 0,
            ordinal: function (nth) {
                var s = nth % 100;
                if (s > 3 && s < 21)
                    return "th";
                switch (s % 10) {
                    case 1:
                        return "st";
                    case 2:
                        return "nd";
                    case 3:
                        return "rd";
                    default:
                        return "th";
                }
            },
            rangeSeparator: " to ",
            weekAbbreviation: "Wk",
            scrollTitle: "Scroll to increment",
            toggleTitle: "Click to toggle",
            amPM: ["AM", "PM"],
            yearAriaLabel: "Year",
            hourAriaLabel: "Hour",
            minuteAriaLabel: "Minute",
            time_24hr: false
        };

        var pad = function (number) { return ("0" + number).slice(-2); };
        var int = function (bool) { return (bool === true ? 1 : 0); };
        /* istanbul ignore next */
        function debounce(func, wait, immediate) {
            if (immediate === void 0) { immediate = false; }
            var timeout;
            return function () {
                var context = this, args = arguments;
                timeout !== null && clearTimeout(timeout);
                timeout = window.setTimeout(function () {
                    timeout = null;
                    if (!immediate)
                        func.apply(context, args);
                }, wait);
                if (immediate && !timeout)
                    func.apply(context, args);
            };
        }
        var arrayify = function (obj) {
            return obj instanceof Array ? obj : [obj];
        };

        function toggleClass(elem, className, bool) {
            if (bool === true)
                return elem.classList.add(className);
            elem.classList.remove(className);
        }
        function createElement(tag, className, content) {
            var e = window.document.createElement(tag);
            className = className || "";
            content = content || "";
            e.className = className;
            if (content !== undefined)
                e.textContent = content;
            return e;
        }
        function clearNode(node) {
            while (node.firstChild)
                node.removeChild(node.firstChild);
        }
        function findParent(node, condition) {
            if (condition(node))
                return node;
            else if (node.parentNode)
                return findParent(node.parentNode, condition);
            return undefined; // nothing found
        }
        function createNumberInput(inputClassName, opts) {
            var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
            if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
                numInput.type = "number";
            }
            else {
                numInput.type = "text";
                numInput.pattern = "\\d*";
            }
            if (opts !== undefined)
                for (var key in opts)
                    numInput.setAttribute(key, opts[key]);
            wrapper.appendChild(numInput);
            wrapper.appendChild(arrowUp);
            wrapper.appendChild(arrowDown);
            return wrapper;
        }
        function getEventTarget(event) {
            if (typeof event.composedPath === "function") {
                var path = event.composedPath();
                return path[0];
            }
            return event.target;
        }

        var doNothing = function () { return undefined; };
        var monthToStr = function (monthNumber, shorthand, locale) { return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber]; };
        var revFormat = {
            D: doNothing,
            F: function (dateObj, monthName, locale) {
                dateObj.setMonth(locale.months.longhand.indexOf(monthName));
            },
            G: function (dateObj, hour) {
                dateObj.setHours(parseFloat(hour));
            },
            H: function (dateObj, hour) {
                dateObj.setHours(parseFloat(hour));
            },
            J: function (dateObj, day) {
                dateObj.setDate(parseFloat(day));
            },
            K: function (dateObj, amPM, locale) {
                dateObj.setHours((dateObj.getHours() % 12) +
                    12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
            },
            M: function (dateObj, shortMonth, locale) {
                dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
            },
            S: function (dateObj, seconds) {
                dateObj.setSeconds(parseFloat(seconds));
            },
            U: function (_, unixSeconds) { return new Date(parseFloat(unixSeconds) * 1000); },
            W: function (dateObj, weekNum, locale) {
                var weekNumber = parseInt(weekNum);
                var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
                date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
                return date;
            },
            Y: function (dateObj, year) {
                dateObj.setFullYear(parseFloat(year));
            },
            Z: function (_, ISODate) { return new Date(ISODate); },
            d: function (dateObj, day) {
                dateObj.setDate(parseFloat(day));
            },
            h: function (dateObj, hour) {
                dateObj.setHours(parseFloat(hour));
            },
            i: function (dateObj, minutes) {
                dateObj.setMinutes(parseFloat(minutes));
            },
            j: function (dateObj, day) {
                dateObj.setDate(parseFloat(day));
            },
            l: doNothing,
            m: function (dateObj, month) {
                dateObj.setMonth(parseFloat(month) - 1);
            },
            n: function (dateObj, month) {
                dateObj.setMonth(parseFloat(month) - 1);
            },
            s: function (dateObj, seconds) {
                dateObj.setSeconds(parseFloat(seconds));
            },
            u: function (_, unixMillSeconds) {
                return new Date(parseFloat(unixMillSeconds));
            },
            w: doNothing,
            y: function (dateObj, year) {
                dateObj.setFullYear(2000 + parseFloat(year));
            }
        };
        var tokenRegex = {
            D: "(\\w+)",
            F: "(\\w+)",
            G: "(\\d\\d|\\d)",
            H: "(\\d\\d|\\d)",
            J: "(\\d\\d|\\d)\\w+",
            K: "",
            M: "(\\w+)",
            S: "(\\d\\d|\\d)",
            U: "(.+)",
            W: "(\\d\\d|\\d)",
            Y: "(\\d{4})",
            Z: "(.+)",
            d: "(\\d\\d|\\d)",
            h: "(\\d\\d|\\d)",
            i: "(\\d\\d|\\d)",
            j: "(\\d\\d|\\d)",
            l: "(\\w+)",
            m: "(\\d\\d|\\d)",
            n: "(\\d\\d|\\d)",
            s: "(\\d\\d|\\d)",
            u: "(.+)",
            w: "(\\d\\d|\\d)",
            y: "(\\d{2})"
        };
        var formats = {
            // get the date in UTC
            Z: function (date) { return date.toISOString(); },
            // weekday name, short, e.g. Thu
            D: function (date, locale, options) {
                return locale.weekdays.shorthand[formats.w(date, locale, options)];
            },
            // full month name e.g. January
            F: function (date, locale, options) {
                return monthToStr(formats.n(date, locale, options) - 1, false, locale);
            },
            // padded hour 1-12
            G: function (date, locale, options) {
                return pad(formats.h(date, locale, options));
            },
            // hours with leading zero e.g. 03
            H: function (date) { return pad(date.getHours()); },
            // day (1-30) with ordinal suffix e.g. 1st, 2nd
            J: function (date, locale) {
                return locale.ordinal !== undefined
                    ? date.getDate() + locale.ordinal(date.getDate())
                    : date.getDate();
            },
            // AM/PM
            K: function (date, locale) { return locale.amPM[int(date.getHours() > 11)]; },
            // shorthand month e.g. Jan, Sep, Oct, etc
            M: function (date, locale) {
                return monthToStr(date.getMonth(), true, locale);
            },
            // seconds 00-59
            S: function (date) { return pad(date.getSeconds()); },
            // unix timestamp
            U: function (date) { return date.getTime() / 1000; },
            W: function (date, _, options) {
                return options.getWeek(date);
            },
            // full year e.g. 2016
            Y: function (date) { return date.getFullYear(); },
            // day in month, padded (01-30)
            d: function (date) { return pad(date.getDate()); },
            // hour from 1-12 (am/pm)
            h: function (date) { return (date.getHours() % 12 ? date.getHours() % 12 : 12); },
            // minutes, padded with leading zero e.g. 09
            i: function (date) { return pad(date.getMinutes()); },
            // day in month (1-30)
            j: function (date) { return date.getDate(); },
            // weekday name, full, e.g. Thursday
            l: function (date, locale) {
                return locale.weekdays.longhand[date.getDay()];
            },
            // padded month number (01-12)
            m: function (date) { return pad(date.getMonth() + 1); },
            // the month number (1-12)
            n: function (date) { return date.getMonth() + 1; },
            // seconds 0-59
            s: function (date) { return date.getSeconds(); },
            // Unix Milliseconds
            u: function (date) { return date.getTime(); },
            // number of the day of the week
            w: function (date) { return date.getDay(); },
            // last two digits of year e.g. 16 for 2016
            y: function (date) { return String(date.getFullYear()).substring(2); }
        };

        var createDateFormatter = function (_a) {
            var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
            return function (dateObj, frmt, overrideLocale) {
                var locale = overrideLocale || l10n;
                if (config.formatDate !== undefined) {
                    return config.formatDate(dateObj, frmt, locale);
                }
                return frmt
                    .split("")
                    .map(function (c, i, arr) {
                    return formats[c] && arr[i - 1] !== "\\"
                        ? formats[c](dateObj, locale, config)
                        : c !== "\\"
                            ? c
                            : "";
                })
                    .join("");
            };
        };
        var createDateParser = function (_a) {
            var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
            return function (date, givenFormat, timeless, customLocale) {
                if (date !== 0 && !date)
                    return undefined;
                var locale = customLocale || l10n;
                var parsedDate;
                var dateOrig = date;
                if (date instanceof Date)
                    parsedDate = new Date(date.getTime());
                else if (typeof date !== "string" &&
                    date.toFixed !== undefined // timestamp
                )
                    // create a copy
                    parsedDate = new Date(date);
                else if (typeof date === "string") {
                    // date string
                    var format = givenFormat || (config || defaults).dateFormat;
                    var datestr = String(date).trim();
                    if (datestr === "today") {
                        parsedDate = new Date();
                        timeless = true;
                    }
                    else if (/Z$/.test(datestr) ||
                        /GMT$/.test(datestr) // datestrings w/ timezone
                    )
                        parsedDate = new Date(date);
                    else if (config && config.parseDate)
                        parsedDate = config.parseDate(date, format);
                    else {
                        parsedDate =
                            !config || !config.noCalendar
                                ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0)
                                : new Date(new Date().setHours(0, 0, 0, 0));
                        var matched = void 0, ops = [];
                        for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
                            var token_1 = format[i];
                            var isBackSlash = token_1 === "\\";
                            var escaped = format[i - 1] === "\\" || isBackSlash;
                            if (tokenRegex[token_1] && !escaped) {
                                regexStr += tokenRegex[token_1];
                                var match = new RegExp(regexStr).exec(date);
                                if (match && (matched = true)) {
                                    ops[token_1 !== "Y" ? "push" : "unshift"]({
                                        fn: revFormat[token_1],
                                        val: match[++matchIndex]
                                    });
                                }
                            }
                            else if (!isBackSlash)
                                regexStr += "."; // don't really care
                            ops.forEach(function (_a) {
                                var fn = _a.fn, val = _a.val;
                                return (parsedDate = fn(parsedDate, val, locale) || parsedDate);
                            });
                        }
                        parsedDate = matched ? parsedDate : undefined;
                    }
                }
                /* istanbul ignore next */
                if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
                    config.errorHandler(new Error("Invalid date provided: " + dateOrig));
                    return undefined;
                }
                if (timeless === true)
                    parsedDate.setHours(0, 0, 0, 0);
                return parsedDate;
            };
        };
        /**
         * Compute the difference in dates, measured in ms
         */
        function compareDates(date1, date2, timeless) {
            if (timeless === void 0) { timeless = true; }
            if (timeless !== false) {
                return (new Date(date1.getTime()).setHours(0, 0, 0, 0) -
                    new Date(date2.getTime()).setHours(0, 0, 0, 0));
            }
            return date1.getTime() - date2.getTime();
        }
        var isBetween = function (ts, ts1, ts2) {
            return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
        };
        var duration = {
            DAY: 86400000
        };

        if (typeof Object.assign !== "function") {
            Object.assign = function (target) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                if (!target) {
                    throw TypeError("Cannot convert undefined or null to object");
                }
                var _loop_1 = function (source) {
                    if (source) {
                        Object.keys(source).forEach(function (key) { return (target[key] = source[key]); });
                    }
                };
                for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
                    var source = args_1[_a];
                    _loop_1(source);
                }
                return target;
            };
        }

        var DEBOUNCED_CHANGE_MS = 300;
        function FlatpickrInstance(element, instanceConfig) {
            var self = {
                config: __assign({}, defaults, flatpickr.defaultConfig),
                l10n: english
            };
            self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
            self._handlers = [];
            self.pluginElements = [];
            self.loadedPlugins = [];
            self._bind = bind;
            self._setHoursFromDate = setHoursFromDate;
            self._positionCalendar = positionCalendar;
            self.changeMonth = changeMonth;
            self.changeYear = changeYear;
            self.clear = clear;
            self.close = close;
            self._createElement = createElement;
            self.destroy = destroy;
            self.isEnabled = isEnabled;
            self.jumpToDate = jumpToDate;
            self.open = open;
            self.redraw = redraw;
            self.set = set;
            self.setDate = setDate;
            self.toggle = toggle;
            function setupHelperFunctions() {
                self.utils = {
                    getDaysInMonth: function (month, yr) {
                        if (month === void 0) { month = self.currentMonth; }
                        if (yr === void 0) { yr = self.currentYear; }
                        if (month === 1 && ((yr % 4 === 0 && yr % 100 !== 0) || yr % 400 === 0))
                            return 29;
                        return self.l10n.daysInMonth[month];
                    }
                };
            }
            function init() {
                self.element = self.input = element;
                self.isOpen = false;
                parseConfig();
                setupLocale();
                setupInputs();
                setupDates();
                setupHelperFunctions();
                if (!self.isMobile)
                    build();
                bindEvents();
                if (self.selectedDates.length || self.config.noCalendar) {
                    if (self.config.enableTime) {
                        setHoursFromDate(self.config.noCalendar
                            ? self.latestSelectedDateObj || self.config.minDate
                            : undefined);
                    }
                    updateValue(false);
                }
                setCalendarWidth();
                self.showTimeInput =
                    self.selectedDates.length > 0 || self.config.noCalendar;
                var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
                /* TODO: investigate this further
            
                  Currently, there is weird positioning behavior in safari causing pages
                  to scroll up. https://github.com/chmln/flatpickr/issues/563
            
                  However, most browsers are not Safari and positioning is expensive when used
                  in scale. https://github.com/chmln/flatpickr/issues/1096
                */
                if (!self.isMobile && isSafari) {
                    positionCalendar();
                }
                triggerEvent("onReady");
            }
            function bindToInstance(fn) {
                return fn.bind(self);
            }
            function setCalendarWidth() {
                var config = self.config;
                if (config.weekNumbers === false && config.showMonths === 1)
                    return;
                else if (config.noCalendar !== true) {
                    window.requestAnimationFrame(function () {
                        if (self.calendarContainer !== undefined) {
                            self.calendarContainer.style.visibility = "hidden";
                            self.calendarContainer.style.display = "block";
                        }
                        if (self.daysContainer !== undefined) {
                            var daysWidth = (self.days.offsetWidth + 1) * config.showMonths;
                            self.daysContainer.style.width = daysWidth + "px";
                            self.calendarContainer.style.width =
                                daysWidth +
                                    (self.weekWrapper !== undefined
                                        ? self.weekWrapper.offsetWidth
                                        : 0) +
                                    "px";
                            self.calendarContainer.style.removeProperty("visibility");
                            self.calendarContainer.style.removeProperty("display");
                        }
                    });
                }
            }
            /**
             * The handler for all events targeting the time inputs
             */
            function updateTime(e) {
                if (self.selectedDates.length === 0) {
                    setDefaultTime();
                }
                if (e !== undefined && e.type !== "blur") {
                    timeWrapper(e);
                }
                var prevValue = self._input.value;
                setHoursFromInputs();
                updateValue();
                if (self._input.value !== prevValue) {
                    self._debouncedChange();
                }
            }
            function ampm2military(hour, amPM) {
                return (hour % 12) + 12 * int(amPM === self.l10n.amPM[1]);
            }
            function military2ampm(hour) {
                switch (hour % 24) {
                    case 0:
                    case 12:
                        return 12;
                    default:
                        return hour % 12;
                }
            }
            /**
             * Syncs the selected date object time with user's time input
             */
            function setHoursFromInputs() {
                if (self.hourElement === undefined || self.minuteElement === undefined)
                    return;
                var hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60, seconds = self.secondElement !== undefined
                    ? (parseInt(self.secondElement.value, 10) || 0) % 60
                    : 0;
                if (self.amPM !== undefined) {
                    hours = ampm2military(hours, self.amPM.textContent);
                }
                var limitMinHours = self.config.minTime !== undefined ||
                    (self.config.minDate &&
                        self.minDateHasTime &&
                        self.latestSelectedDateObj &&
                        compareDates(self.latestSelectedDateObj, self.config.minDate, true) ===
                            0);
                var limitMaxHours = self.config.maxTime !== undefined ||
                    (self.config.maxDate &&
                        self.maxDateHasTime &&
                        self.latestSelectedDateObj &&
                        compareDates(self.latestSelectedDateObj, self.config.maxDate, true) ===
                            0);
                if (limitMaxHours) {
                    var maxTime = self.config.maxTime !== undefined
                        ? self.config.maxTime
                        : self.config.maxDate;
                    hours = Math.min(hours, maxTime.getHours());
                    if (hours === maxTime.getHours())
                        minutes = Math.min(minutes, maxTime.getMinutes());
                    if (minutes === maxTime.getMinutes())
                        seconds = Math.min(seconds, maxTime.getSeconds());
                }
                if (limitMinHours) {
                    var minTime = self.config.minTime !== undefined
                        ? self.config.minTime
                        : self.config.minDate;
                    hours = Math.max(hours, minTime.getHours());
                    if (hours === minTime.getHours())
                        minutes = Math.max(minutes, minTime.getMinutes());
                    if (minutes === minTime.getMinutes())
                        seconds = Math.max(seconds, minTime.getSeconds());
                }
                setHours(hours, minutes, seconds);
            }
            /**
             * Syncs time input values with a date
             */
            function setHoursFromDate(dateObj) {
                var date = dateObj || self.latestSelectedDateObj;
                if (date)
                    setHours(date.getHours(), date.getMinutes(), date.getSeconds());
            }
            function setDefaultHours() {
                var hours = self.config.defaultHour;
                var minutes = self.config.defaultMinute;
                var seconds = self.config.defaultSeconds;
                if (self.config.minDate !== undefined) {
                    var minHr = self.config.minDate.getHours();
                    var minMinutes = self.config.minDate.getMinutes();
                    hours = Math.max(hours, minHr);
                    if (hours === minHr)
                        minutes = Math.max(minMinutes, minutes);
                    if (hours === minHr && minutes === minMinutes)
                        seconds = self.config.minDate.getSeconds();
                }
                if (self.config.maxDate !== undefined) {
                    var maxHr = self.config.maxDate.getHours();
                    var maxMinutes = self.config.maxDate.getMinutes();
                    hours = Math.min(hours, maxHr);
                    if (hours === maxHr)
                        minutes = Math.min(maxMinutes, minutes);
                    if (hours === maxHr && minutes === maxMinutes)
                        seconds = self.config.maxDate.getSeconds();
                }
                setHours(hours, minutes, seconds);
            }
            /**
             * Sets the hours, minutes, and optionally seconds
             * of the latest selected date object and the
             * corresponding time inputs
             * @param {Number} hours the hour. whether its military
             *                 or am-pm gets inferred from config
             * @param {Number} minutes the minutes
             * @param {Number} seconds the seconds (optional)
             */
            function setHours(hours, minutes, seconds) {
                if (self.latestSelectedDateObj !== undefined) {
                    self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
                }
                if (!self.hourElement || !self.minuteElement || self.isMobile)
                    return;
                self.hourElement.value = pad(!self.config.time_24hr
                    ? ((12 + hours) % 12) + 12 * int(hours % 12 === 0)
                    : hours);
                self.minuteElement.value = pad(minutes);
                if (self.amPM !== undefined)
                    self.amPM.textContent = self.l10n.amPM[int(hours >= 12)];
                if (self.secondElement !== undefined)
                    self.secondElement.value = pad(seconds);
            }
            /**
             * Handles the year input and incrementing events
             * @param {Event} event the keyup or increment event
             */
            function onYearInput(event) {
                var year = parseInt(event.target.value) + (event.delta || 0);
                if (year / 1000 > 1 ||
                    (event.key === "Enter" && !/[^\d]/.test(year.toString()))) {
                    changeYear(year);
                }
            }
            /**
             * Essentially addEventListener + tracking
             * @param {Element} element the element to addEventListener to
             * @param {String} event the event name
             * @param {Function} handler the event handler
             */
            function bind(element, event, handler, options) {
                if (event instanceof Array)
                    return event.forEach(function (ev) { return bind(element, ev, handler, options); });
                if (element instanceof Array)
                    return element.forEach(function (el) { return bind(el, event, handler, options); });
                element.addEventListener(event, handler, options);
                self._handlers.push({
                    element: element,
                    event: event,
                    handler: handler,
                    options: options
                });
            }
            /**
             * A mousedown handler which mimics click.
             * Minimizes latency, since we don't need to wait for mouseup in most cases.
             * Also, avoids handling right clicks.
             *
             * @param {Function} handler the event handler
             */
            function onClick(handler) {
                return function (evt) {
                    evt.which === 1 && handler(evt);
                };
            }
            function triggerChange() {
                triggerEvent("onChange");
            }
            /**
             * Adds all the necessary event listeners
             */
            function bindEvents() {
                if (self.config.wrap) {
                    ["open", "close", "toggle", "clear"].forEach(function (evt) {
                        Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), function (el) {
                            return bind(el, "click", self[evt]);
                        });
                    });
                }
                if (self.isMobile) {
                    setupMobile();
                    return;
                }
                var debouncedResize = debounce(onResize, 50);
                self._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);
                if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
                    bind(self.daysContainer, "mouseover", function (e) {
                        if (self.config.mode === "range")
                            onMouseOver(e.target);
                    });
                bind(window.document.body, "keydown", onKeyDown);
                if (!self.config.inline && !self.config.static)
                    bind(window, "resize", debouncedResize);
                if (window.ontouchstart !== undefined)
                    bind(window.document, "touchstart", documentClick);
                else
                    bind(window.document, "mousedown", onClick(documentClick));
                bind(window.document, "focus", documentClick, { capture: true });
                if (self.config.clickOpens === true) {
                    bind(self._input, "focus", self.open);
                    bind(self._input, "mousedown", onClick(self.open));
                }
                if (self.daysContainer !== undefined) {
                    bind(self.monthNav, "mousedown", onClick(onMonthNavClick));
                    bind(self.monthNav, ["keyup", "increment"], onYearInput);
                    bind(self.daysContainer, "mousedown", onClick(selectDate));
                }
                if (self.timeContainer !== undefined &&
                    self.minuteElement !== undefined &&
                    self.hourElement !== undefined) {
                    var selText = function (e) {
                        return e.target.select();
                    };
                    bind(self.timeContainer, ["increment"], updateTime);
                    bind(self.timeContainer, "blur", updateTime, { capture: true });
                    bind(self.timeContainer, "mousedown", onClick(timeIncrement));
                    bind([self.hourElement, self.minuteElement], ["focus", "click"], selText);
                    if (self.secondElement !== undefined)
                        bind(self.secondElement, "focus", function () { return self.secondElement && self.secondElement.select(); });
                    if (self.amPM !== undefined) {
                        bind(self.amPM, "mousedown", onClick(function (e) {
                            updateTime(e);
                            triggerChange();
                        }));
                    }
                }
            }
            /**
             * Set the calendar view to a particular date.
             * @param {Date} jumpDate the date to set the view to
             * @param {boolean} triggerChange if change events should be triggered
             */
            function jumpToDate(jumpDate, triggerChange) {
                var jumpTo = jumpDate !== undefined
                    ? self.parseDate(jumpDate)
                    : self.latestSelectedDateObj ||
                        (self.config.minDate && self.config.minDate > self.now
                            ? self.config.minDate
                            : self.config.maxDate && self.config.maxDate < self.now
                                ? self.config.maxDate
                                : self.now);
                var oldYear = self.currentYear;
                var oldMonth = self.currentMonth;
                try {
                    if (jumpTo !== undefined) {
                        self.currentYear = jumpTo.getFullYear();
                        self.currentMonth = jumpTo.getMonth();
                    }
                }
                catch (e) {
                    /* istanbul ignore next */
                    e.message = "Invalid date supplied: " + jumpTo;
                    self.config.errorHandler(e);
                }
                if (triggerChange && self.currentYear !== oldYear) {
                    triggerEvent("onYearChange");
                    buildMonthSwitch();
                }
                if (triggerChange &&
                    (self.currentYear !== oldYear || self.currentMonth !== oldMonth)) {
                    triggerEvent("onMonthChange");
                }
                self.redraw();
            }
            /**
             * The up/down arrow handler for time inputs
             * @param {Event} e the click event
             */
            function timeIncrement(e) {
                if (~e.target.className.indexOf("arrow"))
                    incrementNumInput(e, e.target.classList.contains("arrowUp") ? 1 : -1);
            }
            /**
             * Increments/decrements the value of input associ-
             * ated with the up/down arrow by dispatching an
             * "increment" event on the input.
             *
             * @param {Event} e the click event
             * @param {Number} delta the diff (usually 1 or -1)
             * @param {Element} inputElem the input element
             */
            function incrementNumInput(e, delta, inputElem) {
                var target = e && e.target;
                var input = inputElem ||
                    (target && target.parentNode && target.parentNode.firstChild);
                var event = createEvent("increment");
                event.delta = delta;
                input && input.dispatchEvent(event);
            }
            function build() {
                var fragment = window.document.createDocumentFragment();
                self.calendarContainer = createElement("div", "flatpickr-calendar");
                self.calendarContainer.tabIndex = -1;
                if (!self.config.noCalendar) {
                    fragment.appendChild(buildMonthNav());
                    self.innerContainer = createElement("div", "flatpickr-innerContainer");
                    if (self.config.weekNumbers) {
                        var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
                        self.innerContainer.appendChild(weekWrapper);
                        self.weekNumbers = weekNumbers;
                        self.weekWrapper = weekWrapper;
                    }
                    self.rContainer = createElement("div", "flatpickr-rContainer");
                    self.rContainer.appendChild(buildWeekdays());
                    if (!self.daysContainer) {
                        self.daysContainer = createElement("div", "flatpickr-days");
                        self.daysContainer.tabIndex = -1;
                    }
                    buildDays();
                    self.rContainer.appendChild(self.daysContainer);
                    self.innerContainer.appendChild(self.rContainer);
                    fragment.appendChild(self.innerContainer);
                }
                if (self.config.enableTime) {
                    fragment.appendChild(buildTime());
                }
                toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
                toggleClass(self.calendarContainer, "animate", self.config.animate === true);
                toggleClass(self.calendarContainer, "multiMonth", self.config.showMonths > 1);
                self.calendarContainer.appendChild(fragment);
                var customAppend = self.config.appendTo !== undefined &&
                    self.config.appendTo.nodeType !== undefined;
                if (self.config.inline || self.config.static) {
                    self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");
                    if (self.config.inline) {
                        if (!customAppend && self.element.parentNode)
                            self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);
                        else if (self.config.appendTo !== undefined)
                            self.config.appendTo.appendChild(self.calendarContainer);
                    }
                    if (self.config.static) {
                        var wrapper = createElement("div", "flatpickr-wrapper");
                        if (self.element.parentNode)
                            self.element.parentNode.insertBefore(wrapper, self.element);
                        wrapper.appendChild(self.element);
                        if (self.altInput)
                            wrapper.appendChild(self.altInput);
                        wrapper.appendChild(self.calendarContainer);
                    }
                }
                if (!self.config.static && !self.config.inline)
                    (self.config.appendTo !== undefined
                        ? self.config.appendTo
                        : window.document.body).appendChild(self.calendarContainer);
            }
            function createDay(className, date, dayNumber, i) {
                var dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", "flatpickr-day " + className, date.getDate().toString());
                dayElement.dateObj = date;
                dayElement.$i = i;
                dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));
                if (className.indexOf("hidden") === -1 &&
                    compareDates(date, self.now) === 0) {
                    self.todayDateElem = dayElement;
                    dayElement.classList.add("today");
                    dayElement.setAttribute("aria-current", "date");
                }
                if (dateIsEnabled) {
                    dayElement.tabIndex = -1;
                    if (isDateSelected(date)) {
                        dayElement.classList.add("selected");
                        self.selectedDateElem = dayElement;
                        if (self.config.mode === "range") {
                            toggleClass(dayElement, "startRange", self.selectedDates[0] &&
                                compareDates(date, self.selectedDates[0], true) === 0);
                            toggleClass(dayElement, "endRange", self.selectedDates[1] &&
                                compareDates(date, self.selectedDates[1], true) === 0);
                            if (className === "nextMonthDay")
                                dayElement.classList.add("inRange");
                        }
                    }
                }
                else {
                    dayElement.classList.add("flatpickr-disabled");
                }
                if (self.config.mode === "range") {
                    if (isDateInRange(date) && !isDateSelected(date))
                        dayElement.classList.add("inRange");
                }
                if (self.weekNumbers &&
                    self.config.showMonths === 1 &&
                    className !== "prevMonthDay" &&
                    dayNumber % 7 === 1) {
                    self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>");
                }
                triggerEvent("onDayCreate", dayElement);
                return dayElement;
            }
            function focusOnDayElem(targetNode) {
                targetNode.focus();
                if (self.config.mode === "range")
                    onMouseOver(targetNode);
            }
            function getFirstAvailableDay(delta) {
                var startMonth = delta > 0 ? 0 : self.config.showMonths - 1;
                var endMonth = delta > 0 ? self.config.showMonths : -1;
                for (var m = startMonth; m != endMonth; m += delta) {
                    var month = self.daysContainer.children[m];
                    var startIndex = delta > 0 ? 0 : month.children.length - 1;
                    var endIndex = delta > 0 ? month.children.length : -1;
                    for (var i = startIndex; i != endIndex; i += delta) {
                        var c = month.children[i];
                        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj))
                            return c;
                    }
                }
                return undefined;
            }
            function getNextAvailableDay(current, delta) {
                var givenMonth = current.className.indexOf("Month") === -1
                    ? current.dateObj.getMonth()
                    : self.currentMonth;
                var endMonth = delta > 0 ? self.config.showMonths : -1;
                var loopDelta = delta > 0 ? 1 : -1;
                for (var m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta) {
                    var month = self.daysContainer.children[m];
                    var startIndex = givenMonth - self.currentMonth === m
                        ? current.$i + delta
                        : delta < 0
                            ? month.children.length - 1
                            : 0;
                    var numMonthDays = month.children.length;
                    for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
                        var c = month.children[i];
                        if (c.className.indexOf("hidden") === -1 &&
                            isEnabled(c.dateObj) &&
                            Math.abs(current.$i - i) >= Math.abs(delta))
                            return focusOnDayElem(c);
                    }
                }
                self.changeMonth(loopDelta);
                focusOnDay(getFirstAvailableDay(loopDelta), 0);
                return undefined;
            }
            function focusOnDay(current, offset) {
                var dayFocused = isInView(document.activeElement || document.body);
                var startElem = current !== undefined
                    ? current
                    : dayFocused
                        ? document.activeElement
                        : self.selectedDateElem !== undefined && isInView(self.selectedDateElem)
                            ? self.selectedDateElem
                            : self.todayDateElem !== undefined && isInView(self.todayDateElem)
                                ? self.todayDateElem
                                : getFirstAvailableDay(offset > 0 ? 1 : -1);
                if (startElem === undefined)
                    return self._input.focus();
                if (!dayFocused)
                    return focusOnDayElem(startElem);
                getNextAvailableDay(startElem, offset);
            }
            function buildMonthDays(year, month) {
                var firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;
                var prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12);
                var daysInMonth = self.utils.getDaysInMonth(month), days = window.document.createDocumentFragment(), isMultiMonth = self.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
                var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
                // prepend days from the ending of previous month
                for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
                    days.appendChild(createDay(prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
                }
                // Start at 1 since there is no 0th day
                for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
                    days.appendChild(createDay("", new Date(year, month, dayNumber), dayNumber, dayIndex));
                }
                // append days from the next month
                for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth &&
                    (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
                    days.appendChild(createDay(nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
                }
                //updateNavigationCurrentMonth();
                var dayContainer = createElement("div", "dayContainer");
                dayContainer.appendChild(days);
                return dayContainer;
            }
            function buildDays() {
                if (self.daysContainer === undefined) {
                    return;
                }
                clearNode(self.daysContainer);
                // TODO: week numbers for each month
                if (self.weekNumbers)
                    clearNode(self.weekNumbers);
                var frag = document.createDocumentFragment();
                for (var i = 0; i < self.config.showMonths; i++) {
                    var d = new Date(self.currentYear, self.currentMonth, 1);
                    d.setMonth(self.currentMonth + i);
                    frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
                }
                self.daysContainer.appendChild(frag);
                self.days = self.daysContainer.firstChild;
                if (self.config.mode === "range" && self.selectedDates.length === 1) {
                    onMouseOver();
                }
            }
            function buildMonthSwitch() {
                if (self.config.showMonths > 1 ||
                    self.config.monthSelectorType !== "dropdown")
                    return;
                var shouldBuildMonth = function (month) {
                    if (self.config.minDate !== undefined &&
                        self.currentYear === self.config.minDate.getFullYear() &&
                        month < self.config.minDate.getMonth()) {
                        return false;
                    }
                    return !(self.config.maxDate !== undefined &&
                        self.currentYear === self.config.maxDate.getFullYear() &&
                        month > self.config.maxDate.getMonth());
                };
                self.monthsDropdownContainer.tabIndex = -1;
                self.monthsDropdownContainer.innerHTML = "";
                for (var i = 0; i < 12; i++) {
                    if (!shouldBuildMonth(i))
                        continue;
                    var month = createElement("option", "flatpickr-monthDropdown-month");
                    month.value = new Date(self.currentYear, i).getMonth().toString();
                    month.textContent = monthToStr(i, self.config.shorthandCurrentMonth, self.l10n);
                    month.tabIndex = -1;
                    if (self.currentMonth === i) {
                        month.selected = true;
                    }
                    self.monthsDropdownContainer.appendChild(month);
                }
            }
            function buildMonth() {
                var container = createElement("div", "flatpickr-month");
                var monthNavFragment = window.document.createDocumentFragment();
                var monthElement;
                if (self.config.showMonths > 1 ||
                    self.config.monthSelectorType === "static") {
                    monthElement = createElement("span", "cur-month");
                }
                else {
                    self.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
                    bind(self.monthsDropdownContainer, "change", function (e) {
                        var target = e.target;
                        var selectedMonth = parseInt(target.value, 10);
                        self.changeMonth(selectedMonth - self.currentMonth);
                        triggerEvent("onMonthChange");
                    });
                    buildMonthSwitch();
                    monthElement = self.monthsDropdownContainer;
                }
                var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
                var yearElement = yearInput.getElementsByTagName("input")[0];
                yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);
                if (self.config.minDate) {
                    yearElement.setAttribute("min", self.config.minDate.getFullYear().toString());
                }
                if (self.config.maxDate) {
                    yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString());
                    yearElement.disabled =
                        !!self.config.minDate &&
                            self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
                }
                var currentMonth = createElement("div", "flatpickr-current-month");
                currentMonth.appendChild(monthElement);
                currentMonth.appendChild(yearInput);
                monthNavFragment.appendChild(currentMonth);
                container.appendChild(monthNavFragment);
                return {
                    container: container,
                    yearElement: yearElement,
                    monthElement: monthElement
                };
            }
            function buildMonths() {
                clearNode(self.monthNav);
                self.monthNav.appendChild(self.prevMonthNav);
                if (self.config.showMonths) {
                    self.yearElements = [];
                    self.monthElements = [];
                }
                for (var m = self.config.showMonths; m--;) {
                    var month = buildMonth();
                    self.yearElements.push(month.yearElement);
                    self.monthElements.push(month.monthElement);
                    self.monthNav.appendChild(month.container);
                }
                self.monthNav.appendChild(self.nextMonthNav);
            }
            function buildMonthNav() {
                self.monthNav = createElement("div", "flatpickr-months");
                self.yearElements = [];
                self.monthElements = [];
                self.prevMonthNav = createElement("span", "flatpickr-prev-month");
                self.prevMonthNav.innerHTML = self.config.prevArrow;
                self.nextMonthNav = createElement("span", "flatpickr-next-month");
                self.nextMonthNav.innerHTML = self.config.nextArrow;
                buildMonths();
                Object.defineProperty(self, "_hidePrevMonthArrow", {
                    get: function () { return self.__hidePrevMonthArrow; },
                    set: function (bool) {
                        if (self.__hidePrevMonthArrow !== bool) {
                            toggleClass(self.prevMonthNav, "flatpickr-disabled", bool);
                            self.__hidePrevMonthArrow = bool;
                        }
                    }
                });
                Object.defineProperty(self, "_hideNextMonthArrow", {
                    get: function () { return self.__hideNextMonthArrow; },
                    set: function (bool) {
                        if (self.__hideNextMonthArrow !== bool) {
                            toggleClass(self.nextMonthNav, "flatpickr-disabled", bool);
                            self.__hideNextMonthArrow = bool;
                        }
                    }
                });
                self.currentYearElement = self.yearElements[0];
                updateNavigationCurrentMonth();
                return self.monthNav;
            }
            function buildTime() {
                self.calendarContainer.classList.add("hasTime");
                if (self.config.noCalendar)
                    self.calendarContainer.classList.add("noCalendar");
                self.timeContainer = createElement("div", "flatpickr-time");
                self.timeContainer.tabIndex = -1;
                var separator = createElement("span", "flatpickr-time-separator", ":");
                var hourInput = createNumberInput("flatpickr-hour", {
                    "aria-label": self.l10n.hourAriaLabel
                });
                self.hourElement = hourInput.getElementsByTagName("input")[0];
                var minuteInput = createNumberInput("flatpickr-minute", {
                    "aria-label": self.l10n.minuteAriaLabel
                });
                self.minuteElement = minuteInput.getElementsByTagName("input")[0];
                self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;
                self.hourElement.value = pad(self.latestSelectedDateObj
                    ? self.latestSelectedDateObj.getHours()
                    : self.config.time_24hr
                        ? self.config.defaultHour
                        : military2ampm(self.config.defaultHour));
                self.minuteElement.value = pad(self.latestSelectedDateObj
                    ? self.latestSelectedDateObj.getMinutes()
                    : self.config.defaultMinute);
                self.hourElement.setAttribute("step", self.config.hourIncrement.toString());
                self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString());
                self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1");
                self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12");
                self.minuteElement.setAttribute("min", "0");
                self.minuteElement.setAttribute("max", "59");
                self.timeContainer.appendChild(hourInput);
                self.timeContainer.appendChild(separator);
                self.timeContainer.appendChild(minuteInput);
                if (self.config.time_24hr)
                    self.timeContainer.classList.add("time24hr");
                if (self.config.enableSeconds) {
                    self.timeContainer.classList.add("hasSeconds");
                    var secondInput = createNumberInput("flatpickr-second");
                    self.secondElement = secondInput.getElementsByTagName("input")[0];
                    self.secondElement.value = pad(self.latestSelectedDateObj
                        ? self.latestSelectedDateObj.getSeconds()
                        : self.config.defaultSeconds);
                    self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step"));
                    self.secondElement.setAttribute("min", "0");
                    self.secondElement.setAttribute("max", "59");
                    self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
                    self.timeContainer.appendChild(secondInput);
                }
                if (!self.config.time_24hr) {
                    // add self.amPM if appropriate
                    self.amPM = createElement("span", "flatpickr-am-pm", self.l10n.amPM[int((self.latestSelectedDateObj
                        ? self.hourElement.value
                        : self.config.defaultHour) > 11)]);
                    self.amPM.title = self.l10n.toggleTitle;
                    self.amPM.tabIndex = -1;
                    self.timeContainer.appendChild(self.amPM);
                }
                return self.timeContainer;
            }
            function buildWeekdays() {
                if (!self.weekdayContainer)
                    self.weekdayContainer = createElement("div", "flatpickr-weekdays");
                else
                    clearNode(self.weekdayContainer);
                for (var i = self.config.showMonths; i--;) {
                    var container = createElement("div", "flatpickr-weekdaycontainer");
                    self.weekdayContainer.appendChild(container);
                }
                updateWeekdays();
                return self.weekdayContainer;
            }
            function updateWeekdays() {
                var firstDayOfWeek = self.l10n.firstDayOfWeek;
                var weekdays = self.l10n.weekdays.shorthand.slice();
                if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
                    weekdays = weekdays.splice(firstDayOfWeek, weekdays.length).concat(weekdays.splice(0, firstDayOfWeek));
                }
                for (var i = self.config.showMonths; i--;) {
                    self.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
                }
            }
            /* istanbul ignore next */
            function buildWeeks() {
                self.calendarContainer.classList.add("hasWeeks");
                var weekWrapper = createElement("div", "flatpickr-weekwrapper");
                weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
                var weekNumbers = createElement("div", "flatpickr-weeks");
                weekWrapper.appendChild(weekNumbers);
                return {
                    weekWrapper: weekWrapper,
                    weekNumbers: weekNumbers
                };
            }
            function changeMonth(value, isOffset) {
                if (isOffset === void 0) { isOffset = true; }
                var delta = isOffset ? value : value - self.currentMonth;
                if ((delta < 0 && self._hidePrevMonthArrow === true) ||
                    (delta > 0 && self._hideNextMonthArrow === true))
                    return;
                self.currentMonth += delta;
                if (self.currentMonth < 0 || self.currentMonth > 11) {
                    self.currentYear += self.currentMonth > 11 ? 1 : -1;
                    self.currentMonth = (self.currentMonth + 12) % 12;
                    triggerEvent("onYearChange");
                    buildMonthSwitch();
                }
                buildDays();
                triggerEvent("onMonthChange");
                updateNavigationCurrentMonth();
            }
            function clear(triggerChangeEvent, toInitial) {
                if (triggerChangeEvent === void 0) { triggerChangeEvent = true; }
                if (toInitial === void 0) { toInitial = true; }
                self.input.value = "";
                if (self.altInput !== undefined)
                    self.altInput.value = "";
                if (self.mobileInput !== undefined)
                    self.mobileInput.value = "";
                self.selectedDates = [];
                self.latestSelectedDateObj = undefined;
                if (toInitial === true) {
                    self.currentYear = self._initialDate.getFullYear();
                    self.currentMonth = self._initialDate.getMonth();
                }
                self.showTimeInput = false;
                if (self.config.enableTime === true) {
                    setDefaultHours();
                }
                self.redraw();
                if (triggerChangeEvent)
                    // triggerChangeEvent is true (default) or an Event
                    triggerEvent("onChange");
            }
            function close() {
                self.isOpen = false;
                if (!self.isMobile) {
                    if (self.calendarContainer !== undefined) {
                        self.calendarContainer.classList.remove("open");
                    }
                    if (self._input !== undefined) {
                        self._input.classList.remove("active");
                    }
                }
                triggerEvent("onClose");
            }
            function destroy() {
                if (self.config !== undefined)
                    triggerEvent("onDestroy");
                for (var i = self._handlers.length; i--;) {
                    var h = self._handlers[i];
                    h.element.removeEventListener(h.event, h.handler, h.options);
                }
                self._handlers = [];
                if (self.mobileInput) {
                    if (self.mobileInput.parentNode)
                        self.mobileInput.parentNode.removeChild(self.mobileInput);
                    self.mobileInput = undefined;
                }
                else if (self.calendarContainer && self.calendarContainer.parentNode) {
                    if (self.config.static && self.calendarContainer.parentNode) {
                        var wrapper = self.calendarContainer.parentNode;
                        wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
                        if (wrapper.parentNode) {
                            while (wrapper.firstChild)
                                wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
                            wrapper.parentNode.removeChild(wrapper);
                        }
                    }
                    else
                        self.calendarContainer.parentNode.removeChild(self.calendarContainer);
                }
                if (self.altInput) {
                    self.input.type = "text";
                    if (self.altInput.parentNode)
                        self.altInput.parentNode.removeChild(self.altInput);
                    delete self.altInput;
                }
                if (self.input) {
                    self.input.type = self.input._type;
                    self.input.classList.remove("flatpickr-input");
                    self.input.removeAttribute("readonly");
                    self.input.value = "";
                }
                [
                    "_showTimeInput",
                    "latestSelectedDateObj",
                    "_hideNextMonthArrow",
                    "_hidePrevMonthArrow",
                    "__hideNextMonthArrow",
                    "__hidePrevMonthArrow",
                    "isMobile",
                    "isOpen",
                    "selectedDateElem",
                    "minDateHasTime",
                    "maxDateHasTime",
                    "days",
                    "daysContainer",
                    "_input",
                    "_positionElement",
                    "innerContainer",
                    "rContainer",
                    "monthNav",
                    "todayDateElem",
                    "calendarContainer",
                    "weekdayContainer",
                    "prevMonthNav",
                    "nextMonthNav",
                    "monthsDropdownContainer",
                    "currentMonthElement",
                    "currentYearElement",
                    "navigationCurrentMonth",
                    "selectedDateElem",
                    "config",
                ].forEach(function (k) {
                    try {
                        delete self[k];
                    }
                    catch (_) { }
                });
            }
            function isCalendarElem(elem) {
                if (self.config.appendTo && self.config.appendTo.contains(elem))
                    return true;
                return self.calendarContainer.contains(elem);
            }
            function documentClick(e) {
                if (self.isOpen && !self.config.inline) {
                    var eventTarget_1 = getEventTarget(e);
                    var isCalendarElement = isCalendarElem(eventTarget_1);
                    var isInput = eventTarget_1 === self.input ||
                        eventTarget_1 === self.altInput ||
                        self.element.contains(eventTarget_1) ||
                        // web components
                        // e.path is not present in all browsers. circumventing typechecks
                        (e.path &&
                            e.path.indexOf &&
                            (~e.path.indexOf(self.input) ||
                                ~e.path.indexOf(self.altInput)));
                    var lostFocus = e.type === "blur"
                        ? isInput &&
                            e.relatedTarget &&
                            !isCalendarElem(e.relatedTarget)
                        : !isInput &&
                            !isCalendarElement &&
                            !isCalendarElem(e.relatedTarget);
                    var isIgnored = !self.config.ignoredFocusElements.some(function (elem) {
                        return elem.contains(eventTarget_1);
                    });
                    if (lostFocus && isIgnored) {
                        self.close();
                        if (self.config.mode === "range" && self.selectedDates.length === 1) {
                            self.clear(false);
                            self.redraw();
                        }
                    }
                }
            }
            function changeYear(newYear) {
                if (!newYear ||
                    (self.config.minDate && newYear < self.config.minDate.getFullYear()) ||
                    (self.config.maxDate && newYear > self.config.maxDate.getFullYear()))
                    return;
                var newYearNum = newYear, isNewYear = self.currentYear !== newYearNum;
                self.currentYear = newYearNum || self.currentYear;
                if (self.config.maxDate &&
                    self.currentYear === self.config.maxDate.getFullYear()) {
                    self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
                }
                else if (self.config.minDate &&
                    self.currentYear === self.config.minDate.getFullYear()) {
                    self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
                }
                if (isNewYear) {
                    self.redraw();
                    triggerEvent("onYearChange");
                    buildMonthSwitch();
                }
            }
            function isEnabled(date, timeless) {
                if (timeless === void 0) { timeless = true; }
                var dateToCheck = self.parseDate(date, undefined, timeless); // timeless
                if ((self.config.minDate &&
                    dateToCheck &&
                    compareDates(dateToCheck, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0) ||
                    (self.config.maxDate &&
                        dateToCheck &&
                        compareDates(dateToCheck, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0))
                    return false;
                if (self.config.enable.length === 0 && self.config.disable.length === 0)
                    return true;
                if (dateToCheck === undefined)
                    return false;
                var bool = self.config.enable.length > 0, array = bool ? self.config.enable : self.config.disable;
                for (var i = 0, d = void 0; i < array.length; i++) {
                    d = array[i];
                    if (typeof d === "function" &&
                        d(dateToCheck) // disabled by function
                    )
                        return bool;
                    else if (d instanceof Date &&
                        dateToCheck !== undefined &&
                        d.getTime() === dateToCheck.getTime())
                        // disabled by date
                        return bool;
                    else if (typeof d === "string" && dateToCheck !== undefined) {
                        // disabled by date string
                        var parsed = self.parseDate(d, undefined, true);
                        return parsed && parsed.getTime() === dateToCheck.getTime()
                            ? bool
                            : !bool;
                    }
                    else if (
                    // disabled by range
                    typeof d === "object" &&
                        dateToCheck !== undefined &&
                        d.from &&
                        d.to &&
                        dateToCheck.getTime() >= d.from.getTime() &&
                        dateToCheck.getTime() <= d.to.getTime())
                        return bool;
                }
                return !bool;
            }
            function isInView(elem) {
                if (self.daysContainer !== undefined)
                    return (elem.className.indexOf("hidden") === -1 &&
                        self.daysContainer.contains(elem));
                return false;
            }
            function onKeyDown(e) {
                // e.key                      e.keyCode
                // "Backspace"                        8
                // "Tab"                              9
                // "Enter"                           13
                // "Escape"     (IE "Esc")           27
                // "ArrowLeft"  (IE "Left")          37
                // "ArrowUp"    (IE "Up")            38
                // "ArrowRight" (IE "Right")         39
                // "ArrowDown"  (IE "Down")          40
                // "Delete"     (IE "Del")           46
                var isInput = e.target === self._input;
                var allowInput = self.config.allowInput;
                var allowKeydown = self.isOpen && (!allowInput || !isInput);
                var allowInlineKeydown = self.config.inline && isInput && !allowInput;
                if (e.keyCode === 13 && isInput) {
                    if (allowInput) {
                        self.setDate(self._input.value, true, e.target === self.altInput
                            ? self.config.altFormat
                            : self.config.dateFormat);
                        return e.target.blur();
                    }
                    else {
                        self.open();
                    }
                }
                else if (isCalendarElem(e.target) ||
                    allowKeydown ||
                    allowInlineKeydown) {
                    var isTimeObj = !!self.timeContainer &&
                        self.timeContainer.contains(e.target);
                    switch (e.keyCode) {
                        case 13:
                            if (isTimeObj) {
                                e.preventDefault();
                                updateTime();
                                focusAndClose();
                            }
                            else
                                selectDate(e);
                            break;
                        case 27: // escape
                            e.preventDefault();
                            focusAndClose();
                            break;
                        case 8:
                        case 46:
                            if (isInput && !self.config.allowInput) {
                                e.preventDefault();
                                self.clear();
                            }
                            break;
                        case 37:
                        case 39:
                            if (!isTimeObj && !isInput) {
                                e.preventDefault();
                                if (self.daysContainer !== undefined &&
                                    (allowInput === false ||
                                        (document.activeElement && isInView(document.activeElement)))) {
                                    var delta_1 = e.keyCode === 39 ? 1 : -1;
                                    if (!e.ctrlKey)
                                        focusOnDay(undefined, delta_1);
                                    else {
                                        e.stopPropagation();
                                        changeMonth(delta_1);
                                        focusOnDay(getFirstAvailableDay(1), 0);
                                    }
                                }
                            }
                            else if (self.hourElement)
                                self.hourElement.focus();
                            break;
                        case 38:
                        case 40:
                            e.preventDefault();
                            var delta = e.keyCode === 40 ? 1 : -1;
                            if ((self.daysContainer && e.target.$i !== undefined) ||
                                e.target === self.input) {
                                if (e.ctrlKey) {
                                    e.stopPropagation();
                                    changeYear(self.currentYear - delta);
                                    focusOnDay(getFirstAvailableDay(1), 0);
                                }
                                else if (!isTimeObj)
                                    focusOnDay(undefined, delta * 7);
                            }
                            else if (e.target === self.currentYearElement) {
                                changeYear(self.currentYear - delta);
                            }
                            else if (self.config.enableTime) {
                                if (!isTimeObj && self.hourElement)
                                    self.hourElement.focus();
                                updateTime(e);
                                self._debouncedChange();
                            }
                            break;
                        case 9:
                            if (isTimeObj) {
                                var elems = [
                                    self.hourElement,
                                    self.minuteElement,
                                    self.secondElement,
                                    self.amPM,
                                ]
                                    .concat(self.pluginElements)
                                    .filter(function (x) { return x; });
                                var i = elems.indexOf(e.target);
                                if (i !== -1) {
                                    var target = elems[i + (e.shiftKey ? -1 : 1)];
                                    e.preventDefault();
                                    (target || self._input).focus();
                                }
                            }
                            else if (!self.config.noCalendar &&
                                self.daysContainer &&
                                self.daysContainer.contains(e.target) &&
                                e.shiftKey) {
                                e.preventDefault();
                                self._input.focus();
                            }
                            break;
                        default:
                            break;
                    }
                }
                if (self.amPM !== undefined && e.target === self.amPM) {
                    switch (e.key) {
                        case self.l10n.amPM[0].charAt(0):
                        case self.l10n.amPM[0].charAt(0).toLowerCase():
                            self.amPM.textContent = self.l10n.amPM[0];
                            setHoursFromInputs();
                            updateValue();
                            break;
                        case self.l10n.amPM[1].charAt(0):
                        case self.l10n.amPM[1].charAt(0).toLowerCase():
                            self.amPM.textContent = self.l10n.amPM[1];
                            setHoursFromInputs();
                            updateValue();
                            break;
                    }
                }
                if (isInput || isCalendarElem(e.target)) {
                    triggerEvent("onKeyDown", e);
                }
            }
            function onMouseOver(elem) {
                if (self.selectedDates.length !== 1 ||
                    (elem &&
                        (!elem.classList.contains("flatpickr-day") ||
                            elem.classList.contains("flatpickr-disabled"))))
                    return;
                var hoverDate = elem
                    ? elem.dateObj.getTime()
                    : self.days.firstElementChild.dateObj.getTime(), initialDate = self.parseDate(self.selectedDates[0], undefined, true).getTime(), rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime());
                var containsDisabled = false;
                var minRange = 0, maxRange = 0;
                for (var t = rangeStartDate; t < rangeEndDate; t += duration.DAY) {
                    if (!isEnabled(new Date(t), true)) {
                        containsDisabled =
                            containsDisabled || (t > rangeStartDate && t < rangeEndDate);
                        if (t < initialDate && (!minRange || t > minRange))
                            minRange = t;
                        else if (t > initialDate && (!maxRange || t < maxRange))
                            maxRange = t;
                    }
                }
                for (var m = 0; m < self.config.showMonths; m++) {
                    var month = self.daysContainer.children[m];
                    var _loop_1 = function (i, l) {
                        var dayElem = month.children[i], date = dayElem.dateObj;
                        var timestamp = date.getTime();
                        var outOfRange = (minRange > 0 && timestamp < minRange) ||
                            (maxRange > 0 && timestamp > maxRange);
                        if (outOfRange) {
                            dayElem.classList.add("notAllowed");
                            ["inRange", "startRange", "endRange"].forEach(function (c) {
                                dayElem.classList.remove(c);
                            });
                            return "continue";
                        }
                        else if (containsDisabled && !outOfRange)
                            return "continue";
                        ["startRange", "inRange", "endRange", "notAllowed"].forEach(function (c) {
                            dayElem.classList.remove(c);
                        });
                        if (elem !== undefined) {
                            elem.classList.add(hoverDate <= self.selectedDates[0].getTime()
                                ? "startRange"
                                : "endRange");
                            if (initialDate < hoverDate && timestamp === initialDate)
                                dayElem.classList.add("startRange");
                            else if (initialDate > hoverDate && timestamp === initialDate)
                                dayElem.classList.add("endRange");
                            if (timestamp >= minRange &&
                                (maxRange === 0 || timestamp <= maxRange) &&
                                isBetween(timestamp, initialDate, hoverDate))
                                dayElem.classList.add("inRange");
                        }
                    };
                    for (var i = 0, l = month.children.length; i < l; i++) {
                        _loop_1(i, l);
                    }
                }
            }
            function onResize() {
                if (self.isOpen && !self.config.static && !self.config.inline)
                    positionCalendar();
            }
            function setDefaultTime() {
                self.setDate(self.config.minDate !== undefined
                    ? new Date(self.config.minDate.getTime())
                    : new Date(), true);
                setDefaultHours();
                updateValue();
            }
            function open(e, positionElement) {
                if (positionElement === void 0) { positionElement = self._positionElement; }
                if (self.isMobile === true) {
                    if (e) {
                        e.preventDefault();
                        e.target && e.target.blur();
                    }
                    if (self.mobileInput !== undefined) {
                        self.mobileInput.focus();
                        self.mobileInput.click();
                    }
                    triggerEvent("onOpen");
                    return;
                }
                if (self._input.disabled || self.config.inline)
                    return;
                var wasOpen = self.isOpen;
                self.isOpen = true;
                if (!wasOpen) {
                    self.calendarContainer.classList.add("open");
                    self._input.classList.add("active");
                    triggerEvent("onOpen");
                    positionCalendar(positionElement);
                }
                if (self.config.enableTime === true && self.config.noCalendar === true) {
                    if (self.selectedDates.length === 0) {
                        setDefaultTime();
                    }
                    if (self.config.allowInput === false &&
                        (e === undefined ||
                            !self.timeContainer.contains(e.relatedTarget))) {
                        setTimeout(function () { return self.hourElement.select(); }, 50);
                    }
                }
            }
            function minMaxDateSetter(type) {
                return function (date) {
                    var dateObj = (self.config["_" + type + "Date"] = self.parseDate(date, self.config.dateFormat));
                    var inverseDateObj = self.config["_" + (type === "min" ? "max" : "min") + "Date"];
                    if (dateObj !== undefined) {
                        self[type === "min" ? "minDateHasTime" : "maxDateHasTime"] =
                            dateObj.getHours() > 0 ||
                                dateObj.getMinutes() > 0 ||
                                dateObj.getSeconds() > 0;
                    }
                    if (self.selectedDates) {
                        self.selectedDates = self.selectedDates.filter(function (d) { return isEnabled(d); });
                        if (!self.selectedDates.length && type === "min")
                            setHoursFromDate(dateObj);
                        updateValue();
                    }
                    if (self.daysContainer) {
                        redraw();
                        if (dateObj !== undefined)
                            self.currentYearElement[type] = dateObj.getFullYear().toString();
                        else
                            self.currentYearElement.removeAttribute(type);
                        self.currentYearElement.disabled =
                            !!inverseDateObj &&
                                dateObj !== undefined &&
                                inverseDateObj.getFullYear() === dateObj.getFullYear();
                    }
                };
            }
            function parseConfig() {
                var boolOpts = [
                    "wrap",
                    "weekNumbers",
                    "allowInput",
                    "clickOpens",
                    "time_24hr",
                    "enableTime",
                    "noCalendar",
                    "altInput",
                    "shorthandCurrentMonth",
                    "inline",
                    "static",
                    "enableSeconds",
                    "disableMobile",
                ];
                var userConfig = __assign({}, instanceConfig, JSON.parse(JSON.stringify(element.dataset || {})));
                var formats = {};
                self.config.parseDate = userConfig.parseDate;
                self.config.formatDate = userConfig.formatDate;
                Object.defineProperty(self.config, "enable", {
                    get: function () { return self.config._enable; },
                    set: function (dates) {
                        self.config._enable = parseDateRules(dates);
                    }
                });
                Object.defineProperty(self.config, "disable", {
                    get: function () { return self.config._disable; },
                    set: function (dates) {
                        self.config._disable = parseDateRules(dates);
                    }
                });
                var timeMode = userConfig.mode === "time";
                if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
                    var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
                    formats.dateFormat =
                        userConfig.noCalendar || timeMode
                            ? "H:i" + (userConfig.enableSeconds ? ":S" : "")
                            : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
                }
                if (userConfig.altInput &&
                    (userConfig.enableTime || timeMode) &&
                    !userConfig.altFormat) {
                    var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
                    formats.altFormat =
                        userConfig.noCalendar || timeMode
                            ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K")
                            : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
                }
                if (!userConfig.altInputClass) {
                    self.config.altInputClass =
                        self.input.className + " " + self.config.altInputClass;
                }
                Object.defineProperty(self.config, "minDate", {
                    get: function () { return self.config._minDate; },
                    set: minMaxDateSetter("min")
                });
                Object.defineProperty(self.config, "maxDate", {
                    get: function () { return self.config._maxDate; },
                    set: minMaxDateSetter("max")
                });
                var minMaxTimeSetter = function (type) { return function (val) {
                    self.config[type === "min" ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i");
                }; };
                Object.defineProperty(self.config, "minTime", {
                    get: function () { return self.config._minTime; },
                    set: minMaxTimeSetter("min")
                });
                Object.defineProperty(self.config, "maxTime", {
                    get: function () { return self.config._maxTime; },
                    set: minMaxTimeSetter("max")
                });
                if (userConfig.mode === "time") {
                    self.config.noCalendar = true;
                    self.config.enableTime = true;
                }
                Object.assign(self.config, formats, userConfig);
                for (var i = 0; i < boolOpts.length; i++)
                    self.config[boolOpts[i]] =
                        self.config[boolOpts[i]] === true ||
                            self.config[boolOpts[i]] === "true";
                HOOKS.filter(function (hook) { return self.config[hook] !== undefined; }).forEach(function (hook) {
                    self.config[hook] = arrayify(self.config[hook] || []).map(bindToInstance);
                });
                self.isMobile =
                    !self.config.disableMobile &&
                        !self.config.inline &&
                        self.config.mode === "single" &&
                        !self.config.disable.length &&
                        !self.config.enable.length &&
                        !self.config.weekNumbers &&
                        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                for (var i = 0; i < self.config.plugins.length; i++) {
                    var pluginConf = self.config.plugins[i](self) || {};
                    for (var key in pluginConf) {
                        if (HOOKS.indexOf(key) > -1) {
                            self.config[key] = arrayify(pluginConf[key])
                                .map(bindToInstance)
                                .concat(self.config[key]);
                        }
                        else if (typeof userConfig[key] === "undefined")
                            self.config[key] = pluginConf[key];
                    }
                }
                triggerEvent("onParseConfig");
            }
            function setupLocale() {
                if (typeof self.config.locale !== "object" &&
                    typeof flatpickr.l10ns[self.config.locale] === "undefined")
                    self.config.errorHandler(new Error("flatpickr: invalid locale " + self.config.locale));
                self.l10n = __assign({}, flatpickr.l10ns["default"], (typeof self.config.locale === "object"
                    ? self.config.locale
                    : self.config.locale !== "default"
                        ? flatpickr.l10ns[self.config.locale]
                        : undefined));
                tokenRegex.K = "(" + self.l10n.amPM[0] + "|" + self.l10n.amPM[1] + "|" + self.l10n.amPM[0].toLowerCase() + "|" + self.l10n.amPM[1].toLowerCase() + ")";
                var userConfig = __assign({}, instanceConfig, JSON.parse(JSON.stringify(element.dataset || {})));
                if (userConfig.time_24hr === undefined &&
                    flatpickr.defaultConfig.time_24hr === undefined) {
                    self.config.time_24hr = self.l10n.time_24hr;
                }
                self.formatDate = createDateFormatter(self);
                self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
            }
            function positionCalendar(customPositionElement) {
                if (self.calendarContainer === undefined)
                    return;
                triggerEvent("onPreCalendarPosition");
                var positionElement = customPositionElement || self._positionElement;
                var calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, (function (acc, child) { return acc + child.offsetHeight; }), 0), calendarWidth = self.calendarContainer.offsetWidth, configPos = self.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" ||
                    (configPosVertical !== "below" &&
                        distanceFromBottom < calendarHeight &&
                        inputBounds.top > calendarHeight);
                var top = window.pageYOffset +
                    inputBounds.top +
                    (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
                toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
                toggleClass(self.calendarContainer, "arrowBottom", showOnTop);
                if (self.config.inline)
                    return;
                var left = window.pageXOffset +
                    inputBounds.left -
                    (configPosHorizontal != null && configPosHorizontal === "center"
                        ? (calendarWidth - inputBounds.width) / 2
                        : 0);
                var right = window.document.body.offsetWidth - inputBounds.right;
                var rightMost = left + calendarWidth > window.document.body.offsetWidth;
                var centerMost = right + calendarWidth > window.document.body.offsetWidth;
                toggleClass(self.calendarContainer, "rightMost", rightMost);
                if (self.config.static)
                    return;
                self.calendarContainer.style.top = top + "px";
                if (!rightMost) {
                    self.calendarContainer.style.left = left + "px";
                    self.calendarContainer.style.right = "auto";
                }
                else if (!centerMost) {
                    self.calendarContainer.style.left = "auto";
                    self.calendarContainer.style.right = right + "px";
                }
                else {
                    var doc = document.styleSheets[0];
                    // some testing environments don't have css support
                    if (doc === undefined)
                        return;
                    var bodyWidth = window.document.body.offsetWidth;
                    var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
                    var centerBefore = ".flatpickr-calendar.centerMost:before";
                    var centerAfter = ".flatpickr-calendar.centerMost:after";
                    var centerIndex = doc.cssRules.length;
                    var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
                    toggleClass(self.calendarContainer, "rightMost", false);
                    toggleClass(self.calendarContainer, "centerMost", true);
                    doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
                    self.calendarContainer.style.left = centerLeft + "px";
                    self.calendarContainer.style.right = "auto";
                }
            }
            function redraw() {
                if (self.config.noCalendar || self.isMobile)
                    return;
                updateNavigationCurrentMonth();
                buildDays();
            }
            function focusAndClose() {
                self._input.focus();
                if (window.navigator.userAgent.indexOf("MSIE") !== -1 ||
                    navigator.msMaxTouchPoints !== undefined) {
                    // hack - bugs in the way IE handles focus keeps the calendar open
                    setTimeout(self.close, 0);
                }
                else {
                    self.close();
                }
            }
            function selectDate(e) {
                e.preventDefault();
                e.stopPropagation();
                var isSelectable = function (day) {
                    return day.classList &&
                        day.classList.contains("flatpickr-day") &&
                        !day.classList.contains("flatpickr-disabled") &&
                        !day.classList.contains("notAllowed");
                };
                var t = findParent(e.target, isSelectable);
                if (t === undefined)
                    return;
                var target = t;
                var selectedDate = (self.latestSelectedDateObj = new Date(target.dateObj.getTime()));
                var shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth ||
                    selectedDate.getMonth() >
                        self.currentMonth + self.config.showMonths - 1) &&
                    self.config.mode !== "range";
                self.selectedDateElem = target;
                if (self.config.mode === "single")
                    self.selectedDates = [selectedDate];
                else if (self.config.mode === "multiple") {
                    var selectedIndex = isDateSelected(selectedDate);
                    if (selectedIndex)
                        self.selectedDates.splice(parseInt(selectedIndex), 1);
                    else
                        self.selectedDates.push(selectedDate);
                }
                else if (self.config.mode === "range") {
                    if (self.selectedDates.length === 2) {
                        self.clear(false, false);
                    }
                    self.latestSelectedDateObj = selectedDate;
                    self.selectedDates.push(selectedDate);
                    // unless selecting same date twice, sort ascendingly
                    if (compareDates(selectedDate, self.selectedDates[0], true) !== 0)
                        self.selectedDates.sort(function (a, b) { return a.getTime() - b.getTime(); });
                }
                setHoursFromInputs();
                if (shouldChangeMonth) {
                    var isNewYear = self.currentYear !== selectedDate.getFullYear();
                    self.currentYear = selectedDate.getFullYear();
                    self.currentMonth = selectedDate.getMonth();
                    if (isNewYear) {
                        triggerEvent("onYearChange");
                        buildMonthSwitch();
                    }
                    triggerEvent("onMonthChange");
                }
                updateNavigationCurrentMonth();
                buildDays();
                updateValue();
                if (self.config.enableTime)
                    setTimeout(function () { return (self.showTimeInput = true); }, 50);
                // maintain focus
                if (!shouldChangeMonth &&
                    self.config.mode !== "range" &&
                    self.config.showMonths === 1)
                    focusOnDayElem(target);
                else if (self.selectedDateElem !== undefined &&
                    self.hourElement === undefined) {
                    self.selectedDateElem && self.selectedDateElem.focus();
                }
                if (self.hourElement !== undefined)
                    self.hourElement !== undefined && self.hourElement.focus();
                if (self.config.closeOnSelect) {
                    var single = self.config.mode === "single" && !self.config.enableTime;
                    var range = self.config.mode === "range" &&
                        self.selectedDates.length === 2 &&
                        !self.config.enableTime;
                    if (single || range) {
                        focusAndClose();
                    }
                }
                triggerChange();
            }
            var CALLBACKS = {
                locale: [setupLocale, updateWeekdays],
                showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
                minDate: [jumpToDate],
                maxDate: [jumpToDate]
            };
            function set(option, value) {
                if (option !== null && typeof option === "object") {
                    Object.assign(self.config, option);
                    for (var key in option) {
                        if (CALLBACKS[key] !== undefined)
                            CALLBACKS[key].forEach(function (x) { return x(); });
                    }
                }
                else {
                    self.config[option] = value;
                    if (CALLBACKS[option] !== undefined)
                        CALLBACKS[option].forEach(function (x) { return x(); });
                    else if (HOOKS.indexOf(option) > -1)
                        self.config[option] = arrayify(value);
                }
                self.redraw();
                updateValue(false);
            }
            function setSelectedDate(inputDate, format) {
                var dates = [];
                if (inputDate instanceof Array)
                    dates = inputDate.map(function (d) { return self.parseDate(d, format); });
                else if (inputDate instanceof Date || typeof inputDate === "number")
                    dates = [self.parseDate(inputDate, format)];
                else if (typeof inputDate === "string") {
                    switch (self.config.mode) {
                        case "single":
                        case "time":
                            dates = [self.parseDate(inputDate, format)];
                            break;
                        case "multiple":
                            dates = inputDate
                                .split(self.config.conjunction)
                                .map(function (date) { return self.parseDate(date, format); });
                            break;
                        case "range":
                            dates = inputDate
                                .split(self.l10n.rangeSeparator)
                                .map(function (date) { return self.parseDate(date, format); });
                            break;
                        default:
                            break;
                    }
                }
                else
                    self.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
                self.selectedDates = dates.filter(function (d) { return d instanceof Date && isEnabled(d, false); });
                if (self.config.mode === "range")
                    self.selectedDates.sort(function (a, b) { return a.getTime() - b.getTime(); });
            }
            function setDate(date, triggerChange, format) {
                if (triggerChange === void 0) { triggerChange = false; }
                if (format === void 0) { format = self.config.dateFormat; }
                if ((date !== 0 && !date) || (date instanceof Array && date.length === 0))
                    return self.clear(triggerChange);
                setSelectedDate(date, format);
                self.showTimeInput = self.selectedDates.length > 0;
                self.latestSelectedDateObj =
                    self.selectedDates[self.selectedDates.length - 1];
                self.redraw();
                jumpToDate();
                setHoursFromDate();
                if (self.selectedDates.length === 0) {
                    self.clear(false);
                }
                updateValue(triggerChange);
                if (triggerChange)
                    triggerEvent("onChange");
            }
            function parseDateRules(arr) {
                return arr
                    .slice()
                    .map(function (rule) {
                    if (typeof rule === "string" ||
                        typeof rule === "number" ||
                        rule instanceof Date) {
                        return self.parseDate(rule, undefined, true);
                    }
                    else if (rule &&
                        typeof rule === "object" &&
                        rule.from &&
                        rule.to)
                        return {
                            from: self.parseDate(rule.from, undefined),
                            to: self.parseDate(rule.to, undefined)
                        };
                    return rule;
                })
                    .filter(function (x) { return x; }); // remove falsy values
            }
            function setupDates() {
                self.selectedDates = [];
                self.now = self.parseDate(self.config.now) || new Date();
                // Workaround IE11 setting placeholder as the input's value
                var preloadedDate = self.config.defaultDate ||
                    ((self.input.nodeName === "INPUT" ||
                        self.input.nodeName === "TEXTAREA") &&
                        self.input.placeholder &&
                        self.input.value === self.input.placeholder
                        ? null
                        : self.input.value);
                if (preloadedDate)
                    setSelectedDate(preloadedDate, self.config.dateFormat);
                self._initialDate =
                    self.selectedDates.length > 0
                        ? self.selectedDates[0]
                        : self.config.minDate &&
                            self.config.minDate.getTime() > self.now.getTime()
                            ? self.config.minDate
                            : self.config.maxDate &&
                                self.config.maxDate.getTime() < self.now.getTime()
                                ? self.config.maxDate
                                : self.now;
                self.currentYear = self._initialDate.getFullYear();
                self.currentMonth = self._initialDate.getMonth();
                if (self.selectedDates.length > 0)
                    self.latestSelectedDateObj = self.selectedDates[0];
                if (self.config.minTime !== undefined)
                    self.config.minTime = self.parseDate(self.config.minTime, "H:i");
                if (self.config.maxTime !== undefined)
                    self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");
                self.minDateHasTime =
                    !!self.config.minDate &&
                        (self.config.minDate.getHours() > 0 ||
                            self.config.minDate.getMinutes() > 0 ||
                            self.config.minDate.getSeconds() > 0);
                self.maxDateHasTime =
                    !!self.config.maxDate &&
                        (self.config.maxDate.getHours() > 0 ||
                            self.config.maxDate.getMinutes() > 0 ||
                            self.config.maxDate.getSeconds() > 0);
                Object.defineProperty(self, "showTimeInput", {
                    get: function () { return self._showTimeInput; },
                    set: function (bool) {
                        self._showTimeInput = bool;
                        if (self.calendarContainer)
                            toggleClass(self.calendarContainer, "showTimeInput", bool);
                        self.isOpen && positionCalendar();
                    }
                });
            }
            function setupInputs() {
                self.input = self.config.wrap
                    ? element.querySelector("[data-input]")
                    : element;
                /* istanbul ignore next */
                if (!self.input) {
                    self.config.errorHandler(new Error("Invalid input element specified"));
                    return;
                }
                // hack: store previous type to restore it after destroy()
                self.input._type = self.input.type;
                self.input.type = "text";
                self.input.classList.add("flatpickr-input");
                self._input = self.input;
                if (self.config.altInput) {
                    // replicate self.element
                    self.altInput = createElement(self.input.nodeName, self.config.altInputClass);
                    self._input = self.altInput;
                    self.altInput.placeholder = self.input.placeholder;
                    self.altInput.disabled = self.input.disabled;
                    self.altInput.required = self.input.required;
                    self.altInput.tabIndex = self.input.tabIndex;
                    self.altInput.type = "text";
                    self.input.setAttribute("type", "hidden");
                    if (!self.config.static && self.input.parentNode)
                        self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
                }
                if (!self.config.allowInput)
                    self._input.setAttribute("readonly", "readonly");
                self._positionElement = self.config.positionElement || self._input;
            }
            function setupMobile() {
                var inputType = self.config.enableTime
                    ? self.config.noCalendar
                        ? "time"
                        : "datetime-local"
                    : "date";
                self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
                self.mobileInput.step = self.input.getAttribute("step") || "any";
                self.mobileInput.tabIndex = 1;
                self.mobileInput.type = inputType;
                self.mobileInput.disabled = self.input.disabled;
                self.mobileInput.required = self.input.required;
                self.mobileInput.placeholder = self.input.placeholder;
                self.mobileFormatStr =
                    inputType === "datetime-local"
                        ? "Y-m-d\\TH:i:S"
                        : inputType === "date"
                            ? "Y-m-d"
                            : "H:i:S";
                if (self.selectedDates.length > 0) {
                    self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
                }
                if (self.config.minDate)
                    self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");
                if (self.config.maxDate)
                    self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");
                self.input.type = "hidden";
                if (self.altInput !== undefined)
                    self.altInput.type = "hidden";
                try {
                    if (self.input.parentNode)
                        self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
                }
                catch (_a) { }
                bind(self.mobileInput, "change", function (e) {
                    self.setDate(e.target.value, false, self.mobileFormatStr);
                    triggerEvent("onChange");
                    triggerEvent("onClose");
                });
            }
            function toggle(e) {
                if (self.isOpen === true)
                    return self.close();
                self.open(e);
            }
            function triggerEvent(event, data) {
                // If the instance has been destroyed already, all hooks have been removed
                if (self.config === undefined)
                    return;
                var hooks = self.config[event];
                if (hooks !== undefined && hooks.length > 0) {
                    for (var i = 0; hooks[i] && i < hooks.length; i++)
                        hooks[i](self.selectedDates, self.input.value, self, data);
                }
                if (event === "onChange") {
                    self.input.dispatchEvent(createEvent("change"));
                    // many front-end frameworks bind to the input event
                    self.input.dispatchEvent(createEvent("input"));
                }
            }
            function createEvent(name) {
                var e = document.createEvent("Event");
                e.initEvent(name, true, true);
                return e;
            }
            function isDateSelected(date) {
                for (var i = 0; i < self.selectedDates.length; i++) {
                    if (compareDates(self.selectedDates[i], date) === 0)
                        return "" + i;
                }
                return false;
            }
            function isDateInRange(date) {
                if (self.config.mode !== "range" || self.selectedDates.length < 2)
                    return false;
                return (compareDates(date, self.selectedDates[0]) >= 0 &&
                    compareDates(date, self.selectedDates[1]) <= 0);
            }
            function updateNavigationCurrentMonth() {
                if (self.config.noCalendar || self.isMobile || !self.monthNav)
                    return;
                self.yearElements.forEach(function (yearElement, i) {
                    var d = new Date(self.currentYear, self.currentMonth, 1);
                    d.setMonth(self.currentMonth + i);
                    if (self.config.showMonths > 1 ||
                        self.config.monthSelectorType === "static") {
                        self.monthElements[i].textContent =
                            monthToStr(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) + " ";
                    }
                    else {
                        self.monthsDropdownContainer.value = d.getMonth().toString();
                    }
                    yearElement.value = d.getFullYear().toString();
                });
                self._hidePrevMonthArrow =
                    self.config.minDate !== undefined &&
                        (self.currentYear === self.config.minDate.getFullYear()
                            ? self.currentMonth <= self.config.minDate.getMonth()
                            : self.currentYear < self.config.minDate.getFullYear());
                self._hideNextMonthArrow =
                    self.config.maxDate !== undefined &&
                        (self.currentYear === self.config.maxDate.getFullYear()
                            ? self.currentMonth + 1 > self.config.maxDate.getMonth()
                            : self.currentYear > self.config.maxDate.getFullYear());
            }
            function getDateStr(format) {
                return self.selectedDates
                    .map(function (dObj) { return self.formatDate(dObj, format); })
                    .filter(function (d, i, arr) {
                    return self.config.mode !== "range" ||
                        self.config.enableTime ||
                        arr.indexOf(d) === i;
                })
                    .join(self.config.mode !== "range"
                    ? self.config.conjunction
                    : self.l10n.rangeSeparator);
            }
            /**
             * Updates the values of inputs associated with the calendar
             */
            function updateValue(triggerChange) {
                if (triggerChange === void 0) { triggerChange = true; }
                if (self.mobileInput !== undefined && self.mobileFormatStr) {
                    self.mobileInput.value =
                        self.latestSelectedDateObj !== undefined
                            ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr)
                            : "";
                }
                self.input.value = getDateStr(self.config.dateFormat);
                if (self.altInput !== undefined) {
                    self.altInput.value = getDateStr(self.config.altFormat);
                }
                if (triggerChange !== false)
                    triggerEvent("onValueUpdate");
            }
            function onMonthNavClick(e) {
                var isPrevMonth = self.prevMonthNav.contains(e.target);
                var isNextMonth = self.nextMonthNav.contains(e.target);
                if (isPrevMonth || isNextMonth) {
                    changeMonth(isPrevMonth ? -1 : 1);
                }
                else if (self.yearElements.indexOf(e.target) >= 0) {
                    e.target.select();
                }
                else if (e.target.classList.contains("arrowUp")) {
                    self.changeYear(self.currentYear + 1);
                }
                else if (e.target.classList.contains("arrowDown")) {
                    self.changeYear(self.currentYear - 1);
                }
            }
            function timeWrapper(e) {
                e.preventDefault();
                var isKeyDown = e.type === "keydown", input = e.target;
                if (self.amPM !== undefined && e.target === self.amPM) {
                    self.amPM.textContent =
                        self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
                }
                var min = parseFloat(input.getAttribute("min")), max = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e.delta ||
                    (isKeyDown ? (e.which === 38 ? 1 : -1) : 0);
                var newValue = curValue + step * delta;
                if (typeof input.value !== "undefined" && input.value.length === 2) {
                    var isHourElem = input === self.hourElement, isMinuteElem = input === self.minuteElement;
                    if (newValue < min) {
                        newValue =
                            max +
                                newValue +
                                int(!isHourElem) +
                                (int(isHourElem) && int(!self.amPM));
                        if (isMinuteElem)
                            incrementNumInput(undefined, -1, self.hourElement);
                    }
                    else if (newValue > max) {
                        newValue =
                            input === self.hourElement ? newValue - max - int(!self.amPM) : min;
                        if (isMinuteElem)
                            incrementNumInput(undefined, 1, self.hourElement);
                    }
                    if (self.amPM &&
                        isHourElem &&
                        (step === 1
                            ? newValue + curValue === 23
                            : Math.abs(newValue - curValue) > step)) {
                        self.amPM.textContent =
                            self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
                    }
                    input.value = pad(newValue);
                }
            }
            init();
            return self;
        }
        /* istanbul ignore next */
        function _flatpickr(nodeList, config) {
            // static list
            var nodes = Array.prototype.slice
                .call(nodeList)
                .filter(function (x) { return x instanceof HTMLElement; });
            var instances = [];
            for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                try {
                    if (node.getAttribute("data-fp-omit") !== null)
                        continue;
                    if (node._flatpickr !== undefined) {
                        node._flatpickr.destroy();
                        node._flatpickr = undefined;
                    }
                    node._flatpickr = FlatpickrInstance(node, config || {});
                    instances.push(node._flatpickr);
                }
                catch (e) {
                    console.error(e);
                }
            }
            return instances.length === 1 ? instances[0] : instances;
        }
        /* istanbul ignore next */
        if (typeof HTMLElement !== "undefined" &&
            typeof HTMLCollection !== "undefined" &&
            typeof NodeList !== "undefined") {
            // browser env
            HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {
                return _flatpickr(this, config);
            };
            HTMLElement.prototype.flatpickr = function (config) {
                return _flatpickr([this], config);
            };
        }
        /* istanbul ignore next */
        var flatpickr = function (selector, config) {
            if (typeof selector === "string") {
                return _flatpickr(window.document.querySelectorAll(selector), config);
            }
            else if (selector instanceof Node) {
                return _flatpickr([selector], config);
            }
            else {
                return _flatpickr(selector, config);
            }
        };
        /* istanbul ignore next */
        flatpickr.defaultConfig = {};
        flatpickr.l10ns = {
            en: __assign({}, english),
            "default": __assign({}, english)
        };
        flatpickr.localize = function (l10n) {
            flatpickr.l10ns["default"] = __assign({}, flatpickr.l10ns["default"], l10n);
        };
        flatpickr.setDefaults = function (config) {
            flatpickr.defaultConfig = __assign({}, flatpickr.defaultConfig, config);
        };
        flatpickr.parseDate = createDateParser({});
        flatpickr.formatDate = createDateFormatter({});
        flatpickr.compareDates = compareDates;
        /* istanbul ignore next */
        if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
            jQuery.fn.flatpickr = function (config) {
                return _flatpickr(this, config);
            };
        }
        // eslint-disable-next-line @typescript-eslint/camelcase
        Date.prototype.fp_incr = function (days) {
            return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
        };
        if (typeof window !== "undefined") {
            window.flatpickr = flatpickr;
        }

        return flatpickr;

    }));
    });

    /* src\common\DatePicker.svelte generated by Svelte v3.6.9 */

    const file$d = "src\\common\\DatePicker.svelte";

    function create_fragment$c(ctx) {
    	var div1, div0, t0, t1, input_1;

    	return {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(ctx.label);
    			t1 = space();
    			input_1 = element("input");
    			attr(div0, "class", "label svelte-1pf9x5k");
    			add_location(div0, file$d, 34, 4, 545);
    			attr(input_1, "class", "control svelte-1pf9x5k");
    			add_location(input_1, file$d, 35, 4, 583);
    			attr(div1, "class", "container svelte-1pf9x5k");
    			add_location(div1, file$d, 33, 1, 515);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);
    			append(div0, t0);
    			append(div1, t1);
    			append(div1, input_1);
    			ctx.input_1_binding(input_1);
    		},

    		p: function update(changed, ctx) {
    			if (changed.label) {
    				set_data(t0, ctx.label);
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div1);
    			}

    			ctx.input_1_binding(null);
    		}
    	};
    }

    function instance$c($$self, $$props, $$invalidate) {
    	

    let { value, label } = $$props;
    let input;
    let fpInstance;

    onMount(() => {
        $$invalidate('fpInstance', fpInstance =  flatpickr(input, {}));

        fpInstance.config.onChange.push(selectedDates => {
            if(selectedDates.length > 0)
                $$invalidate('value', value = new Date(selectedDates[0]));
        });

        return fpInstance;
    });

    	const writable_props = ['value', 'label'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<DatePicker> was created with unknown prop '${key}'`);
    	});

    	function input_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('input', input = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ('value' in $$props) $$invalidate('value', value = $$props.value);
    		if ('label' in $$props) $$invalidate('label', label = $$props.label);
    	};

    	$$self.$$.update = ($$dirty = { fpInstance: 1, value: 1 }) => {
    		if ($$dirty.fpInstance || $$dirty.value) { if (fpInstance) fpInstance.setDate(value); }
    	};

    	return { value, label, input, input_1_binding };
    }

    class DatePicker extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, ["value", "label"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.value === undefined && !('value' in props)) {
    			console.warn("<DatePicker> was created without expected prop 'value'");
    		}
    		if (ctx.label === undefined && !('label' in props)) {
    			console.warn("<DatePicker> was created without expected prop 'label'");
    		}
    	}

    	get value() {
    		throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\database\FieldView.svelte generated by Svelte v3.6.9 */

    const file$e = "src\\database\\FieldView.svelte";

    // (66:4) {:else}
    function create_else_block$1(ctx) {
    	var div, t_value = ctx.clonedField.name, t;

    	return {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			set_style(div, "font-weight", "bold");
    			add_location(div, file$e, 66, 4, 2026);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, t);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.clonedField) && t_value !== (t_value = ctx.clonedField.name)) {
    				set_data(t, t_value);
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}
    		}
    	};
    }

    // (64:4) {#if isNew}
    function create_if_block_6(ctx) {
    	var updating_text, current;

    	function textbox_text_binding(value) {
    		ctx.textbox_text_binding.call(null, value);
    		updating_text = true;
    		add_flush_callback(() => updating_text = false);
    	}

    	let textbox_props = { label: "Field Name" };
    	if (ctx.clonedField.name !== void 0) {
    		textbox_props.text = ctx.clonedField.name;
    	}
    	var textbox = new Textbox({ props: textbox_props, $$inline: true });

    	binding_callbacks.push(() => bind(textbox, 'text', textbox_text_binding));

    	return {
    		c: function create() {
    			textbox.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(textbox, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var textbox_changes = {};
    			if (!updating_text && changed.clonedField) {
    				textbox_changes.text = ctx.clonedField.name;
    			}
    			textbox.$set(textbox_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(textbox.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(textbox.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(textbox, detaching);
    		}
    	};
    }

    // (101:51) 
    function create_if_block_5(ctx) {
    	var updating_value, t, updating_value_1, current;

    	function numberbox0_value_binding_1(value) {
    		ctx.numberbox0_value_binding_1.call(null, value);
    		updating_value = true;
    		add_flush_callback(() => updating_value = false);
    	}

    	let numberbox0_props = { label: "Min Length" };
    	if (ctx.clonedField.typeOptions.minLength !== void 0) {
    		numberbox0_props.value = ctx.clonedField.typeOptions.minLength;
    	}
    	var numberbox0 = new NumberBox({ props: numberbox0_props, $$inline: true });

    	binding_callbacks.push(() => bind(numberbox0, 'value', numberbox0_value_binding_1));

    	function numberbox1_value_binding_1(value_1) {
    		ctx.numberbox1_value_binding_1.call(null, value_1);
    		updating_value_1 = true;
    		add_flush_callback(() => updating_value_1 = false);
    	}

    	let numberbox1_props = { label: "Max Length" };
    	if (ctx.clonedField.typeOptions.maxLength !== void 0) {
    		numberbox1_props.value = ctx.clonedField.typeOptions.maxLength;
    	}
    	var numberbox1 = new NumberBox({ props: numberbox1_props, $$inline: true });

    	binding_callbacks.push(() => bind(numberbox1, 'value', numberbox1_value_binding_1));

    	return {
    		c: function create() {
    			numberbox0.$$.fragment.c();
    			t = space();
    			numberbox1.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(numberbox0, target, anchor);
    			insert(target, t, anchor);
    			mount_component(numberbox1, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var numberbox0_changes = {};
    			if (!updating_value && changed.clonedField) {
    				numberbox0_changes.value = ctx.clonedField.typeOptions.minLength;
    			}
    			numberbox0.$set(numberbox0_changes);

    			var numberbox1_changes = {};
    			if (!updating_value_1 && changed.clonedField) {
    				numberbox1_changes.value = ctx.clonedField.typeOptions.maxLength;
    			}
    			numberbox1.$set(numberbox1_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(numberbox0.$$.fragment, local);

    			transition_in(numberbox1.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(numberbox0.$$.fragment, local);
    			transition_out(numberbox1.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(numberbox0, detaching);

    			if (detaching) {
    				detach(t);
    			}

    			destroy_component(numberbox1, detaching);
    		}
    	};
    }

    // (85:47) 
    function create_if_block_4(ctx) {
    	var updating_selected, t0, updating_selected_1, t1, updating_text, current;

    	function dropdown0_selected_binding(value) {
    		ctx.dropdown0_selected_binding.call(null, value);
    		updating_selected = true;
    		add_flush_callback(() => updating_selected = false);
    	}

    	let dropdown0_props = {
    		label: "Lookup Index",
    		options: ctx.possibleReferenceIndexes,
    		valueMember: func,
    		textMember: func_1
    	};
    	if (ctx.clonedField.typeOptions.indexNodeKey !== void 0) {
    		dropdown0_props.selected = ctx.clonedField.typeOptions.indexNodeKey;
    	}
    	var dropdown0 = new Dropdown({ props: dropdown0_props, $$inline: true });

    	binding_callbacks.push(() => bind(dropdown0, 'selected', dropdown0_selected_binding));

    	function dropdown1_selected_binding(value_1) {
    		ctx.dropdown1_selected_binding.call(null, value_1);
    		updating_selected_1 = true;
    		add_flush_callback(() => updating_selected_1 = false);
    	}

    	let dropdown1_props = {
    		label: "Reverse Reference Index",
    		options: ctx.possibleReverseReferenceIndexes,
    		multiple: "true",
    		valueMember: func_2,
    		textMember: func_3
    	};
    	if (ctx.clonedField.typeOptions.reverseIndexNodeKeys !== void 0) {
    		dropdown1_props.selected = ctx.clonedField.typeOptions.reverseIndexNodeKeys;
    	}
    	var dropdown1 = new Dropdown({ props: dropdown1_props, $$inline: true });

    	binding_callbacks.push(() => bind(dropdown1, 'selected', dropdown1_selected_binding));

    	function textbox_text_binding_2(value_2) {
    		ctx.textbox_text_binding_2.call(null, value_2);
    		updating_text = true;
    		add_flush_callback(() => updating_text = false);
    	}

    	let textbox_props = { label: "Display Value" };
    	if (ctx.clonedField.typeOptions.displayValue !== void 0) {
    		textbox_props.text = ctx.clonedField.typeOptions.displayValue;
    	}
    	var textbox = new Textbox({ props: textbox_props, $$inline: true });

    	binding_callbacks.push(() => bind(textbox, 'text', textbox_text_binding_2));

    	return {
    		c: function create() {
    			dropdown0.$$.fragment.c();
    			t0 = space();
    			dropdown1.$$.fragment.c();
    			t1 = space();
    			textbox.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(dropdown0, target, anchor);
    			insert(target, t0, anchor);
    			mount_component(dropdown1, target, anchor);
    			insert(target, t1, anchor);
    			mount_component(textbox, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var dropdown0_changes = {};
    			if (changed.possibleReferenceIndexes) dropdown0_changes.options = ctx.possibleReferenceIndexes;
    			if (!updating_selected && changed.clonedField) {
    				dropdown0_changes.selected = ctx.clonedField.typeOptions.indexNodeKey;
    			}
    			dropdown0.$set(dropdown0_changes);

    			var dropdown1_changes = {};
    			if (changed.possibleReverseReferenceIndexes) dropdown1_changes.options = ctx.possibleReverseReferenceIndexes;
    			if (!updating_selected_1 && changed.clonedField) {
    				dropdown1_changes.selected = ctx.clonedField.typeOptions.reverseIndexNodeKeys;
    			}
    			dropdown1.$set(dropdown1_changes);

    			var textbox_changes = {};
    			if (!updating_text && changed.clonedField) {
    				textbox_changes.text = ctx.clonedField.typeOptions.displayValue;
    			}
    			textbox.$set(textbox_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown0.$$.fragment, local);

    			transition_in(dropdown1.$$.fragment, local);

    			transition_in(textbox.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(textbox.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(dropdown0, detaching);

    			if (detaching) {
    				detach(t0);
    			}

    			destroy_component(dropdown1, detaching);

    			if (detaching) {
    				detach(t1);
    			}

    			destroy_component(textbox, detaching);
    		}
    	};
    }

    // (81:44) 
    function create_if_block_3(ctx) {
    	var updating_value, t0, updating_value_1, t1, updating_value_2, current;

    	function numberbox0_value_binding(value) {
    		ctx.numberbox0_value_binding.call(null, value);
    		updating_value = true;
    		add_flush_callback(() => updating_value = false);
    	}

    	let numberbox0_props = { label: "Min Value" };
    	if (ctx.clonedField.typeOptions.minValue !== void 0) {
    		numberbox0_props.value = ctx.clonedField.typeOptions.minValue;
    	}
    	var numberbox0 = new NumberBox({ props: numberbox0_props, $$inline: true });

    	binding_callbacks.push(() => bind(numberbox0, 'value', numberbox0_value_binding));

    	function numberbox1_value_binding(value_1) {
    		ctx.numberbox1_value_binding.call(null, value_1);
    		updating_value_1 = true;
    		add_flush_callback(() => updating_value_1 = false);
    	}

    	let numberbox1_props = { label: "Max Value" };
    	if (ctx.clonedField.typeOptions.maxValue !== void 0) {
    		numberbox1_props.value = ctx.clonedField.typeOptions.maxValue;
    	}
    	var numberbox1 = new NumberBox({ props: numberbox1_props, $$inline: true });

    	binding_callbacks.push(() => bind(numberbox1, 'value', numberbox1_value_binding));

    	function numberbox2_value_binding(value_2) {
    		ctx.numberbox2_value_binding.call(null, value_2);
    		updating_value_2 = true;
    		add_flush_callback(() => updating_value_2 = false);
    	}

    	let numberbox2_props = { label: "Decimal Places" };
    	if (ctx.clonedField.typeOptions.decimalPlaces !== void 0) {
    		numberbox2_props.value = ctx.clonedField.typeOptions.decimalPlaces;
    	}
    	var numberbox2 = new NumberBox({ props: numberbox2_props, $$inline: true });

    	binding_callbacks.push(() => bind(numberbox2, 'value', numberbox2_value_binding));

    	return {
    		c: function create() {
    			numberbox0.$$.fragment.c();
    			t0 = space();
    			numberbox1.$$.fragment.c();
    			t1 = space();
    			numberbox2.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(numberbox0, target, anchor);
    			insert(target, t0, anchor);
    			mount_component(numberbox1, target, anchor);
    			insert(target, t1, anchor);
    			mount_component(numberbox2, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var numberbox0_changes = {};
    			if (!updating_value && changed.clonedField) {
    				numberbox0_changes.value = ctx.clonedField.typeOptions.minValue;
    			}
    			numberbox0.$set(numberbox0_changes);

    			var numberbox1_changes = {};
    			if (!updating_value_1 && changed.clonedField) {
    				numberbox1_changes.value = ctx.clonedField.typeOptions.maxValue;
    			}
    			numberbox1.$set(numberbox1_changes);

    			var numberbox2_changes = {};
    			if (!updating_value_2 && changed.clonedField) {
    				numberbox2_changes.value = ctx.clonedField.typeOptions.decimalPlaces;
    			}
    			numberbox2.$set(numberbox2_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(numberbox0.$$.fragment, local);

    			transition_in(numberbox1.$$.fragment, local);

    			transition_in(numberbox2.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(numberbox0.$$.fragment, local);
    			transition_out(numberbox1.$$.fragment, local);
    			transition_out(numberbox2.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(numberbox0, detaching);

    			if (detaching) {
    				detach(t0);
    			}

    			destroy_component(numberbox1, detaching);

    			if (detaching) {
    				detach(t1);
    			}

    			destroy_component(numberbox2, detaching);
    		}
    	};
    }

    // (78:46) 
    function create_if_block_2(ctx) {
    	var updating_value, t, updating_value_1, current;

    	function datepicker0_value_binding(value) {
    		ctx.datepicker0_value_binding.call(null, value);
    		updating_value = true;
    		add_flush_callback(() => updating_value = false);
    	}

    	let datepicker0_props = { label: "Min Value" };
    	if (ctx.clonedField.typeOptions.minValue !== void 0) {
    		datepicker0_props.value = ctx.clonedField.typeOptions.minValue;
    	}
    	var datepicker0 = new DatePicker({ props: datepicker0_props, $$inline: true });

    	binding_callbacks.push(() => bind(datepicker0, 'value', datepicker0_value_binding));

    	function datepicker1_value_binding(value_1) {
    		ctx.datepicker1_value_binding.call(null, value_1);
    		updating_value_1 = true;
    		add_flush_callback(() => updating_value_1 = false);
    	}

    	let datepicker1_props = { label: "Max Value" };
    	if (ctx.clonedField.typeOptions.maxValue !== void 0) {
    		datepicker1_props.value = ctx.clonedField.typeOptions.maxValue;
    	}
    	var datepicker1 = new DatePicker({ props: datepicker1_props, $$inline: true });

    	binding_callbacks.push(() => bind(datepicker1, 'value', datepicker1_value_binding));

    	return {
    		c: function create() {
    			datepicker0.$$.fragment.c();
    			t = space();
    			datepicker1.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(datepicker0, target, anchor);
    			insert(target, t, anchor);
    			mount_component(datepicker1, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var datepicker0_changes = {};
    			if (!updating_value && changed.clonedField) {
    				datepicker0_changes.value = ctx.clonedField.typeOptions.minValue;
    			}
    			datepicker0.$set(datepicker0_changes);

    			var datepicker1_changes = {};
    			if (!updating_value_1 && changed.clonedField) {
    				datepicker1_changes.value = ctx.clonedField.typeOptions.maxValue;
    			}
    			datepicker1.$set(datepicker1_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(datepicker0.$$.fragment, local);

    			transition_in(datepicker1.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(datepicker0.$$.fragment, local);
    			transition_out(datepicker1.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(datepicker0, detaching);

    			if (detaching) {
    				detach(t);
    			}

    			destroy_component(datepicker1, detaching);
    		}
    	};
    }

    // (76:42) 
    function create_if_block_1(ctx) {
    	var updating_checked, current;

    	function checkbox_checked_binding_1(value) {
    		ctx.checkbox_checked_binding_1.call(null, value);
    		updating_checked = true;
    		add_flush_callback(() => updating_checked = false);
    	}

    	let checkbox_props = { label: "Allow Null" };
    	if (ctx.clonedField.typeOptions.allowNulls !== void 0) {
    		checkbox_props.checked = ctx.clonedField.typeOptions.allowNulls;
    	}
    	var checkbox = new Checkbox({ props: checkbox_props, $$inline: true });

    	binding_callbacks.push(() => bind(checkbox, 'checked', checkbox_checked_binding_1));

    	return {
    		c: function create() {
    			checkbox.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(checkbox, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var checkbox_changes = {};
    			if (!updating_checked && changed.clonedField) {
    				checkbox_changes.checked = ctx.clonedField.typeOptions.allowNulls;
    			}
    			checkbox.$set(checkbox_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkbox.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(checkbox.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(checkbox, detaching);
    		}
    	};
    }

    // (72:4) {#if clonedField.type === "string"}
    function create_if_block$3(ctx) {
    	var updating_value, t0, updating_values, t1, updating_checked, current;

    	function numberbox_value_binding(value) {
    		ctx.numberbox_value_binding.call(null, value);
    		updating_value = true;
    		add_flush_callback(() => updating_value = false);
    	}

    	let numberbox_props = { label: "Max Length" };
    	if (ctx.clonedField.typeOptions.maxLength !== void 0) {
    		numberbox_props.value = ctx.clonedField.typeOptions.maxLength;
    	}
    	var numberbox = new NumberBox({ props: numberbox_props, $$inline: true });

    	binding_callbacks.push(() => bind(numberbox, 'value', numberbox_value_binding));

    	function valueslist_values_binding(value_1) {
    		ctx.valueslist_values_binding.call(null, value_1);
    		updating_values = true;
    		add_flush_callback(() => updating_values = false);
    	}

    	let valueslist_props = { label: "Values (options)" };
    	if (ctx.clonedField.typeOptions.values !== void 0) {
    		valueslist_props.values = ctx.clonedField.typeOptions.values;
    	}
    	var valueslist = new ValuesList({ props: valueslist_props, $$inline: true });

    	binding_callbacks.push(() => bind(valueslist, 'values', valueslist_values_binding));

    	function checkbox_checked_binding(value_2) {
    		ctx.checkbox_checked_binding.call(null, value_2);
    		updating_checked = true;
    		add_flush_callback(() => updating_checked = false);
    	}

    	let checkbox_props = { label: "Declared Values Only" };
    	if (ctx.clonedField.typeOptions.allowDeclaredValuesOnly !== void 0) {
    		checkbox_props.checked = ctx.clonedField.typeOptions.allowDeclaredValuesOnly;
    	}
    	var checkbox = new Checkbox({ props: checkbox_props, $$inline: true });

    	binding_callbacks.push(() => bind(checkbox, 'checked', checkbox_checked_binding));

    	return {
    		c: function create() {
    			numberbox.$$.fragment.c();
    			t0 = space();
    			valueslist.$$.fragment.c();
    			t1 = space();
    			checkbox.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(numberbox, target, anchor);
    			insert(target, t0, anchor);
    			mount_component(valueslist, target, anchor);
    			insert(target, t1, anchor);
    			mount_component(checkbox, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var numberbox_changes = {};
    			if (!updating_value && changed.clonedField) {
    				numberbox_changes.value = ctx.clonedField.typeOptions.maxLength;
    			}
    			numberbox.$set(numberbox_changes);

    			var valueslist_changes = {};
    			if (!updating_values && changed.clonedField) {
    				valueslist_changes.values = ctx.clonedField.typeOptions.values;
    			}
    			valueslist.$set(valueslist_changes);

    			var checkbox_changes = {};
    			if (!updating_checked && changed.clonedField) {
    				checkbox_changes.checked = ctx.clonedField.typeOptions.allowDeclaredValuesOnly;
    			}
    			checkbox.$set(checkbox_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(numberbox.$$.fragment, local);

    			transition_in(valueslist.$$.fragment, local);

    			transition_in(checkbox.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(numberbox.$$.fragment, local);
    			transition_out(valueslist.$$.fragment, local);
    			transition_out(checkbox.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(numberbox, detaching);

    			if (detaching) {
    				detach(t0);
    			}

    			destroy_component(valueslist, detaching);

    			if (detaching) {
    				detach(t1);
    			}

    			destroy_component(checkbox, detaching);
    		}
    	};
    }

    // (107:8) <Button color="primary" grouped on:click={save}>
    function create_default_slot_2(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Save");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (108:8) <Button color="secondary" grouped on:click={() => onFinished(false)}>
    function create_default_slot_1(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Cancel");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (106:4) <ButtonGroup style="float: right;">
    function create_default_slot(ctx) {
    	var t, current;

    	var button0 = new Button({
    		props: {
    		color: "primary",
    		grouped: true,
    		$$slots: { default: [create_default_slot_2] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});
    	button0.$on("click", ctx.save);

    	var button1 = new Button({
    		props: {
    		color: "secondary",
    		grouped: true,
    		$$slots: { default: [create_default_slot_1] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});
    	button1.$on("click", ctx.click_handler);

    	return {
    		c: function create() {
    			button0.$$.fragment.c();
    			t = space();
    			button1.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert(target, t, anchor);
    			mount_component(button1, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var button0_changes = {};
    			if (changed.$$scope) button0_changes.$$scope = { changed, ctx };
    			button0.$set(button0_changes);

    			var button1_changes = {};
    			if (changed.$$scope) button1_changes.$$scope = { changed, ctx };
    			button1.$set(button1_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);

    			transition_in(button1.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);

    			if (detaching) {
    				detach(t);
    			}

    			destroy_component(button1, detaching);
    		}
    	};
    }

    function create_fragment$d(ctx) {
    	var div, t0, updating_selected, t1, current_block_type_index, if_block0, t2, updating_text, t3, current_block_type_index_1, if_block1, t4, current;

    	var errorsbox = new ErrorsBox({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	function dropdown_selected_binding(value) {
    		ctx.dropdown_selected_binding.call(null, value);
    		updating_selected = true;
    		add_flush_callback(() => updating_selected = false);
    	}

    	let dropdown_props = { label: "Type", options: fp.keys(allTypes$1) };
    	if (ctx.clonedField.type !== void 0) {
    		dropdown_props.selected = ctx.clonedField.type;
    	}
    	var dropdown = new Dropdown({ props: dropdown_props, $$inline: true });

    	binding_callbacks.push(() => bind(dropdown, 'selected', dropdown_selected_binding));
    	dropdown.$on("change", ctx.typeChanged);

    	var if_block_creators = [
    		create_if_block_6,
    		create_else_block$1
    	];

    	var if_blocks = [];

    	function select_block_type(ctx) {
    		if (ctx.isNew) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	function textbox_text_binding_1(value_1) {
    		ctx.textbox_text_binding_1.call(null, value_1);
    		updating_text = true;
    		add_flush_callback(() => updating_text = false);
    	}

    	let textbox_props = { label: "Label" };
    	if (ctx.clonedField.label !== void 0) {
    		textbox_props.text = ctx.clonedField.label;
    	}
    	var textbox = new Textbox({ props: textbox_props, $$inline: true });

    	binding_callbacks.push(() => bind(textbox, 'text', textbox_text_binding_1));

    	var if_block_creators_1 = [
    		create_if_block$3,
    		create_if_block_1,
    		create_if_block_2,
    		create_if_block_3,
    		create_if_block_4,
    		create_if_block_5
    	];

    	var if_blocks_1 = [];

    	function select_block_type_1(ctx) {
    		if (ctx.clonedField.type === "string") return 0;
    		if (ctx.clonedField.type === "bool") return 1;
    		if (ctx.clonedField.type === "datetime") return 2;
    		if (ctx.clonedField.type === "number") return 3;
    		if (ctx.clonedField.type === "reference") return 4;
    		if (ctx.clonedField.type.startsWith("array")) return 5;
    		return -1;
    	}

    	if (~(current_block_type_index_1 = select_block_type_1(ctx))) {
    		if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    	}

    	var buttongroup = new ButtonGroup({
    		props: {
    		style: "float: right;",
    		$$slots: { default: [create_default_slot] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			div = element("div");
    			errorsbox.$$.fragment.c();
    			t0 = space();
    			dropdown.$$.fragment.c();
    			t1 = space();
    			if_block0.c();
    			t2 = space();
    			textbox.$$.fragment.c();
    			t3 = space();
    			if (if_block1) if_block1.c();
    			t4 = space();
    			buttongroup.$$.fragment.c();
    			attr(div, "class", "root");
    			add_location(div, file$e, 57, 0, 1753);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			mount_component(errorsbox, div, null);
    			append(div, t0);
    			mount_component(dropdown, div, null);
    			append(div, t1);
    			if_blocks[current_block_type_index].m(div, null);
    			append(div, t2);
    			mount_component(textbox, div, null);
    			append(div, t3);
    			if (~current_block_type_index_1) if_blocks_1[current_block_type_index_1].m(div, null);
    			append(div, t4);
    			mount_component(buttongroup, div, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var errorsbox_changes = {};
    			if (changed.errors) errorsbox_changes.errors = ctx.errors;
    			errorsbox.$set(errorsbox_changes);

    			var dropdown_changes = {};
    			if (changed.keys || changed.allTypes) dropdown_changes.options = fp.keys(allTypes$1);
    			if (!updating_selected && changed.clonedField) {
    				dropdown_changes.selected = ctx.clonedField.type;
    			}
    			dropdown.$set(dropdown_changes);

    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);
    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(changed, ctx);
    			} else {
    				group_outros();
    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});
    				check_outros();

    				if_block0 = if_blocks[current_block_type_index];
    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				}
    				transition_in(if_block0, 1);
    				if_block0.m(div, t2);
    			}

    			var textbox_changes = {};
    			if (!updating_text && changed.clonedField) {
    				textbox_changes.text = ctx.clonedField.label;
    			}
    			textbox.$set(textbox_changes);

    			var previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_1(ctx);
    			if (current_block_type_index_1 === previous_block_index_1) {
    				if (~current_block_type_index_1) if_blocks_1[current_block_type_index_1].p(changed, ctx);
    			} else {
    				if (if_block1) {
    					group_outros();
    					transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    						if_blocks_1[previous_block_index_1] = null;
    					});
    					check_outros();
    				}

    				if (~current_block_type_index_1) {
    					if_block1 = if_blocks_1[current_block_type_index_1];
    					if (!if_block1) {
    						if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    						if_block1.c();
    					}
    					transition_in(if_block1, 1);
    					if_block1.m(div, t4);
    				} else {
    					if_block1 = null;
    				}
    			}

    			var buttongroup_changes = {};
    			if (changed.$$scope) buttongroup_changes.$$scope = { changed, ctx };
    			buttongroup.$set(buttongroup_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(errorsbox.$$.fragment, local);

    			transition_in(dropdown.$$.fragment, local);

    			transition_in(if_block0);

    			transition_in(textbox.$$.fragment, local);

    			transition_in(if_block1);

    			transition_in(buttongroup.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(errorsbox.$$.fragment, local);
    			transition_out(dropdown.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(textbox.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(buttongroup.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			destroy_component(errorsbox);

    			destroy_component(dropdown);

    			if_blocks[current_block_type_index].d();

    			destroy_component(textbox);

    			if (~current_block_type_index_1) if_blocks_1[current_block_type_index_1].d();

    			destroy_component(buttongroup);
    		}
    	};
    }

    function func(n) {
    	return n.nodeKey();
    }

    function func_1(n) {
    	return n.name;
    }

    function func_2(n) {
    	return n.nodeKey();
    }

    function func_3(n) {
    	return n.name;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	

    let { field, allFields, onFinished = () => {} } = $$props;
    let { database } = $$props;

    let errors = [];
    let clonedField = fp.cloneDeep(field);

    const typeChanged = (ev) => 
        { const $$result = clonedField.typeOptions = getDefaultTypeOptions(ev.detail); $$invalidate('clonedField', clonedField); return $$result; };


    const save = () => {

        $$invalidate('errors', errors = validate.field(allFields)(clonedField));
        if(errors.length > 0) return;
        field.typeOptions = fp.cloneDeep(clonedField.typeOptions); $$invalidate('field', field);
        onFinished(
            fp.assign(field)(clonedField)
        );
    };

    	const writable_props = ['field', 'allFields', 'onFinished', 'database'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<FieldView> was created with unknown prop '${key}'`);
    	});

    	function dropdown_selected_binding(value) {
    		clonedField.type = value;
    		$$invalidate('clonedField', clonedField);
    	}

    	function textbox_text_binding(value) {
    		clonedField.name = value;
    		$$invalidate('clonedField', clonedField);
    	}

    	function textbox_text_binding_1(value_1) {
    		clonedField.label = value_1;
    		$$invalidate('clonedField', clonedField);
    	}

    	function numberbox_value_binding(value) {
    		clonedField.typeOptions.maxLength = value;
    		$$invalidate('clonedField', clonedField);
    	}

    	function valueslist_values_binding(value_1) {
    		clonedField.typeOptions.values = value_1;
    		$$invalidate('clonedField', clonedField);
    	}

    	function checkbox_checked_binding(value_2) {
    		clonedField.typeOptions.allowDeclaredValuesOnly = value_2;
    		$$invalidate('clonedField', clonedField);
    	}

    	function checkbox_checked_binding_1(value) {
    		clonedField.typeOptions.allowNulls = value;
    		$$invalidate('clonedField', clonedField);
    	}

    	function datepicker0_value_binding(value) {
    		clonedField.typeOptions.minValue = value;
    		$$invalidate('clonedField', clonedField);
    	}

    	function datepicker1_value_binding(value_1) {
    		clonedField.typeOptions.maxValue = value_1;
    		$$invalidate('clonedField', clonedField);
    	}

    	function numberbox0_value_binding(value) {
    		clonedField.typeOptions.minValue = value;
    		$$invalidate('clonedField', clonedField);
    	}

    	function numberbox1_value_binding(value_1) {
    		clonedField.typeOptions.maxValue = value_1;
    		$$invalidate('clonedField', clonedField);
    	}

    	function numberbox2_value_binding(value_2) {
    		clonedField.typeOptions.decimalPlaces = value_2;
    		$$invalidate('clonedField', clonedField);
    	}

    	function dropdown0_selected_binding(value) {
    		clonedField.typeOptions.indexNodeKey = value;
    		$$invalidate('clonedField', clonedField);
    	}

    	function dropdown1_selected_binding(value_1) {
    		clonedField.typeOptions.reverseIndexNodeKeys = value_1;
    		$$invalidate('clonedField', clonedField);
    	}

    	function textbox_text_binding_2(value_2) {
    		clonedField.typeOptions.displayValue = value_2;
    		$$invalidate('clonedField', clonedField);
    	}

    	function numberbox0_value_binding_1(value) {
    		clonedField.typeOptions.minLength = value;
    		$$invalidate('clonedField', clonedField);
    	}

    	function numberbox1_value_binding_1(value_1) {
    		clonedField.typeOptions.maxLength = value_1;
    		$$invalidate('clonedField', clonedField);
    	}

    	function click_handler() {
    		return onFinished(false);
    	}

    	$$self.$set = $$props => {
    		if ('field' in $$props) $$invalidate('field', field = $$props.field);
    		if ('allFields' in $$props) $$invalidate('allFields', allFields = $$props.allFields);
    		if ('onFinished' in $$props) $$invalidate('onFinished', onFinished = $$props.onFinished);
    		if ('database' in $$props) $$invalidate('database', database = $$props.database);
    	};

    	let isNew, possibleReferenceIndexes, selectedReverseRefIndex, possibleReverseReferenceIndexes;

    	$$self.$$.update = ($$dirty = { field: 1, database: 1, clonedField: 1, selectedReverseRefIndex: 1 }) => {
    		if ($$dirty.field) { $$invalidate('isNew', isNew = !!field && field.name.length === 0); }
    		if ($$dirty.database) { $$invalidate('possibleReferenceIndexes', possibleReferenceIndexes = getPotentialReferenceIndexes(
                database.hierarchy, database.currentNode
            )); }
    		if ($$dirty.clonedField || $$dirty.database) { $$invalidate('selectedReverseRefIndex', selectedReverseRefIndex = 
                !clonedField.typeOptions.indexNodeKey 
                ? ""
                : getNode$1(database.hierarchy, clonedField.typeOptions.indexNodeKey)); }
    		if ($$dirty.selectedReverseRefIndex || $$dirty.database) { $$invalidate('possibleReverseReferenceIndexes', possibleReverseReferenceIndexes = 
                !selectedReverseRefIndex 
                ? []
                : getPotentialReverseReferenceIndexes(
                    database.hierarchy, selectedReverseRefIndex)); }
    	};

    	return {
    		field,
    		allFields,
    		onFinished,
    		database,
    		errors,
    		clonedField,
    		typeChanged,
    		save,
    		isNew,
    		possibleReferenceIndexes,
    		possibleReverseReferenceIndexes,
    		dropdown_selected_binding,
    		textbox_text_binding,
    		textbox_text_binding_1,
    		numberbox_value_binding,
    		valueslist_values_binding,
    		checkbox_checked_binding,
    		checkbox_checked_binding_1,
    		datepicker0_value_binding,
    		datepicker1_value_binding,
    		numberbox0_value_binding,
    		numberbox1_value_binding,
    		numberbox2_value_binding,
    		dropdown0_selected_binding,
    		dropdown1_selected_binding,
    		textbox_text_binding_2,
    		numberbox0_value_binding_1,
    		numberbox1_value_binding_1,
    		click_handler
    	};
    }

    class FieldView extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, ["field", "allFields", "onFinished", "database"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.field === undefined && !('field' in props)) {
    			console.warn("<FieldView> was created without expected prop 'field'");
    		}
    		if (ctx.allFields === undefined && !('allFields' in props)) {
    			console.warn("<FieldView> was created without expected prop 'allFields'");
    		}
    		if (ctx.database === undefined && !('database' in props)) {
    			console.warn("<FieldView> was created without expected prop 'database'");
    		}
    	}

    	get field() {
    		throw new Error("<FieldView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set field(value) {
    		throw new Error("<FieldView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get allFields() {
    		throw new Error("<FieldView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set allFields(value) {
    		throw new Error("<FieldView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onFinished() {
    		throw new Error("<FieldView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onFinished(value) {
    		throw new Error("<FieldView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get database() {
    		throw new Error("<FieldView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set database(value) {
    		throw new Error("<FieldView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var uikit = createCommonjsModule(function (module, exports) {
    /*! UIkit 3.1.6 | http://www.getuikit.com | (c) 2014 - 2018 YOOtheme | MIT License */

    (function (global, factory) {
         module.exports = factory() ;
    }(commonjsGlobal, function () {
        function bind(fn, context) {
            return function (a) {
                var l = arguments.length;
                return l ? l > 1 ? fn.apply(context, arguments) : fn.call(context, a) : fn.call(context);
            };
        }

        var objPrototype = Object.prototype;
        var hasOwnProperty = objPrototype.hasOwnProperty;

        function hasOwn(obj, key) {
            return hasOwnProperty.call(obj, key);
        }

        var hyphenateCache = {};
        var hyphenateRe = /([a-z\d])([A-Z])/g;

        function hyphenate(str) {

            if (!(str in hyphenateCache)) {
                hyphenateCache[str] = str
                    .replace(hyphenateRe, '$1-$2')
                    .toLowerCase();
            }

            return hyphenateCache[str];
        }

        var camelizeRe = /-(\w)/g;

        function camelize(str) {
            return str.replace(camelizeRe, toUpper);
        }

        function toUpper(_, c) {
            return c ? c.toUpperCase() : '';
        }

        function ucfirst(str) {
            return str.length ? toUpper(null, str.charAt(0)) + str.slice(1) : '';
        }

        var strPrototype = String.prototype;
        var startsWithFn = strPrototype.startsWith || function (search) { return this.lastIndexOf(search, 0) === 0; };

        function startsWith(str, search) {
            return startsWithFn.call(str, search);
        }

        var endsWithFn = strPrototype.endsWith || function (search) { return this.substr(-search.length) === search; };

        function endsWith(str, search) {
            return endsWithFn.call(str, search);
        }

        var arrPrototype = Array.prototype;

        var includesFn = function (search, i) { return ~this.indexOf(search, i); };
        var includesStr = strPrototype.includes || includesFn;
        var includesArray = arrPrototype.includes || includesFn;

        function includes(obj, search) {
            return obj && (isString(obj) ? includesStr : includesArray).call(obj, search);
        }

        var findIndexFn = arrPrototype.findIndex || function (predicate) {
            var arguments$1 = arguments;

            for (var i = 0; i < this.length; i++) {
                if (predicate.call(arguments$1[1], this[i], i, this)) {
                    return i;
                }
            }
            return -1;
        };

        function findIndex(array, predicate) {
            return findIndexFn.call(array, predicate);
        }

        var isArray = Array.isArray;

        function isFunction(obj) {
            return typeof obj === 'function';
        }

        function isObject(obj) {
            return obj !== null && typeof obj === 'object';
        }

        function isPlainObject(obj) {
            return isObject(obj) && Object.getPrototypeOf(obj) === objPrototype;
        }

        function isWindow(obj) {
            return isObject(obj) && obj === obj.window;
        }

        function isDocument(obj) {
            return isObject(obj) && obj.nodeType === 9;
        }

        function isJQuery(obj) {
            return isObject(obj) && !!obj.jquery;
        }

        function isNode(obj) {
            return obj instanceof Node || isObject(obj) && obj.nodeType >= 1;
        }

        var toString = objPrototype.toString;
        function isNodeCollection(obj) {
            return toString.call(obj).match(/^\[object (NodeList|HTMLCollection)\]$/);
        }

        function isBoolean(value) {
            return typeof value === 'boolean';
        }

        function isString(value) {
            return typeof value === 'string';
        }

        function isNumber(value) {
            return typeof value === 'number';
        }

        function isNumeric(value) {
            return isNumber(value) || isString(value) && !isNaN(value - parseFloat(value));
        }

        function isEmpty(obj) {
            return !(isArray(obj)
                ? obj.length
                : isObject(obj)
                    ? Object.keys(obj).length
                    : false
            );
        }

        function isUndefined(value) {
            return value === void 0;
        }

        function toBoolean(value) {
            return isBoolean(value)
                ? value
                : value === 'true' || value === '1' || value === ''
                    ? true
                    : value === 'false' || value === '0'
                        ? false
                        : value;
        }

        function toNumber(value) {
            var number = Number(value);
            return !isNaN(number) ? number : false;
        }

        function toFloat(value) {
            return parseFloat(value) || 0;
        }

        function toNode(element) {
            return isNode(element) || isWindow(element) || isDocument(element)
                ? element
                : isNodeCollection(element) || isJQuery(element)
                    ? element[0]
                    : isArray(element)
                        ? toNode(element[0])
                        : null;
        }

        function toNodes(element) {
            return isNode(element)
                ? [element]
                : isNodeCollection(element)
                    ? arrPrototype.slice.call(element)
                    : isArray(element)
                        ? element.map(toNode).filter(Boolean)
                        : isJQuery(element)
                            ? element.toArray()
                            : [];
        }

        function toList(value) {
            return isArray(value)
                ? value
                : isString(value)
                    ? value.split(/,(?![^(]*\))/).map(function (value) { return isNumeric(value)
                        ? toNumber(value)
                        : toBoolean(value.trim()); })
                    : [value];
        }

        function toMs(time) {
            return !time
                ? 0
                : endsWith(time, 'ms')
                    ? toFloat(time)
                    : toFloat(time) * 1000;
        }

        function isEqual(value, other) {
            return value === other
                || isObject(value)
                && isObject(other)
                && Object.keys(value).length === Object.keys(other).length
                && each(value, function (val, key) { return val === other[key]; });
        }

        function swap(value, a, b) {
            return value.replace(new RegExp((a + "|" + b), 'mg'), function (match) {
                return match === a ? b : a;
            });
        }

        var assign = Object.assign || function (target) {
            var args = [], len = arguments.length - 1;
            while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

            target = Object(target);
            for (var i = 0; i < args.length; i++) {
                var source = args[i];
                if (source !== null) {
                    for (var key in source) {
                        if (hasOwn(source, key)) {
                            target[key] = source[key];
                        }
                    }
                }
            }
            return target;
        };

        function each(obj, cb) {
            for (var key in obj) {
                if (false === cb(obj[key], key)) {
                    return false;
                }
            }
            return true;
        }

        function sortBy(array, prop) {
            return array.sort(function (ref, ref$1) {
                    var propA = ref[prop]; if ( propA === void 0 ) propA = 0;
                    var propB = ref$1[prop]; if ( propB === void 0 ) propB = 0;

                    return propA > propB
                    ? 1
                    : propB > propA
                        ? -1
                        : 0;
            }
            );
        }

        function uniqueBy(array, prop) {
            var seen = new Set();
            return array.filter(function (ref) {
                var check = ref[prop];

                return seen.has(check)
                ? false
                : seen.add(check) || true;
            } // IE 11 does not return the Set object
            );
        }

        function clamp(number, min, max) {
            if ( min === void 0 ) min = 0;
            if ( max === void 0 ) max = 1;

            return Math.min(Math.max(toNumber(number) || 0, min), max);
        }

        function noop() {}

        function intersectRect(r1, r2) {
            return r1.left < r2.right &&
                r1.right > r2.left &&
                r1.top < r2.bottom &&
                r1.bottom > r2.top;
        }

        function pointInRect(point, rect) {
            return point.x <= rect.right &&
                point.x >= rect.left &&
                point.y <= rect.bottom &&
                point.y >= rect.top;
        }

        var Dimensions = {

            ratio: function(dimensions, prop, value) {
                var obj;


                var aProp = prop === 'width' ? 'height' : 'width';

                return ( obj = {}, obj[aProp] = dimensions[prop] ? Math.round(value * dimensions[aProp] / dimensions[prop]) : dimensions[aProp], obj[prop] = value, obj );
            },

            contain: function(dimensions, maxDimensions) {
                var this$1 = this;

                dimensions = assign({}, dimensions);

                each(dimensions, function (_, prop) { return dimensions = dimensions[prop] > maxDimensions[prop]
                    ? this$1.ratio(dimensions, prop, maxDimensions[prop])
                    : dimensions; }
                );

                return dimensions;
            },

            cover: function(dimensions, maxDimensions) {
                var this$1 = this;

                dimensions = this.contain(dimensions, maxDimensions);

                each(dimensions, function (_, prop) { return dimensions = dimensions[prop] < maxDimensions[prop]
                    ? this$1.ratio(dimensions, prop, maxDimensions[prop])
                    : dimensions; }
                );

                return dimensions;
            }

        };

        function attr(element, name, value) {

            if (isObject(name)) {
                for (var key in name) {
                    attr(element, key, name[key]);
                }
                return;
            }

            if (isUndefined(value)) {
                element = toNode(element);
                return element && element.getAttribute(name);
            } else {
                toNodes(element).forEach(function (element) {

                    if (isFunction(value)) {
                        value = value.call(element, attr(element, name));
                    }

                    if (value === null) {
                        removeAttr(element, name);
                    } else {
                        element.setAttribute(name, value);
                    }
                });
            }

        }

        function hasAttr(element, name) {
            return toNodes(element).some(function (element) { return element.hasAttribute(name); });
        }

        function removeAttr(element, name) {
            element = toNodes(element);
            name.split(' ').forEach(function (name) { return element.forEach(function (element) { return element.hasAttribute(name) && element.removeAttribute(name); }
                ); }
            );
        }

        function data(element, attribute) {
            for (var i = 0, attrs = [attribute, ("data-" + attribute)]; i < attrs.length; i++) {
                if (hasAttr(element, attrs[i])) {
                    return attr(element, attrs[i]);
                }
            }
        }

        function query(selector, context) {
            return toNode(selector) || find(selector, getContext(selector, context));
        }

        function queryAll(selector, context) {
            var nodes = toNodes(selector);
            return nodes.length && nodes || findAll(selector, getContext(selector, context));
        }

        function getContext(selector, context) {
            if ( context === void 0 ) context = document;

            return isContextSelector(selector) || isDocument(context)
                ? context
                : context.ownerDocument;
        }

        function find(selector, context) {
            return toNode(_query(selector, context, 'querySelector'));
        }

        function findAll(selector, context) {
            return toNodes(_query(selector, context, 'querySelectorAll'));
        }

        function _query(selector, context, queryFn) {
            if ( context === void 0 ) context = document;


            if (!selector || !isString(selector)) {
                return null;
            }

            selector = selector.replace(contextSanitizeRe, '$1 *');

            var removes;

            if (isContextSelector(selector)) {

                removes = [];

                selector = splitSelector(selector).map(function (selector, i) {

                    var ctx = context;

                    if (selector[0] === '!') {

                        var selectors = selector.substr(1).trim().split(' ');
                        ctx = closest(context.parentNode, selectors[0]);
                        selector = selectors.slice(1).join(' ').trim();

                    }

                    if (selector[0] === '-') {

                        var selectors$1 = selector.substr(1).trim().split(' ');
                        var prev = (ctx || context).previousElementSibling;
                        ctx = matches(prev, selector.substr(1)) ? prev : null;
                        selector = selectors$1.slice(1).join(' ');

                    }

                    if (!ctx) {
                        return null;
                    }

                    if (!ctx.id) {
                        ctx.id = "uk-" + (Date.now()) + i;
                        removes.push(function () { return removeAttr(ctx, 'id'); });
                    }

                    return ("#" + (escape(ctx.id)) + " " + selector);

                }).filter(Boolean).join(',');

                context = document;

            }

            try {

                return context[queryFn](selector);

            } catch (e) {

                return null;

            } finally {

                removes && removes.forEach(function (remove) { return remove(); });

            }

        }

        var contextSelectorRe = /(^|[^\\],)\s*[!>+~-]/;
        var contextSanitizeRe = /([!>+~-])(?=\s+[!>+~-]|\s*$)/g;

        function isContextSelector(selector) {
            return isString(selector) && selector.match(contextSelectorRe);
        }

        var selectorRe = /.*?[^\\](?:,|$)/g;

        function splitSelector(selector) {
            return selector.match(selectorRe).map(function (selector) { return selector.replace(/,$/, '').trim(); });
        }

        var elProto = Element.prototype;
        var matchesFn = elProto.matches || elProto.webkitMatchesSelector || elProto.msMatchesSelector;

        function matches(element, selector) {
            return toNodes(element).some(function (element) { return matchesFn.call(element, selector); });
        }

        var closestFn = elProto.closest || function (selector) {
            var ancestor = this;

            do {

                if (matches(ancestor, selector)) {
                    return ancestor;
                }

                ancestor = ancestor.parentNode;

            } while (ancestor && ancestor.nodeType === 1);
        };

        function closest(element, selector) {

            if (startsWith(selector, '>')) {
                selector = selector.slice(1);
            }

            return isNode(element)
                ? element.parentNode && closestFn.call(element, selector)
                : toNodes(element).map(function (element) { return closest(element, selector); }).filter(Boolean);
        }

        function parents(element, selector) {
            var elements = [];
            var parent = toNode(element).parentNode;

            while (parent && parent.nodeType === 1) {

                if (matches(parent, selector)) {
                    elements.push(parent);
                }

                parent = parent.parentNode;
            }

            return elements;
        }

        var escapeFn = window.CSS && CSS.escape || function (css) { return css.replace(/([^\x7f-\uFFFF\w-])/g, function (match) { return ("\\" + match); }); };
        function escape(css) {
            return isString(css) ? escapeFn.call(null, css) : '';
        }

        var voidElements = {
            area: true,
            base: true,
            br: true,
            col: true,
            embed: true,
            hr: true,
            img: true,
            input: true,
            keygen: true,
            link: true,
            menuitem: true,
            meta: true,
            param: true,
            source: true,
            track: true,
            wbr: true
        };
        function isVoidElement(element) {
            return toNodes(element).some(function (element) { return voidElements[element.tagName.toLowerCase()]; });
        }

        function isVisible(element) {
            return toNodes(element).some(function (element) { return element.offsetWidth || element.offsetHeight || element.getClientRects().length; });
        }

        var selInput = 'input,select,textarea,button';
        function isInput(element) {
            return toNodes(element).some(function (element) { return matches(element, selInput); });
        }

        function filter(element, selector) {
            return toNodes(element).filter(function (element) { return matches(element, selector); });
        }

        function within(element, selector) {
            return !isString(selector)
                ? element === selector || (isDocument(selector)
                    ? selector.documentElement
                    : toNode(selector)).contains(toNode(element)) // IE 11 document does not implement contains
                : matches(element, selector) || closest(element, selector);
        }

        function on() {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];


            var ref = getArgs(args);
            var targets = ref[0];
            var type = ref[1];
            var selector = ref[2];
            var listener = ref[3];
            var useCapture = ref[4];

            targets = toEventTargets(targets);

            if (selector) {
                listener = delegate(targets, selector, listener);
            }

            if (listener.length > 1) {
                listener = detail(listener);
            }

            type.split(' ').forEach(function (type) { return targets.forEach(function (target) { return target.addEventListener(type, listener, useCapture); }
                ); }
            );
            return function () { return off(targets, type, listener, useCapture); };
        }

        function off(targets, type, listener, useCapture) {
            if ( useCapture === void 0 ) useCapture = false;

            targets = toEventTargets(targets);
            type.split(' ').forEach(function (type) { return targets.forEach(function (target) { return target.removeEventListener(type, listener, useCapture); }
                ); }
            );
        }

        function once() {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];


            var ref = getArgs(args);
            var element = ref[0];
            var type = ref[1];
            var selector = ref[2];
            var listener = ref[3];
            var useCapture = ref[4];
            var condition = ref[5];
            var off = on(element, type, selector, function (e) {
                var result = !condition || condition(e);
                if (result) {
                    off();
                    listener(e, result);
                }
            }, useCapture);

            return off;
        }

        function trigger(targets, event, detail) {
            return toEventTargets(targets).reduce(function (notCanceled, target) { return notCanceled && target.dispatchEvent(createEvent(event, true, true, detail)); }
                , true);
        }

        function createEvent(e, bubbles, cancelable, detail) {
            if ( bubbles === void 0 ) bubbles = true;
            if ( cancelable === void 0 ) cancelable = false;

            if (isString(e)) {
                var event = document.createEvent('CustomEvent'); // IE 11
                event.initCustomEvent(e, bubbles, cancelable, detail);
                e = event;
            }

            return e;
        }

        function getArgs(args) {
            if (isFunction(args[2])) {
                args.splice(2, 0, false);
            }
            return args;
        }

        function delegate(delegates, selector, listener) {
            var this$1 = this;

            return function (e) {

                delegates.forEach(function (delegate) {

                    var current = selector[0] === '>'
                        ? findAll(selector, delegate).reverse().filter(function (element) { return within(e.target, element); })[0]
                        : closest(e.target, selector);

                    if (current) {
                        e.delegate = delegate;
                        e.current = current;

                        listener.call(this$1, e);
                    }

                });

            };
        }

        function detail(listener) {
            return function (e) { return isArray(e.detail) ? listener.apply(void 0, [e].concat(e.detail)) : listener(e); };
        }

        function isEventTarget(target) {
            return target && 'addEventListener' in target;
        }

        function toEventTarget(target) {
            return isEventTarget(target) ? target : toNode(target);
        }

        function toEventTargets(target) {
            return isArray(target)
                    ? target.map(toEventTarget).filter(Boolean)
                    : isString(target)
                        ? findAll(target)
                        : isEventTarget(target)
                            ? [target]
                            : toNodes(target);
        }

        function isTouch(e) {
            return e.pointerType === 'touch' || e.touches;
        }

        function getEventPos(e, prop) {
            if ( prop === void 0 ) prop = 'client';

            var touches = e.touches;
            var changedTouches = e.changedTouches;
            var ref = touches && touches[0] || changedTouches && changedTouches[0] || e;
            var x = ref[(prop + "X")];
            var y = ref[(prop + "Y")];

            return {x: x, y: y};
        }

        /* global setImmediate */

        var Promise = 'Promise' in window ? window.Promise : PromiseFn;

        var Deferred = function() {
            var this$1 = this;

            this.promise = new Promise(function (resolve, reject) {
                this$1.reject = reject;
                this$1.resolve = resolve;
            });
        };

        /**
         * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)
         */

        var RESOLVED = 0;
        var REJECTED = 1;
        var PENDING = 2;

        var async = 'setImmediate' in window ? setImmediate : setTimeout;

        function PromiseFn(executor) {

            this.state = PENDING;
            this.value = undefined;
            this.deferred = [];

            var promise = this;

            try {
                executor(
                    function (x) {
                        promise.resolve(x);
                    },
                    function (r) {
                        promise.reject(r);
                    }
                );
            } catch (e) {
                promise.reject(e);
            }
        }

        PromiseFn.reject = function (r) {
            return new PromiseFn(function (resolve, reject) {
                reject(r);
            });
        };

        PromiseFn.resolve = function (x) {
            return new PromiseFn(function (resolve, reject) {
                resolve(x);
            });
        };

        PromiseFn.all = function all(iterable) {
            return new PromiseFn(function (resolve, reject) {
                var result = [];
                var count = 0;

                if (iterable.length === 0) {
                    resolve(result);
                }

                function resolver(i) {
                    return function (x) {
                        result[i] = x;
                        count += 1;

                        if (count === iterable.length) {
                            resolve(result);
                        }
                    };
                }

                for (var i = 0; i < iterable.length; i += 1) {
                    PromiseFn.resolve(iterable[i]).then(resolver(i), reject);
                }
            });
        };

        PromiseFn.race = function race(iterable) {
            return new PromiseFn(function (resolve, reject) {
                for (var i = 0; i < iterable.length; i += 1) {
                    PromiseFn.resolve(iterable[i]).then(resolve, reject);
                }
            });
        };

        var p = PromiseFn.prototype;

        p.resolve = function resolve(x) {
            var promise = this;

            if (promise.state === PENDING) {
                if (x === promise) {
                    throw new TypeError('Promise settled with itself.');
                }

                var called = false;

                try {
                    var then = x && x.then;

                    if (x !== null && isObject(x) && isFunction(then)) {
                        then.call(
                            x,
                            function (x) {
                                if (!called) {
                                    promise.resolve(x);
                                }
                                called = true;
                            },
                            function (r) {
                                if (!called) {
                                    promise.reject(r);
                                }
                                called = true;
                            }
                        );
                        return;
                    }
                } catch (e) {
                    if (!called) {
                        promise.reject(e);
                    }
                    return;
                }

                promise.state = RESOLVED;
                promise.value = x;
                promise.notify();
            }
        };

        p.reject = function reject(reason) {
            var promise = this;

            if (promise.state === PENDING) {
                if (reason === promise) {
                    throw new TypeError('Promise settled with itself.');
                }

                promise.state = REJECTED;
                promise.value = reason;
                promise.notify();
            }
        };

        p.notify = function notify() {
            var this$1 = this;

            async(function () {
                if (this$1.state !== PENDING) {
                    while (this$1.deferred.length) {
                        var ref = this$1.deferred.shift();
                        var onResolved = ref[0];
                        var onRejected = ref[1];
                        var resolve = ref[2];
                        var reject = ref[3];

                        try {
                            if (this$1.state === RESOLVED) {
                                if (isFunction(onResolved)) {
                                    resolve(onResolved.call(undefined, this$1.value));
                                } else {
                                    resolve(this$1.value);
                                }
                            } else if (this$1.state === REJECTED) {
                                if (isFunction(onRejected)) {
                                    resolve(onRejected.call(undefined, this$1.value));
                                } else {
                                    reject(this$1.value);
                                }
                            }
                        } catch (e) {
                            reject(e);
                        }
                    }
                }
            });
        };

        p.then = function then(onResolved, onRejected) {
            var this$1 = this;

            return new PromiseFn(function (resolve, reject) {
                this$1.deferred.push([onResolved, onRejected, resolve, reject]);
                this$1.notify();
            });
        };

        p.catch = function (onRejected) {
            return this.then(undefined, onRejected);
        };

        function ajax(url, options) {
            return new Promise(function (resolve, reject) {

                var env = assign({
                    data: null,
                    method: 'GET',
                    headers: {},
                    xhr: new XMLHttpRequest(),
                    beforeSend: noop,
                    responseType: ''
                }, options);

                env.beforeSend(env);

                var xhr = env.xhr;

                for (var prop in env) {
                    if (prop in xhr) {
                        try {

                            xhr[prop] = env[prop];

                        } catch (e) {}
                    }
                }

                xhr.open(env.method.toUpperCase(), url);

                for (var header in env.headers) {
                    xhr.setRequestHeader(header, env.headers[header]);
                }

                on(xhr, 'load', function () {

                    if (xhr.status === 0 || xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {
                        resolve(xhr);
                    } else {
                        reject(assign(Error(xhr.statusText), {
                            xhr: xhr,
                            status: xhr.status
                        }));
                    }

                });

                on(xhr, 'error', function () { return reject(assign(Error('Network Error'), {xhr: xhr})); });
                on(xhr, 'timeout', function () { return reject(assign(Error('Network Timeout'), {xhr: xhr})); });

                xhr.send(env.data);
            });
        }

        function getImage(src, srcset, sizes) {

            return new Promise(function (resolve, reject) {
                var img = new Image();

                img.onerror = reject;
                img.onload = function () { return resolve(img); };

                sizes && (img.sizes = sizes);
                srcset && (img.srcset = srcset);
                img.src = src;
            });

        }

        /* global DocumentTouch */

        var isIE = /msie|trident/i.test(window.navigator.userAgent);
        var isRtl = attr(document.documentElement, 'dir') === 'rtl';

        var hasTouchEvents = 'ontouchstart' in window;
        var hasPointerEvents = window.PointerEvent;
        var hasTouch = hasTouchEvents
            || window.DocumentTouch && document instanceof DocumentTouch
            || navigator.maxTouchPoints; // IE >=11

        var pointerDown = hasPointerEvents ? 'pointerdown' : hasTouchEvents ? 'touchstart' : 'mousedown';
        var pointerMove = hasPointerEvents ? 'pointermove' : hasTouchEvents ? 'touchmove' : 'mousemove';
        var pointerUp = hasPointerEvents ? 'pointerup' : hasTouchEvents ? 'touchend' : 'mouseup';
        var pointerEnter = hasPointerEvents ? 'pointerenter' : hasTouchEvents ? '' : 'mouseenter';
        var pointerLeave = hasPointerEvents ? 'pointerleave' : hasTouchEvents ? '' : 'mouseleave';
        var pointerCancel = hasPointerEvents ? 'pointercancel' : 'touchcancel';

        function ready(fn) {

            if (document.readyState !== 'loading') {
                fn();
                return;
            }

            var unbind = on(document, 'DOMContentLoaded', function () {
                unbind();
                fn();
            });
        }

        function index(element, ref) {
            return ref
                ? toNodes(element).indexOf(toNode(ref))
                : toNodes((element = toNode(element)) && element.parentNode.children).indexOf(element);
        }

        function getIndex(i, elements, current, finite) {
            if ( current === void 0 ) current = 0;
            if ( finite === void 0 ) finite = false;


            elements = toNodes(elements);

            var length = elements.length;

            i = isNumeric(i)
                ? toNumber(i)
                : i === 'next'
                    ? current + 1
                    : i === 'previous'
                        ? current - 1
                        : index(elements, i);

            if (finite) {
                return clamp(i, 0, length - 1);
            }

            i %= length;

            return i < 0 ? i + length : i;
        }

        function empty(element) {
            element = $(element);
            element.innerHTML = '';
            return element;
        }

        function html(parent, html) {
            parent = $(parent);
            return isUndefined(html)
                ? parent.innerHTML
                : append(parent.hasChildNodes() ? empty(parent) : parent, html);
        }

        function prepend(parent, element) {

            parent = $(parent);

            if (!parent.hasChildNodes()) {
                return append(parent, element);
            } else {
                return insertNodes(element, function (element) { return parent.insertBefore(element, parent.firstChild); });
            }
        }

        function append(parent, element) {
            parent = $(parent);
            return insertNodes(element, function (element) { return parent.appendChild(element); });
        }

        function before(ref, element) {
            ref = $(ref);
            return insertNodes(element, function (element) { return ref.parentNode.insertBefore(element, ref); });
        }

        function after(ref, element) {
            ref = $(ref);
            return insertNodes(element, function (element) { return ref.nextSibling
                ? before(ref.nextSibling, element)
                : append(ref.parentNode, element); }
            );
        }

        function insertNodes(element, fn) {
            element = isString(element) ? fragment(element) : element;
            return element
                ? 'length' in element
                    ? toNodes(element).map(fn)
                    : fn(element)
                : null;
        }

        function remove(element) {
            toNodes(element).map(function (element) { return element.parentNode && element.parentNode.removeChild(element); });
        }

        function wrapAll(element, structure) {

            structure = toNode(before(element, structure));

            while (structure.firstChild) {
                structure = structure.firstChild;
            }

            append(structure, element);

            return structure;
        }

        function wrapInner(element, structure) {
            return toNodes(toNodes(element).map(function (element) { return element.hasChildNodes ? wrapAll(toNodes(element.childNodes), structure) : append(element, structure); }
            ));
        }

        function unwrap(element) {
            toNodes(element)
                .map(function (element) { return element.parentNode; })
                .filter(function (value, index, self) { return self.indexOf(value) === index; })
                .forEach(function (parent) {
                    before(parent, parent.childNodes);
                    remove(parent);
                });
        }

        var fragmentRe = /^\s*<(\w+|!)[^>]*>/;
        var singleTagRe = /^<(\w+)\s*\/?>(?:<\/\1>)?$/;

        function fragment(html) {

            var matches = singleTagRe.exec(html);
            if (matches) {
                return document.createElement(matches[1]);
            }

            var container = document.createElement('div');
            if (fragmentRe.test(html)) {
                container.insertAdjacentHTML('beforeend', html.trim());
            } else {
                container.textContent = html;
            }

            return container.childNodes.length > 1 ? toNodes(container.childNodes) : container.firstChild;

        }

        function apply(node, fn) {

            if (!node || node.nodeType !== 1) {
                return;
            }

            fn(node);
            node = node.firstElementChild;
            while (node) {
                apply(node, fn);
                node = node.nextElementSibling;
            }
        }

        function $(selector, context) {
            return !isString(selector)
                ? toNode(selector)
                : isHtml(selector)
                    ? toNode(fragment(selector))
                    : find(selector, context);
        }

        function $$(selector, context) {
            return !isString(selector)
                ? toNodes(selector)
                : isHtml(selector)
                    ? toNodes(fragment(selector))
                    : findAll(selector, context);
        }

        function isHtml(str) {
            return str[0] === '<' || str.match(/^\s*</);
        }

        function addClass(element) {
            var args = [], len = arguments.length - 1;
            while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

            apply$1(element, args, 'add');
        }

        function removeClass(element) {
            var args = [], len = arguments.length - 1;
            while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

            apply$1(element, args, 'remove');
        }

        function removeClasses(element, cls) {
            attr(element, 'class', function (value) { return (value || '').replace(new RegExp(("\\b" + cls + "\\b"), 'g'), ''); });
        }

        function replaceClass(element) {
            var args = [], len = arguments.length - 1;
            while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

            args[0] && removeClass(element, args[0]);
            args[1] && addClass(element, args[1]);
        }

        function hasClass(element, cls) {
            return cls && toNodes(element).some(function (element) { return element.classList.contains(cls.split(' ')[0]); });
        }

        function toggleClass(element) {
            var args = [], len = arguments.length - 1;
            while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];


            if (!args.length) {
                return;
            }

            args = getArgs$1(args);

            var force = !isString(args[args.length - 1]) ? args.pop() : []; // in iOS 9.3 force === undefined evaluates to false

            args = args.filter(Boolean);

            toNodes(element).forEach(function (ref) {
                var classList = ref.classList;

                for (var i = 0; i < args.length; i++) {
                    supports.Force
                        ? classList.toggle.apply(classList, [args[i]].concat(force))
                        : (classList[(!isUndefined(force) ? force : !classList.contains(args[i])) ? 'add' : 'remove'](args[i]));
                }
            });

        }

        function apply$1(element, args, fn) {
            args = getArgs$1(args).filter(Boolean);

            args.length && toNodes(element).forEach(function (ref) {
                var classList = ref.classList;

                supports.Multiple
                    ? classList[fn].apply(classList, args)
                    : args.forEach(function (cls) { return classList[fn](cls); });
            });
        }

        function getArgs$1(args) {
            return args.reduce(function (args, arg) { return args.concat.call(args, isString(arg) && includes(arg, ' ') ? arg.trim().split(' ') : arg); }
                , []);
        }

        // IE 11
        var supports = {

            get Multiple() {
                return this.get('_multiple');
            },

            get Force() {
                return this.get('_force');
            },

            get: function(key) {

                if (!hasOwn(this, key)) {
                    var ref = document.createElement('_');
                    var classList = ref.classList;
                    classList.add('a', 'b');
                    classList.toggle('c', false);
                    this._multiple = classList.contains('b');
                    this._force = !classList.contains('c');
                }

                return this[key];
            }

        };

        var cssNumber = {
            'animation-iteration-count': true,
            'column-count': true,
            'fill-opacity': true,
            'flex-grow': true,
            'flex-shrink': true,
            'font-weight': true,
            'line-height': true,
            'opacity': true,
            'order': true,
            'orphans': true,
            'stroke-dasharray': true,
            'stroke-dashoffset': true,
            'widows': true,
            'z-index': true,
            'zoom': true
        };

        function css(element, property, value) {

            return toNodes(element).map(function (element) {

                if (isString(property)) {

                    property = propName(property);

                    if (isUndefined(value)) {
                        return getStyle(element, property);
                    } else if (!value && !isNumber(value)) {
                        element.style.removeProperty(property);
                    } else {
                        element.style[property] = isNumeric(value) && !cssNumber[property] ? (value + "px") : value;
                    }

                } else if (isArray(property)) {

                    var styles = getStyles(element);

                    return property.reduce(function (props, property) {
                        props[property] = styles[propName(property)];
                        return props;
                    }, {});

                } else if (isObject(property)) {
                    each(property, function (value, property) { return css(element, property, value); });
                }

                return element;

            })[0];

        }

        function getStyles(element, pseudoElt) {
            element = toNode(element);
            return element.ownerDocument.defaultView.getComputedStyle(element, pseudoElt);
        }

        function getStyle(element, property, pseudoElt) {
            return getStyles(element, pseudoElt)[property];
        }

        var vars = {};

        function getCssVar(name) {

            var docEl = document.documentElement;

            if (!isIE) {
                return getStyles(docEl).getPropertyValue(("--uk-" + name));
            }

            if (!(name in vars)) {

                /* usage in css: .uk-name:before { content:"xyz" } */

                var element = append(docEl, document.createElement('div'));

                addClass(element, ("uk-" + name));

                vars[name] = getStyle(element, 'content', ':before').replace(/^["'](.*)["']$/, '$1');

                remove(element);

            }

            return vars[name];

        }

        var cssProps = {};

        function propName(name) {

            var ret = cssProps[name];
            if (!ret) {
                ret = cssProps[name] = vendorPropName(name) || name;
            }
            return ret;
        }

        var cssPrefixes = ['webkit', 'moz', 'ms'];

        function vendorPropName(name) {

            name = hyphenate(name);

            var ref = document.documentElement;
            var style = ref.style;

            if (name in style) {
                return name;
            }

            var i = cssPrefixes.length, prefixedName;

            while (i--) {
                prefixedName = "-" + (cssPrefixes[i]) + "-" + name;
                if (prefixedName in style) {
                    return prefixedName;
                }
            }
        }

        function transition(element, props, duration, timing) {
            if ( duration === void 0 ) duration = 400;
            if ( timing === void 0 ) timing = 'linear';


            return Promise.all(toNodes(element).map(function (element) { return new Promise(function (resolve, reject) {

                    for (var name in props) {
                        var value = css(element, name);
                        if (value === '') {
                            css(element, name, value);
                        }
                    }

                    var timer = setTimeout(function () { return trigger(element, 'transitionend'); }, duration);

                    once(element, 'transitionend transitioncanceled', function (ref) {
                        var type = ref.type;

                        clearTimeout(timer);
                        removeClass(element, 'uk-transition');
                        css(element, {
                            'transition-property': '',
                            'transition-duration': '',
                            'transition-timing-function': ''
                        });
                        type === 'transitioncanceled' ? reject() : resolve();
                    }, false, function (ref) {
                        var target = ref.target;

                        return element === target;
                    });

                    addClass(element, 'uk-transition');
                    css(element, assign({
                        'transition-property': Object.keys(props).map(propName).join(','),
                        'transition-duration': (duration + "ms"),
                        'transition-timing-function': timing
                    }, props));

                }); }
            ));

        }

        var Transition = {

            start: transition,

            stop: function(element) {
                trigger(element, 'transitionend');
                return Promise.resolve();
            },

            cancel: function(element) {
                trigger(element, 'transitioncanceled');
            },

            inProgress: function(element) {
                return hasClass(element, 'uk-transition');
            }

        };

        var animationPrefix = 'uk-animation-';
        var clsCancelAnimation = 'uk-cancel-animation';

        function animate(element, animation, duration, origin, out) {
            var arguments$1 = arguments;
            if ( duration === void 0 ) duration = 200;


            return Promise.all(toNodes(element).map(function (element) { return new Promise(function (resolve, reject) {

                    if (hasClass(element, clsCancelAnimation)) {
                        requestAnimationFrame(function () { return Promise.resolve().then(function () { return animate.apply(void 0, arguments$1).then(resolve, reject); }
                            ); }
                        );
                        return;
                    }

                    var cls = animation + " " + animationPrefix + (out ? 'leave' : 'enter');

                    if (startsWith(animation, animationPrefix)) {

                        if (origin) {
                            cls += " uk-transform-origin-" + origin;
                        }

                        if (out) {
                            cls += " " + animationPrefix + "reverse";
                        }

                    }

                    reset();

                    once(element, 'animationend animationcancel', function (ref) {
                        var type = ref.type;


                        var hasReset = false;

                        if (type === 'animationcancel') {
                            reject();
                            reset();
                        } else {
                            resolve();
                            Promise.resolve().then(function () {
                                hasReset = true;
                                reset();
                            });
                        }

                        requestAnimationFrame(function () {
                            if (!hasReset) {
                                addClass(element, clsCancelAnimation);

                                requestAnimationFrame(function () { return removeClass(element, clsCancelAnimation); });
                            }
                        });

                    }, false, function (ref) {
                        var target = ref.target;

                        return element === target;
                    });

                    css(element, 'animationDuration', (duration + "ms"));
                    addClass(element, cls);

                    function reset() {
                        css(element, 'animationDuration', '');
                        removeClasses(element, (animationPrefix + "\\S*"));
                    }

                }); }
            ));

        }

        var inProgress = new RegExp((animationPrefix + "(enter|leave)"));
        var Animation = {

            in: function(element, animation, duration, origin) {
                return animate(element, animation, duration, origin, false);
            },

            out: function(element, animation, duration, origin) {
                return animate(element, animation, duration, origin, true);
            },

            inProgress: function(element) {
                return inProgress.test(attr(element, 'class'));
            },

            cancel: function(element) {
                trigger(element, 'animationcancel');
            }

        };

        var dirs = {
            width: ['x', 'left', 'right'],
            height: ['y', 'top', 'bottom']
        };

        function positionAt(element, target, elAttach, targetAttach, elOffset, targetOffset, flip, boundary) {

            elAttach = getPos(elAttach);
            targetAttach = getPos(targetAttach);

            var flipped = {element: elAttach, target: targetAttach};

            if (!element || !target) {
                return flipped;
            }

            var dim = getDimensions(element);
            var targetDim = getDimensions(target);
            var position = targetDim;

            moveTo(position, elAttach, dim, -1);
            moveTo(position, targetAttach, targetDim, 1);

            elOffset = getOffsets(elOffset, dim.width, dim.height);
            targetOffset = getOffsets(targetOffset, targetDim.width, targetDim.height);

            elOffset['x'] += targetOffset['x'];
            elOffset['y'] += targetOffset['y'];

            position.left += elOffset['x'];
            position.top += elOffset['y'];

            if (flip) {

                var boundaries = [getDimensions(getWindow(element))];

                if (boundary) {
                    boundaries.unshift(getDimensions(boundary));
                }

                each(dirs, function (ref, prop) {
                    var dir = ref[0];
                    var align = ref[1];
                    var alignFlip = ref[2];


                    if (!(flip === true || includes(flip, dir))) {
                        return;
                    }

                    boundaries.some(function (boundary) {

                        var elemOffset = elAttach[dir] === align
                            ? -dim[prop]
                            : elAttach[dir] === alignFlip
                                ? dim[prop]
                                : 0;

                        var targetOffset = targetAttach[dir] === align
                            ? targetDim[prop]
                            : targetAttach[dir] === alignFlip
                                ? -targetDim[prop]
                                : 0;

                        if (position[align] < boundary[align] || position[align] + dim[prop] > boundary[alignFlip]) {

                            var centerOffset = dim[prop] / 2;
                            var centerTargetOffset = targetAttach[dir] === 'center' ? -targetDim[prop] / 2 : 0;

                            return elAttach[dir] === 'center' && (
                                apply(centerOffset, centerTargetOffset)
                                || apply(-centerOffset, -centerTargetOffset)
                            ) || apply(elemOffset, targetOffset);

                        }

                        function apply(elemOffset, targetOffset) {

                            var newVal = position[align] + elemOffset + targetOffset - elOffset[dir] * 2;

                            if (newVal >= boundary[align] && newVal + dim[prop] <= boundary[alignFlip]) {
                                position[align] = newVal;

                                ['element', 'target'].forEach(function (el) {
                                    flipped[el][dir] = !elemOffset
                                        ? flipped[el][dir]
                                        : flipped[el][dir] === dirs[prop][1]
                                            ? dirs[prop][2]
                                            : dirs[prop][1];
                                });

                                return true;
                            }

                        }

                    });

                });
            }

            offset(element, position);

            return flipped;
        }

        function offset(element, coordinates) {

            element = toNode(element);

            if (coordinates) {

                var currentOffset = offset(element);
                var pos = css(element, 'position');

                ['left', 'top'].forEach(function (prop) {
                    if (prop in coordinates) {
                        var value = css(element, prop);
                        css(element, prop, coordinates[prop] - currentOffset[prop]
                            + toFloat(pos === 'absolute' && value === 'auto'
                                ? position(element)[prop]
                                : value)
                        );
                    }
                });

                return;
            }

            return getDimensions(element);
        }

        function getDimensions(element) {

            element = toNode(element);

            var ref = getWindow(element);
            var top = ref.pageYOffset;
            var left = ref.pageXOffset;

            if (isWindow(element)) {

                var height = element.innerHeight;
                var width = element.innerWidth;

                return {
                    top: top,
                    left: left,
                    height: height,
                    width: width,
                    bottom: top + height,
                    right: left + width
                };
            }

            var style, hidden;

            if (!isVisible(element) && css(element, 'display') === 'none') {

                style = attr(element, 'style');
                hidden = attr(element, 'hidden');

                attr(element, {
                    style: ((style || '') + ";display:block !important;"),
                    hidden: null
                });
            }

            var rect = element.getBoundingClientRect();

            if (!isUndefined(style)) {
                attr(element, {style: style, hidden: hidden});
            }

            return {
                height: rect.height,
                width: rect.width,
                top: rect.top + top,
                left: rect.left + left,
                bottom: rect.bottom + top,
                right: rect.right + left
            };
        }

        function position(element) {
            element = toNode(element);

            var parent = element.offsetParent || getDocEl(element);
            var parentOffset = offset(parent);
            var ref = ['top', 'left'].reduce(function (props, prop) {
                var propName = ucfirst(prop);
                props[prop] -= parentOffset[prop]
                    + toFloat(css(element, ("margin" + propName)))
                    + toFloat(css(parent, ("border" + propName + "Width")));
                return props;
            }, offset(element));
            var top = ref.top;
            var left = ref.left;

            return {top: top, left: left};
        }

        var height = dimension('height');
        var width = dimension('width');

        function dimension(prop) {
            var propName = ucfirst(prop);
            return function (element, value) {

                element = toNode(element);

                if (isUndefined(value)) {

                    if (isWindow(element)) {
                        return element[("inner" + propName)];
                    }

                    if (isDocument(element)) {
                        var doc = element.documentElement;
                        return Math.max(doc[("offset" + propName)], doc[("scroll" + propName)]);
                    }

                    value = css(element, prop);
                    value = value === 'auto' ? element[("offset" + propName)] : toFloat(value) || 0;

                    return value - boxModelAdjust(prop, element);

                } else {

                    css(element, prop, !value && value !== 0
                        ? ''
                        : +value + boxModelAdjust(prop, element) + 'px'
                    );

                }

            };
        }

        function boxModelAdjust(prop, element, sizing) {
            if ( sizing === void 0 ) sizing = 'border-box';

            return css(element, 'boxSizing') === sizing
                ? dirs[prop].slice(1).map(ucfirst).reduce(function (value, prop) { return value
                    + toFloat(css(element, ("padding" + prop)))
                    + toFloat(css(element, ("border" + prop + "Width"))); }
                    , 0)
                : 0;
        }

        function moveTo(position, attach, dim, factor) {
            each(dirs, function (ref, prop) {
                var dir = ref[0];
                var align = ref[1];
                var alignFlip = ref[2];

                if (attach[dir] === alignFlip) {
                    position[align] += dim[prop] * factor;
                } else if (attach[dir] === 'center') {
                    position[align] += dim[prop] * factor / 2;
                }
            });
        }

        function getPos(pos) {

            var x = /left|center|right/;
            var y = /top|center|bottom/;

            pos = (pos || '').split(' ');

            if (pos.length === 1) {
                pos = x.test(pos[0])
                    ? pos.concat(['center'])
                    : y.test(pos[0])
                        ? ['center'].concat(pos)
                        : ['center', 'center'];
            }

            return {
                x: x.test(pos[0]) ? pos[0] : 'center',
                y: y.test(pos[1]) ? pos[1] : 'center'
            };
        }

        function getOffsets(offsets, width, height) {

            var ref = (offsets || '').split(' ');
            var x = ref[0];
            var y = ref[1];

            return {
                x: x ? toFloat(x) * (endsWith(x, '%') ? width / 100 : 1) : 0,
                y: y ? toFloat(y) * (endsWith(y, '%') ? height / 100 : 1) : 0
            };
        }

        function flipPosition(pos) {
            switch (pos) {
                case 'left':
                    return 'right';
                case 'right':
                    return 'left';
                case 'top':
                    return 'bottom';
                case 'bottom':
                    return 'top';
                default:
                    return pos;
            }
        }

        function isInView(element, topOffset, leftOffset) {
            if ( topOffset === void 0 ) topOffset = 0;
            if ( leftOffset === void 0 ) leftOffset = 0;


            if (!isVisible(element)) {
                return false;
            }

            element = toNode(element);

            var win = getWindow(element);
            var client = element.getBoundingClientRect();
            var bounding = {
                top: -topOffset,
                left: -leftOffset,
                bottom: topOffset + height(win),
                right: leftOffset + width(win)
            };

            return intersectRect(client, bounding) || pointInRect({x: client.left, y: client.top}, bounding);

        }

        function scrolledOver(element, heightOffset) {
            if ( heightOffset === void 0 ) heightOffset = 0;


            if (!isVisible(element)) {
                return 0;
            }

            element = toNode(element);

            var win = getWindow(element);
            var doc = getDocument(element);
            var elHeight = element.offsetHeight + heightOffset;
            var ref = offsetPosition(element);
            var top = ref[0];
            var vp = height(win);
            var vh = vp + Math.min(0, top - vp);
            var diff = Math.max(0, vp - (height(doc) + heightOffset - (top + elHeight)));

            return clamp(((vh + win.pageYOffset - top) / ((vh + (elHeight - (diff < vp ? diff : 0))) / 100)) / 100);
        }

        function scrollTop(element, top) {
            element = toNode(element);

            if (isWindow(element) || isDocument(element)) {
                var ref = getWindow(element);
                var scrollTo = ref.scrollTo;
                var pageXOffset = ref.pageXOffset;
                scrollTo(pageXOffset, top);
            } else {
                element.scrollTop = top;
            }
        }

        function offsetPosition(element) {
            var offset = [0, 0];

            do {

                offset[0] += element.offsetTop;
                offset[1] += element.offsetLeft;

                if (css(element, 'position') === 'fixed') {
                    var win = getWindow(element);
                    offset[0] += win.pageYOffset;
                    offset[1] += win.pageXOffset;
                    return offset;
                }

            } while ((element = element.offsetParent));

            return offset;
        }

        function toPx(value, property, element) {
            if ( property === void 0 ) property = 'width';
            if ( element === void 0 ) element = window;

            return isNumeric(value)
                ? +value
                : endsWith(value, 'vh')
                    ? percent(height(getWindow(element)), value)
                    : endsWith(value, 'vw')
                        ? percent(width(getWindow(element)), value)
                        : endsWith(value, '%')
                            ? percent(getDimensions(element)[property], value)
                            : toFloat(value);
        }

        function percent(base, value) {
            return base * toFloat(value) / 100;
        }

        function getWindow(element) {
            return isWindow(element) ? element : getDocument(element).defaultView;
        }

        function getDocument(element) {
            return toNode(element).ownerDocument;
        }

        function getDocEl(element) {
            return getDocument(element).documentElement;
        }

        /*
            Based on:
            Copyright (c) 2016 Wilson Page wilsonpage@me.com
            https://github.com/wilsonpage/fastdom
        */

        var fastdom = {

            reads: [],
            writes: [],

            read: function(task) {
                this.reads.push(task);
                scheduleFlush();
                return task;
            },

            write: function(task) {
                this.writes.push(task);
                scheduleFlush();
                return task;
            },

            clear: function(task) {
                return remove$1(this.reads, task) || remove$1(this.writes, task);
            },

            flush: flush

        };

        function flush() {
            runTasks(fastdom.reads);
            runTasks(fastdom.writes.splice(0, fastdom.writes.length));

            fastdom.scheduled = false;

            if (fastdom.reads.length || fastdom.writes.length) {
                scheduleFlush(true);
            }
        }

        function scheduleFlush(microtask) {
            if ( microtask === void 0 ) microtask = false;

            if (!fastdom.scheduled) {
                fastdom.scheduled = true;
                if (microtask) {
                    Promise.resolve().then(flush);
                } else {
                    requestAnimationFrame(flush);
                }
            }
        }

        function runTasks(tasks) {
            var task;
            while ((task = tasks.shift())) {
                task();
            }
        }

        function remove$1(array, item) {
            var index = array.indexOf(item);
            return !!~index && !!array.splice(index, 1);
        }

        function MouseTracker() {}

        MouseTracker.prototype = {

            positions: [],
            position: null,

            init: function() {
                var this$1 = this;


                this.positions = [];
                this.position = null;

                var ticking = false;
                this.unbind = on(document, 'mousemove', function (e) {

                    if (ticking) {
                        return;
                    }

                    setTimeout(function () {

                        var time = Date.now();
                        var ref = this$1.positions;
                        var length = ref.length;

                        if (length && (time - this$1.positions[length - 1].time > 100)) {
                            this$1.positions.splice(0, length);
                        }

                        this$1.positions.push({time: time, x: e.pageX, y: e.pageY});

                        if (this$1.positions.length > 5) {
                            this$1.positions.shift();
                        }

                        ticking = false;
                    }, 5);

                    ticking = true;
                });

            },

            cancel: function() {
                if (this.unbind) {
                    this.unbind();
                }
            },

            movesTo: function(target) {

                if (this.positions.length < 2) {
                    return false;
                }

                var p = offset(target);
                var position = this.positions[this.positions.length - 1];
                var ref = this.positions;
                var prevPos = ref[0];

                if (p.left <= position.x && position.x <= p.right && p.top <= position.y && position.y <= p.bottom) {
                    return false;
                }

                var points = [
                    [{x: p.left, y: p.top}, {x: p.right, y: p.bottom}],
                    [{x: p.right, y: p.top}, {x: p.left, y: p.bottom}]
                ];

                if (p.right <= position.x) ; else if (p.left >= position.x) {
                    points[0].reverse();
                    points[1].reverse();
                } else if (p.bottom <= position.y) {
                    points[0].reverse();
                } else if (p.top >= position.y) {
                    points[1].reverse();
                }

                return !!points.reduce(function (result, point) {
                    return result + (slope(prevPos, point[0]) < slope(position, point[0]) && slope(prevPos, point[1]) > slope(position, point[1]));
                }, 0);
            }

        };

        function slope(a, b) {
            return (b.y - a.y) / (b.x - a.x);
        }

        var strats = {};

        strats.events =
        strats.created =
        strats.beforeConnect =
        strats.connected =
        strats.beforeDisconnect =
        strats.disconnected =
        strats.destroy = concatStrat;

        // args strategy
        strats.args = function (parentVal, childVal) {
            return childVal !== false && concatStrat(childVal || parentVal);
        };

        // update strategy
        strats.update = function (parentVal, childVal) {
            return sortBy(concatStrat(parentVal, isFunction(childVal) ? {read: childVal} : childVal), 'order');
        };

        // property strategy
        strats.props = function (parentVal, childVal) {

            if (isArray(childVal)) {
                childVal = childVal.reduce(function (value, key) {
                    value[key] = String;
                    return value;
                }, {});
            }

            return strats.methods(parentVal, childVal);
        };

        // extend strategy
        strats.computed =
        strats.methods = function (parentVal, childVal) {
            return childVal
                ? parentVal
                    ? assign({}, parentVal, childVal)
                    : childVal
                : parentVal;
        };

        // data strategy
        strats.data = function (parentVal, childVal, vm) {

            if (!vm) {

                if (!childVal) {
                    return parentVal;
                }

                if (!parentVal) {
                    return childVal;
                }

                return function (vm) {
                    return mergeFnData(parentVal, childVal, vm);
                };

            }

            return mergeFnData(parentVal, childVal, vm);
        };

        function mergeFnData(parentVal, childVal, vm) {
            return strats.computed(
                isFunction(parentVal)
                    ? parentVal.call(vm, vm)
                    : parentVal,
                isFunction(childVal)
                    ? childVal.call(vm, vm)
                    : childVal
            );
        }

        // concat strategy
        function concatStrat(parentVal, childVal) {

            parentVal = parentVal && !isArray(parentVal) ? [parentVal] : parentVal;

            return childVal
                ? parentVal
                    ? parentVal.concat(childVal)
                    : isArray(childVal)
                        ? childVal
                        : [childVal]
                : parentVal;
        }

        // default strategy
        function defaultStrat(parentVal, childVal) {
            return isUndefined(childVal) ? parentVal : childVal;
        }

        function mergeOptions(parent, child, vm) {

            var options = {};

            if (isFunction(child)) {
                child = child.options;
            }

            if (child.extends) {
                parent = mergeOptions(parent, child.extends, vm);
            }

            if (child.mixins) {
                for (var i = 0, l = child.mixins.length; i < l; i++) {
                    parent = mergeOptions(parent, child.mixins[i], vm);
                }
            }

            for (var key in parent) {
                mergeKey(key);
            }

            for (var key$1 in child) {
                if (!hasOwn(parent, key$1)) {
                    mergeKey(key$1);
                }
            }

            function mergeKey(key) {
                options[key] = (strats[key] || defaultStrat)(parent[key], child[key], vm);
            }

            return options;
        }

        function parseOptions(options, args) {
            var obj;

            if ( args === void 0 ) args = [];

            try {

                return !options
                    ? {}
                    : startsWith(options, '{')
                        ? JSON.parse(options)
                        : args.length && !includes(options, ':')
                            ? (( obj = {}, obj[args[0]] = options, obj ))
                            : options.split(';').reduce(function (options, option) {
                                var ref = option.split(/:(.*)/);
                                var key = ref[0];
                                var value = ref[1];
                                if (key && !isUndefined(value)) {
                                    options[key.trim()] = value.trim();
                                }
                                return options;
                            }, {});

            } catch (e) {
                return {};
            }

        }

        var id = 0;

        var Player = function(el) {
            this.id = ++id;
            this.el = toNode(el);
        };

        Player.prototype.isVideo = function () {
            return this.isYoutube() || this.isVimeo() || this.isHTML5();
        };

        Player.prototype.isHTML5 = function () {
            return this.el.tagName === 'VIDEO';
        };

        Player.prototype.isIFrame = function () {
            return this.el.tagName === 'IFRAME';
        };

        Player.prototype.isYoutube = function () {
            return this.isIFrame() && !!this.el.src.match(/\/\/.*?youtube(-nocookie)?\.[a-z]+\/(watch\?v=[^&\s]+|embed)|youtu\.be\/.*/);
        };

        Player.prototype.isVimeo = function () {
            return this.isIFrame() && !!this.el.src.match(/vimeo\.com\/video\/.*/);
        };

        Player.prototype.enableApi = function () {
                var this$1 = this;


            if (this.ready) {
                return this.ready;
            }

            var youtube = this.isYoutube();
            var vimeo = this.isVimeo();

            var poller;

            if (youtube || vimeo) {

                return this.ready = new Promise(function (resolve) {

                    once(this$1.el, 'load', function () {
                        if (youtube) {
                            var listener = function () { return post(this$1.el, {event: 'listening', id: this$1.id}); };
                            poller = setInterval(listener, 100);
                            listener();
                        }
                    });

                    listen(function (data) { return youtube && data.id === this$1.id && data.event === 'onReady' || vimeo && Number(data.player_id) === this$1.id; })
                        .then(function () {
                            resolve();
                            poller && clearInterval(poller);
                        });

                    attr(this$1.el, 'src', ("" + (this$1.el.src) + (includes(this$1.el.src, '?') ? '&' : '?') + (youtube ? 'enablejsapi=1' : ("api=1&player_id=" + (this$1.id)))));

                });

            }

            return Promise.resolve();

        };

        Player.prototype.play = function () {
                var this$1 = this;


            if (!this.isVideo()) {
                return;
            }

            if (this.isIFrame()) {
                this.enableApi().then(function () { return post(this$1.el, {func: 'playVideo', method: 'play'}); });
            } else if (this.isHTML5()) {
                try {
                    var promise = this.el.play();

                    if (promise) {
                        promise.catch(noop);
                    }
                } catch (e) {}
            }
        };

        Player.prototype.pause = function () {
                var this$1 = this;


            if (!this.isVideo()) {
                return;
            }

            if (this.isIFrame()) {
                this.enableApi().then(function () { return post(this$1.el, {func: 'pauseVideo', method: 'pause'}); });
            } else if (this.isHTML5()) {
                this.el.pause();
            }
        };

        Player.prototype.mute = function () {
                var this$1 = this;


            if (!this.isVideo()) {
                return;
            }

            if (this.isIFrame()) {
                this.enableApi().then(function () { return post(this$1.el, {func: 'mute', method: 'setVolume', value: 0}); });
            } else if (this.isHTML5()) {
                this.el.muted = true;
                attr(this.el, 'muted', '');
            }

        };

        function post(el, cmd) {
            try {
                el.contentWindow.postMessage(JSON.stringify(assign({event: 'command'}, cmd)), '*');
            } catch (e) {}
        }

        function listen(cb) {

            return new Promise(function (resolve) {

                once(window, 'message', function (_, data) { return resolve(data); }, false, function (ref) {
                    var data = ref.data;


                    if (!data || !isString(data)) {
                        return;
                    }

                    try {
                        data = JSON.parse(data);
                    } catch (e) {
                        return;
                    }

                    return data && cb(data);

                });

            });

        }

        var IntersectionObserver = 'IntersectionObserver' in window
            ? window.IntersectionObserver
            : /*@__PURE__*/(function () {
            function IntersectionObserverClass(callback, ref) {
                var this$1 = this;
                if ( ref === void 0 ) ref = {};
                var rootMargin = ref.rootMargin; if ( rootMargin === void 0 ) rootMargin = '0 0';


                    this.targets = [];

                    var ref$1 = (rootMargin || '0 0').split(' ').map(toFloat);
                var offsetTop = ref$1[0];
                var offsetLeft = ref$1[1];

                    this.offsetTop = offsetTop;
                    this.offsetLeft = offsetLeft;

                    var pending;
                    this.apply = function () {

                        if (pending) {
                            return;
                        }

                        pending = requestAnimationFrame(function () { return setTimeout(function () {
                            var records = this$1.takeRecords();

                            if (records.length) {
                                callback(records, this$1);
                            }

                            pending = false;
                        }); });

                    };

                    this.off = on(window, 'scroll resize load', this.apply, {passive: true, capture: true});

                }

                IntersectionObserverClass.prototype.takeRecords = function () {
                    var this$1 = this;

                    return this.targets.filter(function (entry) {

                        var inView = isInView(entry.target, this$1.offsetTop, this$1.offsetLeft);

                        if (entry.isIntersecting === null || inView ^ entry.isIntersecting) {
                            entry.isIntersecting = inView;
                            return true;
                        }

                    });
                };

                IntersectionObserverClass.prototype.observe = function (target) {
                    this.targets.push({
                        target: target,
                        isIntersecting: null
                    });
                    this.apply();
                };

                IntersectionObserverClass.prototype.disconnect = function () {
                    this.targets = [];
                    this.off();
                };

            return IntersectionObserverClass;
        }());



        var util = /*#__PURE__*/Object.freeze({
            ajax: ajax,
            getImage: getImage,
            transition: transition,
            Transition: Transition,
            animate: animate,
            Animation: Animation,
            attr: attr,
            hasAttr: hasAttr,
            removeAttr: removeAttr,
            data: data,
            addClass: addClass,
            removeClass: removeClass,
            removeClasses: removeClasses,
            replaceClass: replaceClass,
            hasClass: hasClass,
            toggleClass: toggleClass,
            positionAt: positionAt,
            offset: offset,
            position: position,
            height: height,
            width: width,
            boxModelAdjust: boxModelAdjust,
            flipPosition: flipPosition,
            isInView: isInView,
            scrolledOver: scrolledOver,
            scrollTop: scrollTop,
            offsetPosition: offsetPosition,
            toPx: toPx,
            ready: ready,
            index: index,
            getIndex: getIndex,
            empty: empty,
            html: html,
            prepend: prepend,
            append: append,
            before: before,
            after: after,
            remove: remove,
            wrapAll: wrapAll,
            wrapInner: wrapInner,
            unwrap: unwrap,
            fragment: fragment,
            apply: apply,
            $: $,
            $$: $$,
            isIE: isIE,
            isRtl: isRtl,
            hasTouch: hasTouch,
            pointerDown: pointerDown,
            pointerMove: pointerMove,
            pointerUp: pointerUp,
            pointerEnter: pointerEnter,
            pointerLeave: pointerLeave,
            pointerCancel: pointerCancel,
            on: on,
            off: off,
            once: once,
            trigger: trigger,
            createEvent: createEvent,
            toEventTargets: toEventTargets,
            isTouch: isTouch,
            getEventPos: getEventPos,
            fastdom: fastdom,
            isVoidElement: isVoidElement,
            isVisible: isVisible,
            selInput: selInput,
            isInput: isInput,
            filter: filter,
            within: within,
            bind: bind,
            hasOwn: hasOwn,
            hyphenate: hyphenate,
            camelize: camelize,
            ucfirst: ucfirst,
            startsWith: startsWith,
            endsWith: endsWith,
            includes: includes,
            findIndex: findIndex,
            isArray: isArray,
            isFunction: isFunction,
            isObject: isObject,
            isPlainObject: isPlainObject,
            isWindow: isWindow,
            isDocument: isDocument,
            isJQuery: isJQuery,
            isNode: isNode,
            isNodeCollection: isNodeCollection,
            isBoolean: isBoolean,
            isString: isString,
            isNumber: isNumber,
            isNumeric: isNumeric,
            isEmpty: isEmpty,
            isUndefined: isUndefined,
            toBoolean: toBoolean,
            toNumber: toNumber,
            toFloat: toFloat,
            toNode: toNode,
            toNodes: toNodes,
            toList: toList,
            toMs: toMs,
            isEqual: isEqual,
            swap: swap,
            assign: assign,
            each: each,
            sortBy: sortBy,
            uniqueBy: uniqueBy,
            clamp: clamp,
            noop: noop,
            intersectRect: intersectRect,
            pointInRect: pointInRect,
            Dimensions: Dimensions,
            MouseTracker: MouseTracker,
            mergeOptions: mergeOptions,
            parseOptions: parseOptions,
            Player: Player,
            Promise: Promise,
            Deferred: Deferred,
            IntersectionObserver: IntersectionObserver,
            query: query,
            queryAll: queryAll,
            find: find,
            findAll: findAll,
            matches: matches,
            closest: closest,
            parents: parents,
            escape: escape,
            css: css,
            getStyles: getStyles,
            getStyle: getStyle,
            getCssVar: getCssVar,
            propName: propName
        });

        function componentAPI (UIkit) {

            var DATA = UIkit.data;

            var components = {};

            UIkit.component = function (name, options) {

                if (!options) {

                    if (isPlainObject(components[name])) {
                        components[name] = UIkit.extend(components[name]);
                    }

                    return components[name];

                }

                UIkit[name] = function (element, data) {
                    var i = arguments.length, argsArray = Array(i);
                    while ( i-- ) argsArray[i] = arguments[i];


                    var component = UIkit.component(name);

                    if (isPlainObject(element)) {
                        return new component({data: element});
                    }

                    if (component.options.functional) {
                        return new component({data: [].concat( argsArray )});
                    }

                    return element && element.nodeType ? init(element) : $$(element).map(init)[0];

                    function init(element) {

                        var instance = UIkit.getComponent(element, name);

                        if (instance) {
                            if (!data) {
                                return instance;
                            } else {
                                instance.$destroy();
                            }
                        }

                        return new component({el: element, data: data});

                    }

                };

                var opt = isPlainObject(options) ? assign({}, options) : options.options;

                opt.name = name;

                if (opt.install) {
                    opt.install(UIkit, opt, name);
                }

                if (UIkit._initialized && !opt.functional) {
                    var id = hyphenate(name);
                    fastdom.read(function () { return UIkit[name](("[uk-" + id + "],[data-uk-" + id + "]")); });
                }

                return components[name] = isPlainObject(options) ? opt : options;
            };

            UIkit.getComponents = function (element) { return element && element[DATA] || {}; };
            UIkit.getComponent = function (element, name) { return UIkit.getComponents(element)[name]; };

            UIkit.connect = function (node) {

                if (node[DATA]) {
                    for (var name in node[DATA]) {
                        node[DATA][name]._callConnected();
                    }
                }

                for (var i = 0; i < node.attributes.length; i++) {

                    var name$1 = getComponentName(node.attributes[i].name);

                    if (name$1 && name$1 in components) {
                        UIkit[name$1](node);
                    }

                }

            };

            UIkit.disconnect = function (node) {
                for (var name in node[DATA]) {
                    node[DATA][name]._callDisconnected();
                }
            };

        }

        function getComponentName(attribute) {
            return startsWith(attribute, 'uk-') || startsWith(attribute, 'data-uk-')
                ? camelize(attribute.replace('data-uk-', '').replace('uk-', ''))
                : false;
        }

        function boot (UIkit) {

            var connect = UIkit.connect;
            var disconnect = UIkit.disconnect;

            if (!('MutationObserver' in window)) {
                return;
            }

            if (document.body) {

                init();

            } else {

                (new MutationObserver(function () {

                    if (document.body) {
                        this.disconnect();
                        init();
                    }

                })).observe(document, {childList: true, subtree: true});

            }

            function init() {

                apply(document.body, connect);

                // Safari renders prior to first animation frame
                fastdom.flush();

                (new MutationObserver(function (mutations) { return mutations.forEach(applyMutation); })).observe(document, {
                    childList: true,
                    subtree: true,
                    characterData: true,
                    attributes: true
                });

                UIkit._initialized = true;
            }

            function applyMutation(mutation) {

                var target = mutation.target;
                var type = mutation.type;

                var update = type !== 'attributes'
                    ? applyChildList(mutation)
                    : applyAttribute(mutation);

                update && UIkit.update(target);

            }

            function applyAttribute(ref) {
                var target = ref.target;
                var attributeName = ref.attributeName;


                if (attributeName === 'href') {
                    return true;
                }

                var name = getComponentName(attributeName);

                if (!name || !(name in UIkit)) {
                    return;
                }

                if (hasAttr(target, attributeName)) {
                    UIkit[name](target);
                    return true;
                }

                var component = UIkit.getComponent(target, name);

                if (component) {
                    component.$destroy();
                    return true;
                }

            }

            function applyChildList(ref) {
                var addedNodes = ref.addedNodes;
                var removedNodes = ref.removedNodes;


                for (var i = 0; i < addedNodes.length; i++) {
                    apply(addedNodes[i], connect);
                }

                for (var i$1 = 0; i$1 < removedNodes.length; i$1++) {
                    apply(removedNodes[i$1], disconnect);
                }

                return true;
            }

            function apply(node, fn) {

                if (node.nodeType !== 1 || hasAttr(node, 'uk-no-boot')) {
                    return;
                }

                fn(node);
                node = node.firstElementChild;
                while (node) {
                    var next = node.nextElementSibling;
                    apply(node, fn);
                    node = next;
                }
            }

        }

        function globalAPI (UIkit) {

            var DATA = UIkit.data;

            UIkit.use = function (plugin) {

                if (plugin.installed) {
                    return;
                }

                plugin.call(null, this);
                plugin.installed = true;

                return this;
            };

            UIkit.mixin = function (mixin, component) {
                component = (isString(component) ? UIkit.component(component) : component) || this;
                component.options = mergeOptions(component.options, mixin);
            };

            UIkit.extend = function (options) {

                options = options || {};

                var Super = this;
                var Sub = function UIkitComponent(options) {
                    this._init(options);
                };

                Sub.prototype = Object.create(Super.prototype);
                Sub.prototype.constructor = Sub;
                Sub.options = mergeOptions(Super.options, options);

                Sub.super = Super;
                Sub.extend = Super.extend;

                return Sub;
            };

            UIkit.update = function (element, e) {

                element = element ? toNode(element) : document.body;

                path(element, function (element) { return update(element[DATA], e); });
                apply(element, function (element) { return update(element[DATA], e); });

            };

            var container;
            Object.defineProperty(UIkit, 'container', {

                get: function() {
                    return container || document.body;
                },

                set: function(element) {
                    container = $(element);
                }

            });

            function update(data, e) {

                if (!data) {
                    return;
                }

                for (var name in data) {
                    if (data[name]._connected) {
                        data[name]._callUpdate(e);
                    }
                }

            }

            function path(node, fn) {
                if (node && node !== document.body && node.parentNode) {
                    path(node.parentNode, fn);
                    fn(node.parentNode);
                }
            }

        }

        function hooksAPI (UIkit) {

            UIkit.prototype._callHook = function (hook) {
                var this$1 = this;


                var handlers = this.$options[hook];

                if (handlers) {
                    handlers.forEach(function (handler) { return handler.call(this$1); });
                }
            };

            UIkit.prototype._callConnected = function () {

                if (this._connected) {
                    return;
                }

                this._data = {};
                this._computeds = {};
                this._initProps();

                this._callHook('beforeConnect');
                this._connected = true;

                this._initEvents();
                this._initObserver();

                this._callHook('connected');
                this._callUpdate();
            };

            UIkit.prototype._callDisconnected = function () {

                if (!this._connected) {
                    return;
                }

                this._callHook('beforeDisconnect');

                if (this._observer) {
                    this._observer.disconnect();
                    this._observer = null;
                }

                this._unbindEvents();
                this._callHook('disconnected');

                this._connected = false;

            };

            UIkit.prototype._callUpdate = function (e) {
                var this$1 = this;
                if ( e === void 0 ) e = 'update';


                var type = e.type || e;

                if (includes(['update', 'resize'], type)) {
                    this._callWatches();
                }

                var updates = this.$options.update;
                var ref = this._frames;
                var reads = ref.reads;
                var writes = ref.writes;

                if (!updates) {
                    return;
                }

                updates.forEach(function (ref, i) {
                    var read = ref.read;
                    var write = ref.write;
                    var events = ref.events;


                    if (type !== 'update' && !includes(events, type)) {
                        return;
                    }

                    if (read && !includes(fastdom.reads, reads[i])) {
                        reads[i] = fastdom.read(function () {

                            var result = this$1._connected && read.call(this$1, this$1._data, type);

                            if (result === false && write) {
                                fastdom.clear(writes[i]);
                            } else if (isPlainObject(result)) {
                                assign(this$1._data, result);
                            }
                        });
                    }

                    if (write && !includes(fastdom.writes, writes[i])) {
                        writes[i] = fastdom.write(function () { return this$1._connected && write.call(this$1, this$1._data, type); });
                    }

                });

            };

        }

        function stateAPI (UIkit) {

            var uid = 0;

            UIkit.prototype._init = function (options) {

                options = options || {};
                options.data = normalizeData(options, this.constructor.options);

                this.$options = mergeOptions(this.constructor.options, options, this);
                this.$el = null;
                this.$props = {};

                this._frames = {reads: {}, writes: {}};
                this._events = [];

                this._uid = uid++;
                this._initData();
                this._initMethods();
                this._initComputeds();
                this._callHook('created');

                if (options.el) {
                    this.$mount(options.el);
                }
            };

            UIkit.prototype._initData = function () {

                var ref = this.$options;
                var data = ref.data; if ( data === void 0 ) data = {};

                for (var key in data) {
                    this.$props[key] = this[key] = data[key];
                }
            };

            UIkit.prototype._initMethods = function () {

                var ref = this.$options;
                var methods = ref.methods;

                if (methods) {
                    for (var key in methods) {
                        this[key] = bind(methods[key], this);
                    }
                }
            };

            UIkit.prototype._initComputeds = function () {

                var ref = this.$options;
                var computed = ref.computed;

                this._computeds = {};

                if (computed) {
                    for (var key in computed) {
                        registerComputed(this, key, computed[key]);
                    }
                }
            };

            UIkit.prototype._callWatches = function () {

                var ref = this;
                var computed = ref.$options.computed;
                var _computeds = ref._computeds;

                for (var key in _computeds) {

                    var value = _computeds[key];
                    delete _computeds[key];

                    if (computed[key].watch && !isEqual(value, this[key])) {
                        computed[key].watch.call(this, this[key], value);
                    }

                }

            };

            UIkit.prototype._initProps = function (props) {

                var key;

                props = props || getProps(this.$options, this.$name);

                for (key in props) {
                    if (!isUndefined(props[key])) {
                        this.$props[key] = props[key];
                    }
                }

                var exclude = [this.$options.computed, this.$options.methods];
                for (key in this.$props) {
                    if (key in props && notIn(exclude, key)) {
                        this[key] = this.$props[key];
                    }
                }
            };

            UIkit.prototype._initEvents = function () {
                var this$1 = this;


                var ref = this.$options;
                var events = ref.events;

                if (events) {

                    events.forEach(function (event) {

                        if (!hasOwn(event, 'handler')) {
                            for (var key in event) {
                                registerEvent(this$1, event[key], key);
                            }
                        } else {
                            registerEvent(this$1, event);
                        }

                    });
                }
            };

            UIkit.prototype._unbindEvents = function () {
                this._events.forEach(function (unbind) { return unbind(); });
                this._events = [];
            };

            UIkit.prototype._initObserver = function () {
                var this$1 = this;


                var ref = this.$options;
                var attrs = ref.attrs;
                var props = ref.props;
                var el = ref.el;
                if (this._observer || !props || attrs === false) {
                    return;
                }

                attrs = isArray(attrs) ? attrs : Object.keys(props);

                this._observer = new MutationObserver(function () {

                    var data = getProps(this$1.$options, this$1.$name);
                    if (attrs.some(function (key) { return !isUndefined(data[key]) && data[key] !== this$1.$props[key]; })) {
                        this$1.$reset();
                    }

                });

                var filter = attrs.map(function (key) { return hyphenate(key); }).concat(this.$name);

                this._observer.observe(el, {
                    attributes: true,
                    attributeFilter: filter.concat(filter.map(function (key) { return ("data-" + key); }))
                });
            };

            function getProps(opts, name) {

                var data$1 = {};
                var args = opts.args; if ( args === void 0 ) args = [];
                var props = opts.props; if ( props === void 0 ) props = {};
                var el = opts.el;

                if (!props) {
                    return data$1;
                }

                for (var key in props) {
                    var prop = hyphenate(key);
                    var value = data(el, prop);

                    if (!isUndefined(value)) {

                        value = props[key] === Boolean && value === ''
                            ? true
                            : coerce(props[key], value);

                        if (prop === 'target' && (!value || startsWith(value, '_'))) {
                            continue;
                        }

                        data$1[key] = value;
                    }
                }

                var options = parseOptions(data(el, name), args);

                for (var key$1 in options) {
                    var prop$1 = camelize(key$1);
                    if (props[prop$1] !== undefined) {
                        data$1[prop$1] = coerce(props[prop$1], options[key$1]);
                    }
                }

                return data$1;
            }

            function registerComputed(component, key, cb) {
                Object.defineProperty(component, key, {

                    enumerable: true,

                    get: function() {

                        var _computeds = component._computeds;
                        var $props = component.$props;
                        var $el = component.$el;

                        if (!hasOwn(_computeds, key)) {
                            _computeds[key] = (cb.get || cb).call(component, $props, $el);
                        }

                        return _computeds[key];
                    },

                    set: function(value) {

                        var _computeds = component._computeds;

                        _computeds[key] = cb.set ? cb.set.call(component, value) : value;

                        if (isUndefined(_computeds[key])) {
                            delete _computeds[key];
                        }
                    }

                });
            }

            function registerEvent(component, event, key) {

                if (!isPlainObject(event)) {
                    event = ({name: key, handler: event});
                }

                var name = event.name;
                var el = event.el;
                var handler = event.handler;
                var capture = event.capture;
                var passive = event.passive;
                var delegate = event.delegate;
                var filter = event.filter;
                var self = event.self;
                el = isFunction(el)
                    ? el.call(component)
                    : el || component.$el;

                if (isArray(el)) {
                    el.forEach(function (el) { return registerEvent(component, assign({}, event, {el: el}), key); });
                    return;
                }

                if (!el || filter && !filter.call(component)) {
                    return;
                }

                handler = detail(isString(handler) ? component[handler] : bind(handler, component));

                if (self) {
                    handler = selfFilter(handler);
                }

                component._events.push(
                    on(
                        el,
                        name,
                        !delegate
                            ? null
                            : isString(delegate)
                                ? delegate
                                : delegate.call(component),
                        handler,
                        isBoolean(passive)
                            ? {passive: passive, capture: capture}
                            : capture
                    )
                );

            }

            function selfFilter(handler) {
                return function selfHandler(e) {
                    if (e.target === e.currentTarget || e.target === e.current) {
                        return handler.call(null, e);
                    }
                };
            }

            function notIn(options, key) {
                return options.every(function (arr) { return !arr || !hasOwn(arr, key); });
            }

            function detail(listener) {
                return function (e) { return isArray(e.detail) ? listener.apply(void 0, [e].concat(e.detail)) : listener(e); };
            }

            function coerce(type, value) {

                if (type === Boolean) {
                    return toBoolean(value);
                } else if (type === Number) {
                    return toNumber(value);
                } else if (type === 'list') {
                    return toList(value);
                }

                return type ? type(value) : value;
            }

            function normalizeData(ref, ref$1) {
                var data = ref.data;
                var el = ref.el;
                var args = ref$1.args;
                var props = ref$1.props; if ( props === void 0 ) props = {};

                data = isArray(data)
                    ? !isEmpty(args)
                        ? data.slice(0, args.length).reduce(function (data, value, index) {
                            if (isPlainObject(value)) {
                                assign(data, value);
                            } else {
                                data[args[index]] = value;
                            }
                            return data;
                        }, {})
                        : undefined
                    : data;

                if (data) {
                    for (var key in data) {
                        if (isUndefined(data[key])) {
                            delete data[key];
                        } else {
                            data[key] = props[key] ? coerce(props[key], data[key]) : data[key];
                        }
                    }
                }

                return data;
            }
        }

        function instanceAPI (UIkit) {

            var DATA = UIkit.data;

            UIkit.prototype.$mount = function (el) {

                var ref = this.$options;
                var name = ref.name;

                if (!el[DATA]) {
                    el[DATA] = {};
                }

                if (el[DATA][name]) {
                    return;
                }

                el[DATA][name] = this;

                this.$el = this.$options.el = this.$options.el || el;

                if (within(el, document)) {
                    this._callConnected();
                }
            };

            UIkit.prototype.$emit = function (e) {
                this._callUpdate(e);
            };

            UIkit.prototype.$reset = function () {
                this._callDisconnected();
                this._callConnected();
            };

            UIkit.prototype.$destroy = function (removeEl) {
                if ( removeEl === void 0 ) removeEl = false;


                var ref = this.$options;
                var el = ref.el;
                var name = ref.name;

                if (el) {
                    this._callDisconnected();
                }

                this._callHook('destroy');

                if (!el || !el[DATA]) {
                    return;
                }

                delete el[DATA][name];

                if (!isEmpty(el[DATA])) {
                    delete el[DATA];
                }

                if (removeEl) {
                    remove(this.$el);
                }
            };

            UIkit.prototype.$create = function (component, element, data) {
                return UIkit[component](element, data);
            };

            UIkit.prototype.$update = UIkit.update;
            UIkit.prototype.$getComponent = UIkit.getComponent;

            var names = {};
            Object.defineProperties(UIkit.prototype, {

                $container: Object.getOwnPropertyDescriptor(UIkit, 'container'),

                $name: {

                    get: function() {
                        var ref = this.$options;
                        var name = ref.name;

                        if (!names[name]) {
                            names[name] = UIkit.prefix + hyphenate(name);
                        }

                        return names[name];
                    }

                }

            });

        }

        var UIkit = function (options) {
            this._init(options);
        };

        UIkit.util = util;
        UIkit.data = '__uikit__';
        UIkit.prefix = 'uk-';
        UIkit.options = {};

        globalAPI(UIkit);
        hooksAPI(UIkit);
        stateAPI(UIkit);
        componentAPI(UIkit);
        instanceAPI(UIkit);

        var Class = {

            connected: function() {
                !hasClass(this.$el, this.$name) && addClass(this.$el, this.$name);
            }

        };

        var Togglable = {

            props: {
                cls: Boolean,
                animation: 'list',
                duration: Number,
                origin: String,
                transition: String,
                queued: Boolean
            },

            data: {
                cls: false,
                animation: [false],
                duration: 200,
                origin: false,
                transition: 'linear',
                queued: false,

                initProps: {
                    overflow: '',
                    height: '',
                    paddingTop: '',
                    paddingBottom: '',
                    marginTop: '',
                    marginBottom: ''
                },

                hideProps: {
                    overflow: 'hidden',
                    height: 0,
                    paddingTop: 0,
                    paddingBottom: 0,
                    marginTop: 0,
                    marginBottom: 0
                }

            },

            computed: {

                hasAnimation: function(ref) {
                    var animation = ref.animation;

                    return !!animation[0];
                },

                hasTransition: function(ref) {
                    var animation = ref.animation;

                    return this.hasAnimation && animation[0] === true;
                }

            },

            methods: {

                toggleElement: function(targets, show, animate) {
                    var this$1 = this;

                    return new Promise(function (resolve) {

                        targets = toNodes(targets);

                        var all = function (targets) { return Promise.all(targets.map(function (el) { return this$1._toggleElement(el, show, animate); })); };
                        var toggled = targets.filter(function (el) { return this$1.isToggled(el); });
                        var untoggled = targets.filter(function (el) { return !includes(toggled, el); });

                        var p;

                        if (!this$1.queued || !isUndefined(animate) || !isUndefined(show) || !this$1.hasAnimation || targets.length < 2) {

                            p = all(untoggled.concat(toggled));

                        } else {

                            var body = document.body;
                            var scroll = body.scrollTop;
                            var el = toggled[0];
                            var inProgress = Animation.inProgress(el) && hasClass(el, 'uk-animation-leave')
                                    || Transition.inProgress(el) && el.style.height === '0px';

                            p = all(toggled);

                            if (!inProgress) {
                                p = p.then(function () {
                                    var p = all(untoggled);
                                    body.scrollTop = scroll;
                                    return p;
                                });
                            }

                        }

                        p.then(resolve, noop);

                    });
                },

                toggleNow: function(targets, show) {
                    var this$1 = this;

                    return new Promise(function (resolve) { return Promise.all(toNodes(targets).map(function (el) { return this$1._toggleElement(el, show, false); })).then(resolve, noop); });
                },

                isToggled: function(el) {
                    var nodes = toNodes(el || this.$el);
                    return this.cls
                        ? hasClass(nodes, this.cls.split(' ')[0])
                        : !hasAttr(nodes, 'hidden');
                },

                updateAria: function(el) {
                    if (this.cls === false) {
                        attr(el, 'aria-hidden', !this.isToggled(el));
                    }
                },

                _toggleElement: function(el, show, animate) {
                    var this$1 = this;


                    show = isBoolean(show)
                        ? show
                        : Animation.inProgress(el)
                            ? hasClass(el, 'uk-animation-leave')
                            : Transition.inProgress(el)
                                ? el.style.height === '0px'
                                : !this.isToggled(el);

                    if (!trigger(el, ("before" + (show ? 'show' : 'hide')), [this])) {
                        return Promise.reject();
                    }

                    var promise = (
                        isFunction(animate)
                            ? animate
                            : animate === false || !this.hasAnimation
                                ? this._toggle
                                : this.hasTransition
                                    ? toggleHeight(this)
                                    : toggleAnimation(this)
                    )(el, show);

                    trigger(el, show ? 'show' : 'hide', [this]);

                    var final = function () {
                        trigger(el, show ? 'shown' : 'hidden', [this$1]);
                        this$1.$update(el);
                    };

                    return promise ? promise.then(final) : Promise.resolve(final());
                },

                _toggle: function(el, toggled) {

                    if (!el) {
                        return;
                    }

                    toggled = Boolean(toggled);

                    var changed;
                    if (this.cls) {
                        changed = includes(this.cls, ' ') || toggled !== hasClass(el, this.cls);
                        changed && toggleClass(el, this.cls, includes(this.cls, ' ') ? undefined : toggled);
                    } else {
                        changed = toggled === hasAttr(el, 'hidden');
                        changed && attr(el, 'hidden', !toggled ? '' : null);
                    }

                    $$('[autofocus]', el).some(function (el) { return isVisible(el) ? el.focus() || true : el.blur(); });

                    this.updateAria(el);
                    changed && this.$update(el);
                }

            }

        };

        function toggleHeight(ref) {
            var isToggled = ref.isToggled;
            var duration = ref.duration;
            var initProps = ref.initProps;
            var hideProps = ref.hideProps;
            var transition = ref.transition;
            var _toggle = ref._toggle;

            return function (el, show) {

                var inProgress = Transition.inProgress(el);
                var inner = el.hasChildNodes ? toFloat(css(el.firstElementChild, 'marginTop')) + toFloat(css(el.lastElementChild, 'marginBottom')) : 0;
                var currentHeight = isVisible(el) ? height(el) + (inProgress ? 0 : inner) : 0;

                Transition.cancel(el);

                if (!isToggled(el)) {
                    _toggle(el, true);
                }

                height(el, '');

                // Update child components first
                fastdom.flush();

                var endHeight = height(el) + (inProgress ? 0 : inner);
                height(el, currentHeight);

                return (show
                        ? Transition.start(el, assign({}, initProps, {overflow: 'hidden', height: endHeight}), Math.round(duration * (1 - currentHeight / endHeight)), transition)
                        : Transition.start(el, hideProps, Math.round(duration * (currentHeight / endHeight)), transition).then(function () { return _toggle(el, false); })
                ).then(function () { return css(el, initProps); });

            };
        }

        function toggleAnimation(ref) {
            var animation = ref.animation;
            var duration = ref.duration;
            var origin = ref.origin;
            var _toggle = ref._toggle;

            return function (el, show) {

                Animation.cancel(el);

                if (show) {
                    _toggle(el, true);
                    return Animation.in(el, animation[0], duration, origin);
                }

                return Animation.out(el, animation[1] || animation[0], duration, origin).then(function () { return _toggle(el, false); });
            };
        }

        var Accordion = {

            mixins: [Class, Togglable],

            props: {
                targets: String,
                active: null,
                collapsible: Boolean,
                multiple: Boolean,
                toggle: String,
                content: String,
                transition: String
            },

            data: {
                targets: '> *',
                active: false,
                animation: [true],
                collapsible: true,
                multiple: false,
                clsOpen: 'uk-open',
                toggle: '> .uk-accordion-title',
                content: '> .uk-accordion-content',
                transition: 'ease'
            },

            computed: {

                items: function(ref, $el) {
                    var targets = ref.targets;

                    return $$(targets, $el);
                }

            },

            events: [

                {

                    name: 'click',

                    delegate: function() {
                        return ((this.targets) + " " + (this.$props.toggle));
                    },

                    handler: function(e) {
                        e.preventDefault();
                        this.toggle(index($$(((this.targets) + " " + (this.$props.toggle)), this.$el), e.current));
                    }

                }

            ],

            connected: function() {

                if (this.active === false) {
                    return;
                }

                var active = this.items[Number(this.active)];
                if (active && !hasClass(active, this.clsOpen)) {
                    this.toggle(active, false);
                }
            },

            update: function() {
                var this$1 = this;


                this.items.forEach(function (el) { return this$1._toggle($(this$1.content, el), hasClass(el, this$1.clsOpen)); });

                var active = !this.collapsible && !hasClass(this.items, this.clsOpen) && this.items[0];
                if (active) {
                    this.toggle(active, false);
                }
            },

            methods: {

                toggle: function(item, animate) {
                    var this$1 = this;


                    var index = getIndex(item, this.items);
                    var active = filter(this.items, ("." + (this.clsOpen)));

                    item = this.items[index];

                    item && [item]
                        .concat(!this.multiple && !includes(active, item) && active || [])
                        .forEach(function (el) {

                            var isItem = el === item;
                            var state = isItem && !hasClass(el, this$1.clsOpen);

                            if (!state && isItem && !this$1.collapsible && active.length < 2) {
                                return;
                            }

                            toggleClass(el, this$1.clsOpen, state);

                            var content = el._wrapper ? el._wrapper.firstElementChild : $(this$1.content, el);

                            if (!el._wrapper) {
                                el._wrapper = wrapAll(content, '<div>');
                                attr(el._wrapper, 'hidden', state ? '' : null);
                            }

                            this$1._toggle(content, true);
                            this$1.toggleElement(el._wrapper, state, animate).then(function () {

                                if (hasClass(el, this$1.clsOpen) !== state) {
                                    return;
                                }

                                if (!state) {
                                    this$1._toggle(content, false);
                                }

                                el._wrapper = null;
                                unwrap(content);

                            });

                        });
                }

            }

        };

        var Alert = {

            mixins: [Class, Togglable],

            args: 'animation',

            props: {
                close: String
            },

            data: {
                animation: [true],
                selClose: '.uk-alert-close',
                duration: 150,
                hideProps: assign({opacity: 0}, Togglable.data.hideProps)
            },

            events: [

                {

                    name: 'click',

                    delegate: function() {
                        return this.selClose;
                    },

                    handler: function(e) {
                        e.preventDefault();
                        this.close();
                    }

                }

            ],

            methods: {

                close: function() {
                    var this$1 = this;

                    this.toggleElement(this.$el).then(function () { return this$1.$destroy(true); });
                }

            }

        };

        function Core (UIkit) {

            ready(function () {

                UIkit.update();
                on(window, 'load resize', function () { return UIkit.update(null, 'resize'); });
                on(document, 'loadedmetadata load', function (ref) {
                    var target = ref.target;

                    return UIkit.update(target, 'resize');
                }, true);

                // throttle `scroll` event (Safari triggers multiple `scroll` events per frame)
                var pending;
                on(window, 'scroll', function (e) {

                    if (pending) {
                        return;
                    }
                    pending = true;
                    fastdom.write(function () { return pending = false; });

                    var target = e.target;
                    UIkit.update(target.nodeType !== 1 ? document.body : target, e.type);

                }, {passive: true, capture: true});

                var started = 0;
                on(document, 'animationstart', function (ref) {
                    var target = ref.target;

                    if ((css(target, 'animationName') || '').match(/^uk-.*(left|right)/)) {

                        started++;
                        css(document.body, 'overflowX', 'hidden');
                        setTimeout(function () {
                            if (!--started) {
                                css(document.body, 'overflowX', '');
                            }
                        }, toMs(css(target, 'animationDuration')) + 100);
                    }
                }, true);

                var off;
                on(document, pointerDown, function (e) {

                    off && off();

                    if (!isTouch(e)) {
                        return;
                    }

                    var pos = getEventPos(e);
                    var target = 'tagName' in e.target ? e.target : e.target.parentNode;
                    off = once(document, pointerUp, function (e) {

                        var ref = getEventPos(e);
                        var x = ref.x;
                        var y = ref.y;

                        // swipe
                        if (target && x && Math.abs(pos.x - x) > 100 || y && Math.abs(pos.y - y) > 100) {

                            setTimeout(function () {
                                trigger(target, 'swipe');
                                trigger(target, ("swipe" + (swipeDirection(pos.x, pos.y, x, y))));
                            });

                        }

                    });
                }, {passive: true});

            });

        }

        function swipeDirection(x1, y1, x2, y2) {
            return Math.abs(x1 - x2) >= Math.abs(y1 - y2)
                ? x1 - x2 > 0
                    ? 'Left'
                    : 'Right'
                : y1 - y2 > 0
                    ? 'Up'
                    : 'Down';
        }

        var Video = {

            args: 'autoplay',

            props: {
                automute: Boolean,
                autoplay: Boolean
            },

            data: {
                automute: false,
                autoplay: true
            },

            computed: {

                inView: function(ref) {
                    var autoplay = ref.autoplay;

                    return autoplay === 'inview';
                }

            },

            connected: function() {

                if (this.inView && !hasAttr(this.$el, 'preload')) {
                    this.$el.preload = 'none';
                }

                this.player = new Player(this.$el);

                if (this.automute) {
                    this.player.mute();
                }

            },

            update: {

                read: function() {

                    return !this.player
                        ? false
                        : {
                            visible: isVisible(this.$el) && css(this.$el, 'visibility') !== 'hidden',
                            inView: this.inView && isInView(this.$el)
                        };
                },

                write: function(ref) {
                    var visible = ref.visible;
                    var inView = ref.inView;


                    if (!visible || this.inView && !inView) {
                        this.player.pause();
                    } else if (this.autoplay === true || this.inView && inView) {
                        this.player.play();
                    }

                },

                events: ['resize', 'scroll']

            }

        };

        var Cover = {

            mixins: [Class, Video],

            props: {
                width: Number,
                height: Number
            },

            data: {
                automute: true
            },

            update: {

                read: function() {

                    var el = this.$el;

                    if (!isVisible(el)) {
                        return false;
                    }

                    var ref = el.parentNode;
                    var height = ref.offsetHeight;
                    var width = ref.offsetWidth;

                    return {height: height, width: width};
                },

                write: function(ref) {
                    var height = ref.height;
                    var width = ref.width;


                    var el = this.$el;
                    var elWidth = this.width || el.naturalWidth || el.videoWidth || el.clientWidth;
                    var elHeight = this.height || el.naturalHeight || el.videoHeight || el.clientHeight;

                    if (!elWidth || !elHeight) {
                        return;
                    }

                    css(el, Dimensions.cover(
                        {
                            width: elWidth,
                            height: elHeight
                        },
                        {
                            width: width + (width % 2 ? 1 : 0),
                            height: height + (height % 2 ? 1 : 0)
                        }
                    ));

                },

                events: ['resize']

            }

        };

        var Position = {

            props: {
                pos: String,
                offset: null,
                flip: Boolean,
                clsPos: String
            },

            data: {
                pos: ("bottom-" + (!isRtl ? 'left' : 'right')),
                flip: true,
                offset: false,
                clsPos: ''
            },

            computed: {

                pos: function(ref) {
                    var pos = ref.pos;

                    return (pos + (!includes(pos, '-') ? '-center' : '')).split('-');
                },

                dir: function() {
                    return this.pos[0];
                },

                align: function() {
                    return this.pos[1];
                }

            },

            methods: {

                positionAt: function(element, target, boundary) {

                    removeClasses(element, ((this.clsPos) + "-(top|bottom|left|right)(-[a-z]+)?"));
                    css(element, {top: '', left: ''});

                    var node;
                    var ref = this;
                    var offset$1 = ref.offset;
                    var axis = this.getAxis();

                    if (!isNumeric(offset$1)) {
                        node = $(offset$1);
                        offset$1 = node
                            ? offset(node)[axis === 'x' ? 'left' : 'top'] - offset(target)[axis === 'x' ? 'right' : 'bottom']
                            : 0;
                    }

                    var ref$1 = positionAt(
                        element,
                        target,
                        axis === 'x' ? ((flipPosition(this.dir)) + " " + (this.align)) : ((this.align) + " " + (flipPosition(this.dir))),
                        axis === 'x' ? ((this.dir) + " " + (this.align)) : ((this.align) + " " + (this.dir)),
                        axis === 'x' ? ("" + (this.dir === 'left' ? -offset$1 : offset$1)) : (" " + (this.dir === 'top' ? -offset$1 : offset$1)),
                        null,
                        this.flip,
                        boundary
                    ).target;
                    var x = ref$1.x;
                    var y = ref$1.y;

                    this.dir = axis === 'x' ? x : y;
                    this.align = axis === 'x' ? y : x;

                    toggleClass(element, ((this.clsPos) + "-" + (this.dir) + "-" + (this.align)), this.offset === false);

                },

                getAxis: function() {
                    return this.dir === 'top' || this.dir === 'bottom' ? 'y' : 'x';
                }

            }

        };

        var active;

        var Drop = {

            mixins: [Position, Togglable],

            args: 'pos',

            props: {
                mode: 'list',
                toggle: Boolean,
                boundary: Boolean,
                boundaryAlign: Boolean,
                delayShow: Number,
                delayHide: Number,
                clsDrop: String
            },

            data: {
                mode: ['click', 'hover'],
                toggle: '- *',
                boundary: window,
                boundaryAlign: false,
                delayShow: 0,
                delayHide: 800,
                clsDrop: false,
                hoverIdle: 200,
                animation: ['uk-animation-fade'],
                cls: 'uk-open'
            },

            computed: {

                boundary: function(ref, $el) {
                    var boundary = ref.boundary;

                    return query(boundary, $el);
                },

                clsDrop: function(ref) {
                    var clsDrop = ref.clsDrop;

                    return clsDrop || ("uk-" + (this.$options.name));
                },

                clsPos: function() {
                    return this.clsDrop;
                }

            },

            created: function() {
                this.tracker = new MouseTracker();
            },

            connected: function() {

                addClass(this.$el, this.clsDrop);

                var ref = this.$props;
                var toggle = ref.toggle;
                this.toggle = toggle && this.$create('toggle', query(toggle, this.$el), {
                    target: this.$el,
                    mode: this.mode
                });

                !this.toggle && trigger(this.$el, 'updatearia');

            },

            events: [


                {

                    name: 'click',

                    delegate: function() {
                        return ("." + (this.clsDrop) + "-close");
                    },

                    handler: function(e) {
                        e.preventDefault();
                        this.hide(false);
                    }

                },

                {

                    name: 'click',

                    delegate: function() {
                        return 'a[href^="#"]';
                    },

                    handler: function(e) {

                        var id = e.target.hash;

                        if (!id) {
                            e.preventDefault();
                        }

                        if (!id || !within(id, this.$el)) {
                            this.hide(false);
                        }
                    }

                },

                {

                    name: 'beforescroll',

                    handler: function() {
                        this.hide(false);
                    }

                },

                {

                    name: 'toggle',

                    self: true,

                    handler: function(e, toggle) {

                        e.preventDefault();

                        if (this.isToggled()) {
                            this.hide(false);
                        } else {
                            this.show(toggle, false);
                        }
                    }

                },

                {

                    name: pointerEnter,

                    filter: function() {
                        return includes(this.mode, 'hover');
                    },

                    handler: function(e) {

                        if (isTouch(e)) {
                            return;
                        }

                        if (active
                            && active !== this
                            && active.toggle
                            && includes(active.toggle.mode, 'hover')
                            && !within(e.target, active.toggle.$el)
                            && !pointInRect({x: e.pageX, y: e.pageY}, offset(active.$el))
                        ) {
                            active.hide(false);
                        }

                        e.preventDefault();
                        this.show(this.toggle);
                    }

                },

                {

                    name: 'toggleshow',

                    handler: function(e, toggle) {

                        if (toggle && !includes(toggle.target, this.$el)) {
                            return;
                        }

                        e.preventDefault();
                        this.show(toggle || this.toggle);
                    }

                },

                {

                    name: ("togglehide " + pointerLeave),

                    handler: function(e, toggle) {

                        if (isTouch(e) || toggle && !includes(toggle.target, this.$el)) {
                            return;
                        }

                        e.preventDefault();

                        if (this.toggle && includes(this.toggle.mode, 'hover')) {
                            this.hide();
                        }
                    }

                },

                {

                    name: 'beforeshow',

                    self: true,

                    handler: function() {
                        this.clearTimers();
                        Animation.cancel(this.$el);
                        this.position();
                    }

                },

                {

                    name: 'show',

                    self: true,

                    handler: function() {
                        this.tracker.init();
                        trigger(this.$el, 'updatearia');
                        registerEvent();
                    }

                },

                {

                    name: 'beforehide',

                    self: true,

                    handler: function() {
                        this.clearTimers();
                    }

                },

                {

                    name: 'hide',

                    handler: function(ref) {
                        var target = ref.target;


                        if (this.$el !== target) {
                            active = active === null && within(target, this.$el) && this.isToggled() ? this : active;
                            return;
                        }

                        active = this.isActive() ? null : active;
                        trigger(this.$el, 'updatearia');
                        this.tracker.cancel();
                    }

                },

                {

                    name: 'updatearia',

                    self: true,

                    handler: function(e, toggle) {

                        e.preventDefault();

                        this.updateAria(this.$el);

                        if (toggle || this.toggle) {
                            attr((toggle || this.toggle).$el, 'aria-expanded', this.isToggled() ? 'true' : 'false');
                            toggleClass(this.toggle.$el, this.cls, this.isToggled());
                        }
                    }
                }

            ],

            update: {

                write: function() {

                    if (this.isToggled() && !Animation.inProgress(this.$el)) {
                        this.position();
                    }

                },

                events: ['resize']

            },

            methods: {

                show: function(toggle, delay) {
                    var this$1 = this;
                    if ( delay === void 0 ) delay = true;


                    var show = function () { return !this$1.isToggled() && this$1.toggleElement(this$1.$el, true); };
                    var tryShow = function () {

                        this$1.toggle = toggle || this$1.toggle;

                        this$1.clearTimers();

                        if (this$1.isActive()) {
                            return;
                        } else if (delay && active && active !== this$1 && active.isDelaying) {
                            this$1.showTimer = setTimeout(this$1.show, 10);
                            return;
                        } else if (this$1.isParentOf(active)) {

                            if (active.hideTimer) {
                                active.hide(false);
                            } else {
                                return;
                            }

                        } else if (active && this$1.isChildOf(active)) {

                            active.clearTimers();

                        } else if (active && !this$1.isChildOf(active) && !this$1.isParentOf(active)) {

                            var prev;
                            while (active && active !== prev && !this$1.isChildOf(active)) {
                                prev = active;
                                active.hide(false);
                            }

                        }

                        if (delay && this$1.delayShow) {
                            this$1.showTimer = setTimeout(show, this$1.delayShow);
                        } else {
                            show();
                        }

                        active = this$1;
                    };

                    if (toggle && this.toggle && toggle.$el !== this.toggle.$el) {

                        once(this.$el, 'hide', tryShow);
                        this.hide(false);

                    } else {
                        tryShow();
                    }
                },

                hide: function(delay) {
                    var this$1 = this;
                    if ( delay === void 0 ) delay = true;


                    var hide = function () { return this$1.toggleNow(this$1.$el, false); };

                    this.clearTimers();

                    this.isDelaying = this.tracker.movesTo(this.$el);

                    if (delay && this.isDelaying) {
                        this.hideTimer = setTimeout(this.hide, this.hoverIdle);
                    } else if (delay && this.delayHide) {
                        this.hideTimer = setTimeout(hide, this.delayHide);
                    } else {
                        hide();
                    }
                },

                clearTimers: function() {
                    clearTimeout(this.showTimer);
                    clearTimeout(this.hideTimer);
                    this.showTimer = null;
                    this.hideTimer = null;
                    this.isDelaying = false;
                },

                isActive: function() {
                    return active === this;
                },

                isChildOf: function(drop) {
                    return drop && drop !== this && within(this.$el, drop.$el);
                },

                isParentOf: function(drop) {
                    return drop && drop !== this && within(drop.$el, this.$el);
                },

                position: function() {

                    removeClasses(this.$el, ((this.clsDrop) + "-(stack|boundary)"));
                    css(this.$el, {top: '', left: '', display: 'block'});
                    toggleClass(this.$el, ((this.clsDrop) + "-boundary"), this.boundaryAlign);

                    var boundary = offset(this.boundary);
                    var alignTo = this.boundaryAlign ? boundary : offset(this.toggle.$el);

                    if (this.align === 'justify') {
                        var prop = this.getAxis() === 'y' ? 'width' : 'height';
                        css(this.$el, prop, alignTo[prop]);
                    } else if (this.$el.offsetWidth > Math.max(boundary.right - alignTo.left, alignTo.right - boundary.left)) {
                        addClass(this.$el, ((this.clsDrop) + "-stack"));
                    }

                    this.positionAt(this.$el, this.boundaryAlign ? this.boundary : this.toggle.$el, this.boundary);

                    css(this.$el, 'display', '');

                }

            }

        };

        var registered;

        function registerEvent() {

            if (registered) {
                return;
            }

            registered = true;
            on(document, pointerUp, function (ref) {
                var target = ref.target;
                var defaultPrevented = ref.defaultPrevented;

                var prev;

                if (defaultPrevented) {
                    return;
                }

                while (active && active !== prev && !within(target, active.$el) && !(active.toggle && within(target, active.toggle.$el))) {
                    prev = active;
                    active.hide(false);
                }
            });
        }

        var Dropdown = {

            extends: Drop

        };

        var FormCustom = {

            mixins: [Class],

            args: 'target',

            props: {
                target: Boolean
            },

            data: {
                target: false
            },

            computed: {

                input: function(_, $el) {
                    return $(selInput, $el);
                },

                state: function() {
                    return this.input.nextElementSibling;
                },

                target: function(ref, $el) {
                    var target = ref.target;

                    return target && (target === true
                        && this.input.parentNode === $el
                        && this.input.nextElementSibling
                        || query(target, $el));
                }

            },

            update: function() {

                var ref = this;
                var target = ref.target;
                var input = ref.input;

                if (!target) {
                    return;
                }

                var option;
                var prop = isInput(target) ? 'value' : 'textContent';
                var prev = target[prop];
                var value = input.files && input.files[0]
                    ? input.files[0].name
                    : matches(input, 'select') && (option = $$('option', input).filter(function (el) { return el.selected; })[0])
                        ? option.textContent
                        : input.value;

                if (prev !== value) {
                    target[prop] = value;
                }

            },

            events: [

                {
                    name: 'change',

                    handler: function() {
                        this.$emit();
                    }
                },

                {
                    name: 'reset',

                    el: function() {
                        return closest(this.$el, 'form');
                    },

                    handler: function() {
                        this.$emit();
                    }
                }

            ]

        };

        // Deprecated
        var Gif = {

            update: {

                read: function(data) {

                    var inview = isInView(this.$el);

                    if (!inview || data.isInView === inview) {
                        return false;
                    }

                    data.isInView = inview;
                },

                write: function() {
                    this.$el.src = this.$el.src;
                },

                events: ['scroll', 'resize']
            }

        };

        var Margin = {

            props: {
                margin: String,
                firstColumn: Boolean
            },

            data: {
                margin: 'uk-margin-small-top',
                firstColumn: 'uk-first-column'
            },

            update: {

                read: function(data) {

                    var items = this.$el.children;
                    var rows = [[]];

                    if (!items.length || !isVisible(this.$el)) {
                        return data.rows = rows;
                    }

                    data.rows = getRows(items);
                    data.stacks = !data.rows.some(function (row) { return row.length > 1; });

                },

                write: function(ref) {
                    var this$1 = this;
                    var rows = ref.rows;


                    rows.forEach(function (row, i) { return row.forEach(function (el, j) {
                            toggleClass(el, this$1.margin, i !== 0);
                            toggleClass(el, this$1.firstColumn, j === 0);
                        }); }
                    );

                },

                events: ['resize']

            }

        };

        function getRows(items) {
            var rows = [[]];

            for (var i = 0; i < items.length; i++) {

                var el = items[i];
                var dim = getOffset(el);

                if (!dim.height) {
                    continue;
                }

                for (var j = rows.length - 1; j >= 0; j--) {

                    var row = rows[j];

                    if (!row[0]) {
                        row.push(el);
                        break;
                    }

                    var leftDim = (void 0);
                    if (row[0].offsetParent === el.offsetParent) {
                        leftDim = getOffset(row[0]);
                    } else {
                        dim = getOffset(el, true);
                        leftDim = getOffset(row[0], true);
                    }

                    if (dim.top >= leftDim.bottom - 1) {
                        rows.push([el]);
                        break;
                    }

                    if (dim.bottom > leftDim.top) {

                        if (dim.left < leftDim.left && !isRtl) {
                            row.unshift(el);
                            break;
                        }

                        row.push(el);
                        break;
                    }

                    if (j === 0) {
                        rows.unshift([el]);
                        break;
                    }

                }

            }

            return rows;

        }

        function getOffset(element, offset) {
            var assign;

            if ( offset === void 0 ) offset = false;

            var offsetTop = element.offsetTop;
            var offsetLeft = element.offsetLeft;
            var offsetHeight = element.offsetHeight;

            if (offset) {
                (assign = offsetPosition(element), offsetTop = assign[0], offsetLeft = assign[1]);
            }

            return {
                top: offsetTop,
                left: offsetLeft,
                height: offsetHeight,
                bottom: offsetTop + offsetHeight
            };
        }

        var Grid = {

            extends: Margin,

            mixins: [Class],

            name: 'grid',

            props: {
                masonry: Boolean,
                parallax: Number
            },

            data: {
                margin: 'uk-grid-margin',
                clsStack: 'uk-grid-stack',
                masonry: false,
                parallax: 0
            },

            computed: {

                length: function(_, $el) {
                    return $el.children.length;
                },

                parallax: function(ref) {
                    var parallax = ref.parallax;

                    return parallax && this.length ? Math.abs(parallax) : '';
                }

            },

            connected: function() {
                this.masonry && addClass(this.$el, 'uk-flex-top uk-flex-wrap-top');
            },

            update: [

                {

                    read: function(ref) {
                        var rows = ref.rows;


                        if (this.masonry || this.parallax) {
                            rows = rows.map(function (elements) { return sortBy(elements, 'offsetLeft'); });

                            if (isRtl) {
                                rows.map(function (row) { return row.reverse(); });
                            }

                        }

                        var transitionInProgress = rows.some(function (elements) { return elements.some(Transition.inProgress); });
                        var translates = false;
                        var elHeight = '';

                        if (this.masonry && this.length) {

                            var height = 0;

                            translates = rows.reduce(function (translates, row, i) {

                                translates[i] = row.map(function (_, j) { return i === 0 ? 0 : toFloat(translates[i - 1][j]) + (height - toFloat(rows[i - 1][j] && rows[i - 1][j].offsetHeight)); });
                                height = row.reduce(function (height, el) { return Math.max(height, el.offsetHeight); }, 0);

                                return translates;

                            }, []);

                            elHeight = maxColumnHeight(rows) + getMarginTop(this.$el, this.margin) * (rows.length - 1);

                        }

                        return {rows: rows, translates: translates, height: !transitionInProgress ? elHeight : false};

                    },

                    write: function(ref) {
                        var stacks = ref.stacks;
                        var height = ref.height;


                        toggleClass(this.$el, this.clsStack, stacks);

                        css(this.$el, 'paddingBottom', this.parallax);
                        height !== false && css(this.$el, 'height', height);

                    },

                    events: ['resize']

                },

                {

                    read: function(ref) {
                        var height$1 = ref.height;

                        return {
                            scrolled: this.parallax
                                ? scrolledOver(this.$el, height$1 ? height$1 - height(this.$el) : 0) * this.parallax
                                : false
                        };
                    },

                    write: function(ref) {
                        var rows = ref.rows;
                        var scrolled = ref.scrolled;
                        var translates = ref.translates;


                        if (scrolled === false && !translates) {
                            return;
                        }

                        rows.forEach(function (row, i) { return row.forEach(function (el, j) { return css(el, 'transform', !scrolled && !translates ? '' : ("translateY(" + ((translates && -translates[i][j]) + (scrolled ? j % 2 ? scrolled : scrolled / 8 : 0)) + "px)")); }
                            ); }
                        );

                    },

                    events: ['scroll', 'resize']

                }

            ]

        };

        function getMarginTop(root, cls) {

            var nodes = toNodes(root.children);
            var ref = nodes.filter(function (el) { return hasClass(el, cls); });
            var node = ref[0];

            return toFloat(node
                ? css(node, 'marginTop')
                : css(nodes[0], 'paddingLeft'));
        }

        function maxColumnHeight(rows) {
            return Math.max.apply(Math, rows.reduce(function (sum, row) {
                row.forEach(function (el, i) { return sum[i] = (sum[i] || 0) + el.offsetHeight; });
                return sum;
            }, []));
        }

        // IE 11 fix (min-height on a flex container won't apply to its flex items)
        var FlexBug = isIE ? {

            data: {
                selMinHeight: false,
                forceHeight: false
            },

            computed: {

                elements: function(ref, $el) {
                    var selMinHeight = ref.selMinHeight;

                    return selMinHeight ? $$(selMinHeight, $el) : [$el];
                }

            },

            update: [

                {

                    read: function() {
                        css(this.elements, 'height', '');
                    },

                    order: -5,

                    events: ['resize']

                },

                {

                    write: function() {
                        var this$1 = this;

                        this.elements.forEach(function (el) {
                            var height = toFloat(css(el, 'minHeight'));
                            if (height && (this$1.forceHeight || Math.round(height + boxModelAdjust('height', el, 'content-box')) >= el.offsetHeight)) {
                                css(el, 'height', height);
                            }
                        });
                    },

                    order: 5,

                    events: ['resize']

                }

            ]

        } : {};

        var HeightMatch = {

            mixins: [FlexBug],

            args: 'target',

            props: {
                target: String,
                row: Boolean
            },

            data: {
                target: '> *',
                row: true,
                forceHeight: true
            },

            computed: {

                elements: function(ref, $el) {
                    var target = ref.target;

                    return $$(target, $el);
                }

            },

            update: {

                read: function() {
                    return {
                        rows: (this.row ? getRows(this.elements) : [this.elements]).map(match)
                    };
                },

                write: function(ref) {
                    var rows = ref.rows;

                    rows.forEach(function (ref) {
                            var heights = ref.heights;
                            var elements = ref.elements;

                            return elements.forEach(function (el, i) { return css(el, 'minHeight', heights[i]); }
                        );
                    }
                    );
                },

                events: ['resize']

            }

        };

        function match(elements) {
            var assign;


            if (elements.length < 2) {
                return {heights: [''], elements: elements};
            }

            var ref = getHeights(elements);
            var heights = ref.heights;
            var max = ref.max;
            var hasMinHeight = elements.some(function (el) { return el.style.minHeight; });
            var hasShrunk = elements.some(function (el, i) { return !el.style.minHeight && heights[i] < max; });

            if (hasMinHeight && hasShrunk) {
                css(elements, 'minHeight', '');
                ((assign = getHeights(elements), heights = assign.heights, max = assign.max));
            }

            heights = elements.map(function (el, i) { return heights[i] === max && toFloat(el.style.minHeight).toFixed(2) !== max.toFixed(2) ? '' : max; }
            );

            return {heights: heights, elements: elements};
        }

        function getHeights(elements) {
            var heights = elements.map(function (el) { return offset(el).height - boxModelAdjust('height', el, 'content-box'); });
            var max = Math.max.apply(null, heights);

            return {heights: heights, max: max};
        }

        var HeightViewport = {

            mixins: [FlexBug],

            props: {
                expand: Boolean,
                offsetTop: Boolean,
                offsetBottom: Boolean,
                minHeight: Number
            },

            data: {
                expand: false,
                offsetTop: false,
                offsetBottom: false,
                minHeight: 0
            },

            update: {

                read: function(ref) {
                    var prev = ref.minHeight;


                    var minHeight = '';
                    var box = boxModelAdjust('height', this.$el, 'content-box');

                    if (this.expand) {

                        minHeight = height(window) - (offsetHeight(document.documentElement) - offsetHeight(this.$el)) - box || '';

                    } else {

                        // on mobile devices (iOS and Android) window.innerHeight !== 100vh
                        minHeight = 'calc(100vh';

                        if (this.offsetTop) {

                            var ref$1 = offset(this.$el);
                            var top = ref$1.top;
                            minHeight += top < height(window) / 2 ? (" - " + top + "px") : '';

                        }

                        if (this.offsetBottom === true) {

                            minHeight += " - " + (offsetHeight(this.$el.nextElementSibling)) + "px";

                        } else if (isNumeric(this.offsetBottom)) {

                            minHeight += " - " + (this.offsetBottom) + "vh";

                        } else if (this.offsetBottom && endsWith(this.offsetBottom, 'px')) {

                            minHeight += " - " + (toFloat(this.offsetBottom)) + "px";

                        } else if (isString(this.offsetBottom)) {

                            minHeight += " - " + (offsetHeight(query(this.offsetBottom, this.$el))) + "px";

                        }

                        minHeight += (box ? (" - " + box + "px") : '') + ")";

                    }

                    return {minHeight: minHeight, prev: prev};
                },

                write: function(ref) {
                    var minHeight = ref.minHeight;
                    var prev = ref.prev;


                    css(this.$el, {minHeight: minHeight});

                    if (minHeight !== prev) {
                        this.$update(this.$el, 'resize');
                    }

                    if (this.minHeight && toFloat(css(this.$el, 'minHeight')) < this.minHeight) {
                        css(this.$el, 'minHeight', this.minHeight);
                    }

                },

                events: ['resize']

            }

        };

        function offsetHeight(el) {
            return el && el.offsetHeight || 0;
        }

        var Svg = {

            args: 'src',

            props: {
                id: Boolean,
                icon: String,
                src: String,
                style: String,
                width: Number,
                height: Number,
                ratio: Number,
                'class': String,
                strokeAnimation: Boolean,
                attributes: 'list'
            },

            data: {
                ratio: 1,
                include: ['style', 'class'],
                'class': '',
                strokeAnimation: false
            },

            beforeConnect: function() {
                var this$1 = this;
                var assign;


                this.class += ' uk-svg';

                if (!this.icon && includes(this.src, '#')) {

                    var parts = this.src.split('#');

                    if (parts.length > 1) {
                        (assign = parts, this.src = assign[0], this.icon = assign[1]);
                    }
                }

                this.svg = this.getSvg().then(function (el) {
                    this$1.applyAttributes(el);
                    return this$1.svgEl = insertSVG(el, this$1.$el);
                }, noop);

            },

            disconnected: function() {
                var this$1 = this;


                if (isVoidElement(this.$el)) {
                    attr(this.$el, 'hidden', null);
                }

                if (this.svg) {
                    this.svg.then(function (svg) { return (!this$1._connected || svg !== this$1.svgEl) && remove(svg); }, noop);
                }

                this.svg = this.svgEl = null;

            },

            update: {

                read: function() {
                    return !!(this.strokeAnimation && this.svgEl && isVisible(this.svgEl));
                },

                write: function() {
                    applyAnimation(this.svgEl);
                },

                type: ['resize']

            },

            methods: {

                getSvg: function() {
                    var this$1 = this;

                    return loadSVG(this.src).then(function (svg) { return parseSVG(svg, this$1.icon) || Promise.reject('SVG not found.'); }
                    );
                },

                applyAttributes: function(el) {
                    var this$1 = this;


                    for (var prop in this.$options.props) {
                        if (this[prop] && includes(this.include, prop)) {
                            attr(el, prop, this[prop]);
                        }
                    }

                    for (var attribute in this.attributes) {
                        var ref = this.attributes[attribute].split(':', 2);
                        var prop$1 = ref[0];
                        var value = ref[1];
                        attr(el, prop$1, value);
                    }

                    if (!this.id) {
                        removeAttr(el, 'id');
                    }

                    var props = ['width', 'height'];
                    var dimensions = [this.width, this.height];

                    if (!dimensions.some(function (val) { return val; })) {
                        dimensions = props.map(function (prop) { return attr(el, prop); });
                    }

                    var viewBox = attr(el, 'viewBox');
                    if (viewBox && !dimensions.some(function (val) { return val; })) {
                        dimensions = viewBox.split(' ').slice(2);
                    }

                    dimensions.forEach(function (val, i) {
                        val = (val | 0) * this$1.ratio;
                        val && attr(el, props[i], val);

                        if (val && !dimensions[i ^ 1]) {
                            removeAttr(el, props[i ^ 1]);
                        }
                    });

                    attr(el, 'data-svg', this.icon || this.src);

                }

            }

        };

        var svgs = {};

        function loadSVG(src) {

            if (svgs[src]) {
                return svgs[src];
            }

            return svgs[src] = new Promise(function (resolve, reject) {

                if (!src) {
                    reject();
                    return;
                }

                if (startsWith(src, 'data:')) {
                    resolve(decodeURIComponent(src.split(',')[1]));
                } else {

                    ajax(src).then(
                        function (xhr) { return resolve(xhr.response); },
                        function () { return reject('SVG not found.'); }
                    );

                }

            });
        }

        function parseSVG(svg, icon) {

            if (icon && includes(svg, '<symbol')) {
                svg = parseSymbols(svg, icon) || svg;
            }

            svg = $(svg.substr(svg.indexOf('<svg')));
            return svg && svg.hasChildNodes() && svg;
        }

        var symbolRe = /<symbol(.*?id=(['"])(.*?)\2[^]*?<\/)symbol>/g;
        var symbols = {};

        function parseSymbols(svg, icon) {

            if (!symbols[svg]) {

                symbols[svg] = {};

                var match;
                while ((match = symbolRe.exec(svg))) {
                    symbols[svg][match[3]] = "<svg xmlns=\"http://www.w3.org/2000/svg\"" + (match[1]) + "svg>";
                }

                symbolRe.lastIndex = 0;

            }

            return symbols[svg][icon];
        }

        function applyAnimation(el) {

            var length = getMaxPathLength(el);

            if (length) {
                el.style.setProperty('--uk-animation-stroke', length);
            }

        }

        function getMaxPathLength(el) {
            return Math.ceil(Math.max.apply(Math, $$('[stroke]', el).map(function (stroke) { return stroke.getTotalLength && stroke.getTotalLength() || 0; }
            ).concat([0])));
        }

        function insertSVG(el, root) {
            if (isVoidElement(root) || root.tagName === 'CANVAS') {

                attr(root, 'hidden', true);

                var next = root.nextElementSibling;
                return equals(el, next)
                    ? next
                    : after(root, el);

            } else {

                var last = root.lastElementChild;
                return equals(el, last)
                    ? last
                    : append(root, el);

            }
        }

        function equals(el, other) {
            return attr(el, 'data-svg') === attr(other, 'data-svg');
        }

        var closeIcon = "<svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" xmlns=\"http://www.w3.org/2000/svg\"><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"1\" y1=\"1\" x2=\"13\" y2=\"13\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"13\" y1=\"1\" x2=\"1\" y2=\"13\"/></svg>";

        var closeLarge = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" x1=\"1\" y1=\"1\" x2=\"19\" y2=\"19\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" x1=\"19\" y1=\"1\" x2=\"1\" y2=\"19\"/></svg>";

        var marker = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"9\" y=\"4\" width=\"1\" height=\"11\"/><rect x=\"4\" y=\"9\" width=\"11\" height=\"1\"/></svg>";

        var navbarToggleIcon = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect y=\"9\" width=\"20\" height=\"2\"/><rect y=\"3\" width=\"20\" height=\"2\"/><rect y=\"15\" width=\"20\" height=\"2\"/></svg>";

        var overlayIcon = "<svg width=\"40\" height=\"40\" viewBox=\"0 0 40 40\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"19\" y=\"0\" width=\"1\" height=\"40\"/><rect x=\"0\" y=\"19\" width=\"40\" height=\"1\"/></svg>";

        var paginationNext = "<svg width=\"7\" height=\"12\" viewBox=\"0 0 7 12\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"1 1 6 6 1 11\"/></svg>";

        var paginationPrevious = "<svg width=\"7\" height=\"12\" viewBox=\"0 0 7 12\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"6 1 1 6 6 11\"/></svg>";

        var searchIcon = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9\" cy=\"9\" r=\"7\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M14,14 L18,18 L14,14 Z\"/></svg>";

        var searchLarge = "<svg width=\"40\" height=\"40\" viewBox=\"0 0 40 40\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.8\" cx=\"17.5\" cy=\"17.5\" r=\"16.5\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.8\" x1=\"38\" y1=\"39\" x2=\"29\" y2=\"30\"/></svg>";

        var searchNavbar = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10.5\" cy=\"10.5\" r=\"9.5\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"23\" y1=\"23\" x2=\"17\" y2=\"17\"/></svg>";

        var slidenavNext = "<svg width=\"14px\" height=\"24px\" viewBox=\"0 0 14 24\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" points=\"1.225,23 12.775,12 1.225,1 \"/></svg>";

        var slidenavNextLarge = "<svg width=\"25px\" height=\"40px\" viewBox=\"0 0 25 40\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"2\" points=\"4.002,38.547 22.527,20.024 4,1.5 \"/></svg>";

        var slidenavPrevious = "<svg width=\"14px\" height=\"24px\" viewBox=\"0 0 14 24\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" points=\"12.775,1 1.225,12 12.775,23 \"/></svg>";

        var slidenavPreviousLarge = "<svg width=\"25px\" height=\"40px\" viewBox=\"0 0 25 40\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"2\" points=\"20.527,1.5 2,20.024 20.525,38.547 \"/></svg>";

        var spinner = "<svg width=\"30\" height=\"30\" viewBox=\"0 0 30 30\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" cx=\"15\" cy=\"15\" r=\"14\"/></svg>";

        var totop = "<svg width=\"18\" height=\"10\" viewBox=\"0 0 18 10\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"1 9 9 1 17 9 \"/></svg>";

        var parsed = {};
        var icons = {
            spinner: spinner,
            totop: totop,
            marker: marker,
            'close-icon': closeIcon,
            'close-large': closeLarge,
            'navbar-toggle-icon': navbarToggleIcon,
            'overlay-icon': overlayIcon,
            'pagination-next': paginationNext,
            'pagination-previous': paginationPrevious,
            'search-icon': searchIcon,
            'search-large': searchLarge,
            'search-navbar': searchNavbar,
            'slidenav-next': slidenavNext,
            'slidenav-next-large': slidenavNextLarge,
            'slidenav-previous': slidenavPrevious,
            'slidenav-previous-large': slidenavPreviousLarge
        };

        var Icon = {

            install: install,

            extends: Svg,

            args: 'icon',

            props: ['icon'],

            data: {include: []},

            isIcon: true,

            beforeConnect: function() {
                addClass(this.$el, 'uk-icon');
            },

            methods: {

                getSvg: function() {

                    var icon = getIcon(applyRtl(this.icon));

                    if (!icon) {
                        return Promise.reject('Icon not found.');
                    }

                    return Promise.resolve(icon);
                }

            }

        };

        var IconComponent = {

            args: false,

            extends: Icon,

            data: function (vm) { return ({
                icon: hyphenate(vm.constructor.options.name)
            }); },

            beforeConnect: function() {
                addClass(this.$el, this.$name);
            }

        };

        var Slidenav = {

            extends: IconComponent,

            beforeConnect: function() {
                addClass(this.$el, 'uk-slidenav');
            },

            computed: {

                icon: function(ref, $el) {
                    var icon = ref.icon;

                    return hasClass($el, 'uk-slidenav-large')
                        ? (icon + "-large")
                        : icon;
                }

            }

        };

        var Search = {

            extends: IconComponent,

            computed: {

                icon: function(ref, $el) {
                    var icon = ref.icon;

                    return hasClass($el, 'uk-search-icon') && parents($el, '.uk-search-large').length
                        ? 'search-large'
                        : parents($el, '.uk-search-navbar').length
                            ? 'search-navbar'
                            : icon;
                }

            }

        };

        var Close = {

            extends: IconComponent,

            computed: {

                icon: function() {
                    return ("close-" + (hasClass(this.$el, 'uk-close-large') ? 'large' : 'icon'));
                }

            }

        };

        var Spinner = {

            extends: IconComponent,

            connected: function() {
                var this$1 = this;

                this.svg.then(function (svg) { return this$1.ratio !== 1 && css($('circle', svg), 'strokeWidth', 1 / this$1.ratio); }, noop);
            }

        };

        function install(UIkit) {
            UIkit.icon.add = function (name, svg) {
                var obj;


                var added = isString(name) ? (( obj = {}, obj[name] = svg, obj )) : name;
                each(added, function (svg, name) {
                    icons[name] = svg;
                    delete parsed[name];
                });

                if (UIkit._initialized) {
                    apply(document.body, function (el) { return each(UIkit.getComponents(el), function (cmp) {
                            cmp.$options.isIcon && cmp.icon in added && cmp.$reset();
                        }); }
                    );
                }
            };
        }

        function getIcon(icon) {

            if (!icons[icon]) {
                return null;
            }

            if (!parsed[icon]) {
                parsed[icon] = $(icons[icon].trim());
            }

            return parsed[icon].cloneNode(true);
        }

        function applyRtl(icon) {
            return isRtl ? swap(swap(icon, 'left', 'right'), 'previous', 'next') : icon;
        }

        var Img = {

            args: 'dataSrc',

            props: {
                dataSrc: String,
                dataSrcset: Boolean,
                sizes: String,
                width: Number,
                height: Number,
                offsetTop: String,
                offsetLeft: String,
                target: String
            },

            data: {
                dataSrc: '',
                dataSrcset: false,
                sizes: false,
                width: false,
                height: false,
                offsetTop: '50vh',
                offsetLeft: 0,
                target: false
            },

            computed: {

                cacheKey: function(ref) {
                    var dataSrc = ref.dataSrc;

                    return ((this.$name) + "." + dataSrc);
                },

                width: function(ref) {
                    var width = ref.width;
                    var dataWidth = ref.dataWidth;

                    return width || dataWidth;
                },

                height: function(ref) {
                    var height = ref.height;
                    var dataHeight = ref.dataHeight;

                    return height || dataHeight;
                },

                sizes: function(ref) {
                    var sizes = ref.sizes;
                    var dataSizes = ref.dataSizes;

                    return sizes || dataSizes;
                },

                isImg: function(_, $el) {
                    return isImg($el);
                },

                target: {

                    get: function(ref) {
                        var target = ref.target;

                        return [this.$el].concat(queryAll(target, this.$el));
                    },

                    watch: function() {
                        this.observe();
                    }

                },

                offsetTop: function(ref) {
                    var offsetTop = ref.offsetTop;

                    return toPx(offsetTop, 'height');
                },

                offsetLeft: function(ref) {
                    var offsetLeft = ref.offsetLeft;

                    return toPx(offsetLeft, 'width');
                }

            },

            connected: function() {

                if (storage[this.cacheKey]) {
                    setSrcAttrs(this.$el, storage[this.cacheKey] || this.dataSrc, this.dataSrcset, this.sizes);
                } else if (this.isImg && this.width && this.height) {
                    setSrcAttrs(this.$el, getPlaceholderImage(this.width, this.height, this.sizes));
                }

                this.observer = new IntersectionObserver(this.load, {
                    rootMargin: ((this.offsetTop) + "px " + (this.offsetLeft) + "px")
                });

                requestAnimationFrame(this.observe);

            },

            disconnected: function() {
                this.observer.disconnect();
            },

            update: {

                read: function(ref) {
                    var this$1 = this;
                    var image = ref.image;


                    if (!image && document.readyState === 'complete') {
                        this.load(this.observer.takeRecords());
                    }

                    if (this.isImg) {
                        return false;
                    }

                    image && image.then(function (img) { return img && img.currentSrc !== '' && setSrcAttrs(this$1.$el, currentSrc(img)); });

                },

                write: function(data) {

                    if (this.dataSrcset && window.devicePixelRatio !== 1) {

                        var bgSize = css(this.$el, 'backgroundSize');
                        if (bgSize.match(/^(auto\s?)+$/) || toFloat(bgSize) === data.bgSize) {
                            data.bgSize = getSourceSize(this.dataSrcset, this.sizes);
                            css(this.$el, 'backgroundSize', ((data.bgSize) + "px"));
                        }

                    }

                },

                events: ['resize']

            },

            methods: {

                load: function(entries) {
                    var this$1 = this;


                    if (!entries.some(function (entry) { return entry.isIntersecting; })) {
                        return;
                    }

                    this._data.image = getImage(this.dataSrc, this.dataSrcset, this.sizes).then(function (img) {

                        setSrcAttrs(this$1.$el, currentSrc(img), img.srcset, img.sizes);
                        storage[this$1.cacheKey] = currentSrc(img);
                        return img;

                    }, noop);

                    this.observer.disconnect();
                },

                observe: function() {
                    var this$1 = this;

                    if (!this._data.image && this._connected) {
                        this.target.forEach(function (el) { return this$1.observer.observe(el); });
                    }
                }

            }

        };

        function setSrcAttrs(el, src, srcset, sizes) {

            if (isImg(el)) {
                sizes && (el.sizes = sizes);
                srcset && (el.srcset = srcset);
                src && (el.src = src);
            } else if (src) {

                var change = !includes(el.style.backgroundImage, src);
                if (change) {
                    css(el, 'backgroundImage', ("url(" + (escape(src)) + ")"));
                    trigger(el, createEvent('load', false));
                }

            }

        }

        function getPlaceholderImage(width, height, sizes) {
            var assign;


            if (sizes) {
                ((assign = Dimensions.ratio({width: width, height: height}, 'width', toPx(sizesToPixel(sizes))), width = assign.width, height = assign.height));
            }

            return ("data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"" + width + "\" height=\"" + height + "\"></svg>");
        }

        var sizesRe = /\s*(.*?)\s*(\w+|calc\(.*?\))\s*(?:,|$)/g;
        function sizesToPixel(sizes) {
            var matches;

            sizesRe.lastIndex = 0;

            while ((matches = sizesRe.exec(sizes))) {
                if (!matches[1] || window.matchMedia(matches[1]).matches) {
                    matches = evaluateSize(matches[2]);
                    break;
                }
            }

            return matches || '100vw';
        }

        var sizeRe = /\d+(?:\w+|%)/g;
        var additionRe = /[+-]?(\d+)/g;
        function evaluateSize(size) {
            return startsWith(size, 'calc')
                ? size
                    .substring(5, size.length - 1)
                    .replace(sizeRe, function (size) { return toPx(size); })
                    .replace(/ /g, '')
                    .match(additionRe)
                    .reduce(function (a, b) { return a + +b; }, 0)
                : size;
        }

        var srcSetRe = /\s+\d+w\s*(?:,|$)/g;
        function getSourceSize(srcset, sizes) {
            var srcSize = toPx(sizesToPixel(sizes));
            var descriptors = (srcset.match(srcSetRe) || []).map(toFloat).sort(function (a, b) { return a - b; });

            return descriptors.filter(function (size) { return size >= srcSize; })[0] || descriptors.pop() || '';
        }

        function isImg(el) {
            return el.tagName === 'IMG';
        }

        function currentSrc(el) {
            return el.currentSrc || el.src;
        }

        var key = '__test__';
        var storage;

        // workaround for Safari's private browsing mode and accessing sessionStorage in Blink
        try {
            storage = window.sessionStorage || {};
            storage[key] = 1;
            delete storage[key];
        } catch (e) {
            storage = {};
        }

        var Media = {

            props: {
                media: Boolean
            },

            data: {
                media: false
            },

            computed: {

                matchMedia: function() {
                    var media = toMedia(this.media);
                    return !media || window.matchMedia(media).matches;
                }

            }

        };

        function toMedia(value) {

            if (isString(value)) {
                if (value[0] === '@') {
                    var name = "breakpoint-" + (value.substr(1));
                    value = toFloat(getCssVar(name));
                } else if (isNaN(value)) {
                    return value;
                }
            }

            return value && !isNaN(value) ? ("(min-width: " + value + "px)") : false;
        }

        var Leader = {

            mixins: [Class, Media],

            props: {
                fill: String
            },

            data: {
                fill: '',
                clsWrapper: 'uk-leader-fill',
                clsHide: 'uk-leader-hide',
                attrFill: 'data-fill'
            },

            computed: {

                fill: function(ref) {
                    var fill = ref.fill;

                    return fill || getCssVar('leader-fill-content');
                }

            },

            connected: function() {
                var assign;

                (assign = wrapInner(this.$el, ("<span class=\"" + (this.clsWrapper) + "\">")), this.wrapper = assign[0]);
            },

            disconnected: function() {
                unwrap(this.wrapper.childNodes);
            },

            update: {

                read: function(ref) {
                    var changed = ref.changed;
                    var width = ref.width;


                    var prev = width;

                    width = Math.floor(this.$el.offsetWidth / 2);

                    return {
                        width: width,
                        fill: this.fill,
                        changed: changed || prev !== width,
                        hide: !this.matchMedia
                    };
                },

                write: function(data) {

                    toggleClass(this.wrapper, this.clsHide, data.hide);

                    if (data.changed) {
                        data.changed = false;
                        attr(this.wrapper, this.attrFill, new Array(data.width).join(data.fill));
                    }

                },

                events: ['resize']

            }

        };

        var Container = {

            props: {
                container: Boolean
            },

            data: {
                container: true
            },

            computed: {

                container: function(ref) {
                    var container = ref.container;

                    return container === true && this.$container || container && $(container);
                }

            }

        };

        var active$1;

        var Modal = {

            mixins: [Class, Container, Togglable],

            props: {
                selPanel: String,
                selClose: String,
                escClose: Boolean,
                bgClose: Boolean,
                stack: Boolean
            },

            data: {
                cls: 'uk-open',
                escClose: true,
                bgClose: true,
                overlay: true,
                stack: false
            },

            computed: {

                panel: function(ref, $el) {
                    var selPanel = ref.selPanel;

                    return $(selPanel, $el);
                },

                transitionElement: function() {
                    return this.panel;
                },

                bgClose: function(ref) {
                    var bgClose = ref.bgClose;

                    return bgClose && this.panel;
                }

            },

            beforeDisconnect: function() {
                if (this.isToggled()) {
                    this.toggleNow(this.$el, false);
                }
            },

            events: [

                {

                    name: 'click',

                    delegate: function() {
                        return this.selClose;
                    },

                    handler: function(e) {
                        e.preventDefault();
                        this.hide();
                    }

                },

                {

                    name: 'toggle',

                    self: true,

                    handler: function(e) {

                        if (e.defaultPrevented) {
                            return;
                        }

                        e.preventDefault();
                        this.toggle();
                    }

                },

                {
                    name: 'beforeshow',

                    self: true,

                    handler: function(e) {

                        var prev = active$1 && active$1 !== this && active$1;

                        active$1 = this;

                        if (prev) {
                            if (this.stack) {
                                this.prev = prev;
                            } else {

                                active$1 = prev;

                                if (prev.isToggled()) {
                                    prev.hide().then(this.show);
                                } else {
                                    once(prev.$el, 'beforeshow hidden', this.show, false, function (ref) {
                                        var target = ref.target;
                                        var type = ref.type;

                                        return type === 'hidden' && target === prev.$el;
                                    });
                                }
                                e.preventDefault();

                            }

                            return;
                        }

                        registerEvents();

                    }

                },

                {

                    name: 'show',

                    self: true,

                    handler: function() {

                        if (!hasClass(document.documentElement, this.clsPage)) {
                            this.scrollbarWidth = width(window) - width(document);
                            css(document.body, 'overflowY', this.scrollbarWidth && this.overlay ? 'scroll' : '');
                        }

                        addClass(document.documentElement, this.clsPage);

                    }

                },

                {

                    name: 'hide',

                    self: true,

                    handler: function() {
                        if (!active$1 || active$1 === this && !this.prev) {
                            deregisterEvents();
                        }
                    }

                },

                {

                    name: 'hidden',

                    self: true,

                    handler: function() {

                        var found;
                        var ref = this;
                        var prev = ref.prev;

                        active$1 = active$1 && active$1 !== this && active$1 || prev;

                        if (!active$1) {

                            css(document.body, 'overflowY', '');

                        } else {
                            while (prev) {

                                if (prev.clsPage === this.clsPage) {
                                    found = true;
                                    break;
                                }

                                prev = prev.prev;

                            }

                        }

                        if (!found) {
                            removeClass(document.documentElement, this.clsPage);
                        }

                    }

                }

            ],

            methods: {

                toggle: function() {
                    return this.isToggled() ? this.hide() : this.show();
                },

                show: function() {
                    var this$1 = this;


                    if (this.isToggled()) {
                        return Promise.resolve();
                    }

                    if (this.container && this.$el.parentNode !== this.container) {
                        append(this.container, this.$el);
                        return new Promise(function (resolve) { return requestAnimationFrame(function () { return this$1.show().then(resolve); }
                            ); }
                        );
                    }

                    return this.toggleElement(this.$el, true, animate$1(this));
                },

                hide: function() {
                    return this.isToggled()
                        ? this.toggleElement(this.$el, false, animate$1(this))
                        : Promise.resolve();
                },

                getActive: function() {
                    return active$1;
                }

            }

        };

        var events;

        function registerEvents() {

            if (events) {
                return;
            }

            events = [
                on(document, pointerUp, function (ref) {
                    var target = ref.target;
                    var defaultPrevented = ref.defaultPrevented;

                    if (active$1 && active$1.bgClose && !defaultPrevented && (!active$1.overlay || within(target, active$1.$el)) && !within(target, active$1.panel)) {
                        active$1.hide();
                    }
                }),
                on(document, 'keydown', function (e) {
                    if (e.keyCode === 27 && active$1 && active$1.escClose) {
                        e.preventDefault();
                        active$1.hide();
                    }
                })
            ];
        }

        function deregisterEvents() {
            events && events.forEach(function (unbind) { return unbind(); });
            events = null;
        }

        function animate$1(ref) {
            var transitionElement = ref.transitionElement;
            var _toggle = ref._toggle;

            return function (el, show) { return new Promise(function (resolve, reject) { return once(el, 'show hide', function () {
                        el._reject && el._reject();
                        el._reject = reject;

                        _toggle(el, show);

                        if (toMs(css(transitionElement, 'transitionDuration'))) {
                            once(transitionElement, 'transitionend', resolve, false, function (e) { return e.target === transitionElement; });
                        } else {
                            resolve();
                        }
                    }); }
                ); };
        }

        var Modal$1 = {

            install: install$1,

            mixins: [Modal],

            data: {
                clsPage: 'uk-modal-page',
                selPanel: '.uk-modal-dialog',
                selClose: '.uk-modal-close, .uk-modal-close-default, .uk-modal-close-outside, .uk-modal-close-full'
            },

            events: [

                {
                    name: 'show',

                    self: true,

                    handler: function() {

                        if (hasClass(this.panel, 'uk-margin-auto-vertical')) {
                            addClass(this.$el, 'uk-flex');
                        } else {
                            css(this.$el, 'display', 'block');
                        }

                        height(this.$el); // force reflow
                    }
                },

                {
                    name: 'hidden',

                    self: true,

                    handler: function() {

                        css(this.$el, 'display', '');
                        removeClass(this.$el, 'uk-flex');

                    }
                }

            ]

        };

        function install$1(UIkit) {

            UIkit.modal.dialog = function (content, options) {

                var dialog = UIkit.modal((" <div class=\"uk-modal\"> <div class=\"uk-modal-dialog\">" + content + "</div> </div> "), options);

                dialog.show();

                on(dialog.$el, 'hidden', function (ref) {
                    var target = ref.target;
                    var currentTarget = ref.currentTarget;

                    if (target === currentTarget) {
                        Promise.resolve(function () { return dialog.$destroy(true); });
                    }
                });

                return dialog;
            };

            UIkit.modal.alert = function (message, options) {

                options = assign({bgClose: false, escClose: false, labels: UIkit.modal.labels}, options);

                return new Promise(
                    function (resolve) { return on(UIkit.modal.dialog((" <div class=\"uk-modal-body\">" + (isString(message) ? message : html(message)) + "</div> <div class=\"uk-modal-footer uk-text-right\"> <button class=\"uk-button uk-button-primary uk-modal-close\" autofocus>" + (options.labels.ok) + "</button> </div> "), options).$el, 'hide', resolve); }
                );
            };

            UIkit.modal.confirm = function (message, options) {

                options = assign({bgClose: false, escClose: true, labels: UIkit.modal.labels}, options);

                return new Promise(function (resolve, reject) {

                    var confirm = UIkit.modal.dialog((" <form> <div class=\"uk-modal-body\">" + (isString(message) ? message : html(message)) + "</div> <div class=\"uk-modal-footer uk-text-right\"> <button class=\"uk-button uk-button-default uk-modal-close\" type=\"button\">" + (options.labels.cancel) + "</button> <button class=\"uk-button uk-button-primary\" autofocus>" + (options.labels.ok) + "</button> </div> </form> "), options);

                    var resolved = false;

                    on(confirm.$el, 'submit', 'form', function (e) {
                        e.preventDefault();
                        resolve();
                        resolved = true;
                        confirm.hide();
                    });
                    on(confirm.$el, 'hide', function () {
                        if (!resolved) {
                            reject();
                        }
                    });

                });
            };

            UIkit.modal.prompt = function (message, value, options) {

                options = assign({bgClose: false, escClose: true, labels: UIkit.modal.labels}, options);

                return new Promise(function (resolve) {

                    var prompt = UIkit.modal.dialog((" <form class=\"uk-form-stacked\"> <div class=\"uk-modal-body\"> <label>" + (isString(message) ? message : html(message)) + "</label> <input class=\"uk-input\" autofocus> </div> <div class=\"uk-modal-footer uk-text-right\"> <button class=\"uk-button uk-button-default uk-modal-close\" type=\"button\">" + (options.labels.cancel) + "</button> <button class=\"uk-button uk-button-primary\">" + (options.labels.ok) + "</button> </div> </form> "), options),
                        input = $('input', prompt.$el);

                    input.value = value;

                    var resolved = false;

                    on(prompt.$el, 'submit', 'form', function (e) {
                        e.preventDefault();
                        resolve(input.value);
                        resolved = true;
                        prompt.hide();
                    });
                    on(prompt.$el, 'hide', function () {
                        if (!resolved) {
                            resolve(null);
                        }
                    });

                });
            };

            UIkit.modal.labels = {
                ok: 'Ok',
                cancel: 'Cancel'
            };

        }

        var Nav = {

            extends: Accordion,

            data: {
                targets: '> .uk-parent',
                toggle: '> a',
                content: '> ul'
            }

        };

        var Navbar = {

            mixins: [Class, FlexBug],

            props: {
                dropdown: String,
                mode: 'list',
                align: String,
                offset: Number,
                boundary: Boolean,
                boundaryAlign: Boolean,
                clsDrop: String,
                delayShow: Number,
                delayHide: Number,
                dropbar: Boolean,
                dropbarMode: String,
                dropbarAnchor: Boolean,
                duration: Number
            },

            data: {
                dropdown: '.uk-navbar-nav > li',
                align: !isRtl ? 'left' : 'right',
                clsDrop: 'uk-navbar-dropdown',
                mode: undefined,
                offset: undefined,
                delayShow: undefined,
                delayHide: undefined,
                boundaryAlign: undefined,
                flip: 'x',
                boundary: true,
                dropbar: false,
                dropbarMode: 'slide',
                dropbarAnchor: false,
                duration: 200,
                forceHeight: true,
                selMinHeight: '.uk-navbar-nav > li > a, .uk-navbar-item, .uk-navbar-toggle'
            },

            computed: {

                boundary: function(ref, $el) {
                    var boundary = ref.boundary;
                    var boundaryAlign = ref.boundaryAlign;

                    return (boundary === true || boundaryAlign) ? $el : boundary;
                },

                dropbarAnchor: function(ref, $el) {
                    var dropbarAnchor = ref.dropbarAnchor;

                    return query(dropbarAnchor, $el);
                },

                pos: function(ref) {
                    var align = ref.align;

                    return ("bottom-" + align);
                },

                dropdowns: function(ref, $el) {
                    var dropdown = ref.dropdown;
                    var clsDrop = ref.clsDrop;

                    return $$((dropdown + " ." + clsDrop), $el);
                }

            },

            beforeConnect: function() {

                var ref = this.$props;
                var dropbar = ref.dropbar;

                this.dropbar = dropbar && (query(dropbar, this.$el) || $('+ .uk-navbar-dropbar', this.$el) || $('<div></div>'));

                if (this.dropbar) {

                    addClass(this.dropbar, 'uk-navbar-dropbar');

                    if (this.dropbarMode === 'slide') {
                        addClass(this.dropbar, 'uk-navbar-dropbar-slide');
                    }
                }

            },

            disconnected: function() {
                this.dropbar && remove(this.dropbar);
            },

            update: function() {
                var this$1 = this;


                this.$create(
                    'drop',
                    this.dropdowns.filter(function (el) { return !this$1.getDropdown(el); }),
                    assign({}, this.$props, {boundary: this.boundary, pos: this.pos, offset: this.dropbar || this.offset})
                );

            },

            events: [

                {
                    name: 'mouseover',

                    delegate: function() {
                        return this.dropdown;
                    },

                    handler: function(ref) {
                        var current = ref.current;

                        var active = this.getActive();
                        if (active && active.toggle && !within(active.toggle.$el, current) && !active.tracker.movesTo(active.$el)) {
                            active.hide(false);
                        }
                    }

                },

                {
                    name: 'mouseleave',

                    el: function() {
                        return this.dropbar;
                    },

                    handler: function() {
                        var active = this.getActive();

                        if (active && !this.dropdowns.some(function (el) { return matches(el, ':hover'); })) {
                            active.hide();
                        }
                    }
                },

                {
                    name: 'beforeshow',

                    capture: true,

                    filter: function() {
                        return this.dropbar;
                    },

                    handler: function() {

                        if (!this.dropbar.parentNode) {
                            after(this.dropbarAnchor || this.$el, this.dropbar);
                        }

                    }
                },

                {
                    name: 'show',

                    capture: true,

                    filter: function() {
                        return this.dropbar;
                    },

                    handler: function(_, drop) {

                        var $el = drop.$el;
                        var dir = drop.dir;

                        this.clsDrop && addClass($el, ((this.clsDrop) + "-dropbar"));

                        if (dir === 'bottom') {
                            this.transitionTo($el.offsetHeight + toFloat(css($el, 'marginTop')) + toFloat(css($el, 'marginBottom')), $el);
                        }
                    }
                },

                {
                    name: 'beforehide',

                    filter: function() {
                        return this.dropbar;
                    },

                    handler: function(e, ref) {
                        var $el = ref.$el;


                        var active = this.getActive();

                        if (matches(this.dropbar, ':hover') && active && active.$el === $el) {
                            e.preventDefault();
                        }
                    }
                },

                {
                    name: 'hide',

                    filter: function() {
                        return this.dropbar;
                    },

                    handler: function(_, ref) {
                        var $el = ref.$el;


                        var active = this.getActive();

                        if (!active || active && active.$el === $el) {
                            this.transitionTo(0);
                        }
                    }
                }

            ],

            methods: {

                getActive: function() {
                    var ref = this.dropdowns.map(this.getDropdown).filter(function (drop) { return drop && drop.isActive(); });
                    var active = ref[0];
                    return active && includes(active.mode, 'hover') && within(active.toggle.$el, this.$el) && active;
                },

                transitionTo: function(newHeight, el) {
                    var this$1 = this;


                    var ref = this;
                    var dropbar = ref.dropbar;
                    var oldHeight = isVisible(dropbar) ? height(dropbar) : 0;

                    el = oldHeight < newHeight && el;

                    css(el, 'clip', ("rect(0," + (el.offsetWidth) + "px," + oldHeight + "px,0)"));

                    height(dropbar, oldHeight);

                    Transition.cancel([el, dropbar]);
                    return Promise.all([
                        Transition.start(dropbar, {height: newHeight}, this.duration),
                        Transition.start(el, {clip: ("rect(0," + (el.offsetWidth) + "px," + newHeight + "px,0)")}, this.duration)
                    ])
                        .catch(noop)
                        .then(function () {
                            css(el, {clip: ''});
                            this$1.$update(dropbar);
                        });
                },

                getDropdown: function(el) {
                    return this.$getComponent(el, 'drop') || this.$getComponent(el, 'dropdown');
                }

            }

        };

        var Offcanvas = {

            mixins: [Modal],

            args: 'mode',

            props: {
                mode: String,
                flip: Boolean,
                overlay: Boolean
            },

            data: {
                mode: 'slide',
                flip: false,
                overlay: false,
                clsPage: 'uk-offcanvas-page',
                clsContainer: 'uk-offcanvas-container',
                selPanel: '.uk-offcanvas-bar',
                clsFlip: 'uk-offcanvas-flip',
                clsContainerAnimation: 'uk-offcanvas-container-animation',
                clsSidebarAnimation: 'uk-offcanvas-bar-animation',
                clsMode: 'uk-offcanvas',
                clsOverlay: 'uk-offcanvas-overlay',
                selClose: '.uk-offcanvas-close'
            },

            computed: {

                clsFlip: function(ref) {
                    var flip = ref.flip;
                    var clsFlip = ref.clsFlip;

                    return flip ? clsFlip : '';
                },

                clsOverlay: function(ref) {
                    var overlay = ref.overlay;
                    var clsOverlay = ref.clsOverlay;

                    return overlay ? clsOverlay : '';
                },

                clsMode: function(ref) {
                    var mode = ref.mode;
                    var clsMode = ref.clsMode;

                    return (clsMode + "-" + mode);
                },

                clsSidebarAnimation: function(ref) {
                    var mode = ref.mode;
                    var clsSidebarAnimation = ref.clsSidebarAnimation;

                    return mode === 'none' || mode === 'reveal' ? '' : clsSidebarAnimation;
                },

                clsContainerAnimation: function(ref) {
                    var mode = ref.mode;
                    var clsContainerAnimation = ref.clsContainerAnimation;

                    return mode !== 'push' && mode !== 'reveal' ? '' : clsContainerAnimation;
                },

                transitionElement: function(ref) {
                    var mode = ref.mode;

                    return mode === 'reveal' ? this.panel.parentNode : this.panel;
                }

            },

            events: [

                {

                    name: 'click',

                    delegate: function() {
                        return 'a[href^="#"]';
                    },

                    handler: function(ref) {
                        var current = ref.current;

                        if (current.hash && $(current.hash, document.body)) {
                            this.hide();
                        }
                    }

                },

                {
                    name: 'touchstart',

                    passive: true,

                    el: function() {
                        return this.panel;
                    },

                    handler: function(ref) {
                        var targetTouches = ref.targetTouches;


                        if (targetTouches.length === 1) {
                            this.clientY = targetTouches[0].clientY;
                        }

                    }

                },

                {
                    name: 'touchmove',

                    self: true,
                    passive: false,

                    filter: function() {
                        return this.overlay;
                    },

                    handler: function(e) {
                        e.cancelable && e.preventDefault();
                    }

                },

                {
                    name: 'touchmove',

                    passive: false,

                    el: function() {
                        return this.panel;
                    },

                    handler: function(e) {

                        if (e.targetTouches.length !== 1) {
                            return;
                        }

                        var clientY = event.targetTouches[0].clientY - this.clientY;
                        var ref = this.panel;
                        var scrollTop = ref.scrollTop;
                        var scrollHeight = ref.scrollHeight;
                        var clientHeight = ref.clientHeight;

                        if (clientHeight >= scrollHeight
                            || scrollTop === 0 && clientY > 0
                            || scrollHeight - scrollTop <= clientHeight && clientY < 0
                        ) {
                            e.cancelable && e.preventDefault();
                        }

                    }

                },

                {
                    name: 'show',

                    self: true,

                    handler: function() {

                        if (this.mode === 'reveal' && !hasClass(this.panel.parentNode, this.clsMode)) {
                            wrapAll(this.panel, '<div>');
                            addClass(this.panel.parentNode, this.clsMode);
                        }

                        css(document.documentElement, 'overflowY', this.overlay ? 'hidden' : '');
                        addClass(document.body, this.clsContainer, this.clsFlip);
                        css(this.$el, 'display', 'block');
                        addClass(this.$el, this.clsOverlay);
                        addClass(this.panel, this.clsSidebarAnimation, this.mode !== 'reveal' ? this.clsMode : '');

                        height(document.body); // force reflow
                        addClass(document.body, this.clsContainerAnimation);

                        this.clsContainerAnimation && suppressUserScale();

                    }
                },

                {
                    name: 'hide',

                    self: true,

                    handler: function() {
                        removeClass(document.body, this.clsContainerAnimation);

                        var active = this.getActive();
                        if (this.mode === 'none' || active && active !== this && active !== this.prev) {
                            trigger(this.panel, 'transitionend');
                        }
                    }
                },

                {
                    name: 'hidden',

                    self: true,

                    handler: function() {

                        this.clsContainerAnimation && resumeUserScale();

                        if (this.mode === 'reveal') {
                            unwrap(this.panel);
                        }

                        removeClass(this.panel, this.clsSidebarAnimation, this.clsMode);
                        removeClass(this.$el, this.clsOverlay);
                        css(this.$el, 'display', '');
                        removeClass(document.body, this.clsContainer, this.clsFlip);

                        css(document.documentElement, 'overflowY', '');

                    }
                },

                {
                    name: 'swipeLeft swipeRight',

                    handler: function(e) {

                        if (this.isToggled() && endsWith(e.type, 'Left') ^ this.flip) {
                            this.hide();
                        }

                    }
                }

            ]

        };

        // Chrome in responsive mode zooms page upon opening offcanvas
        function suppressUserScale() {
            getViewport().content += ',user-scalable=0';
        }

        function resumeUserScale() {
            var viewport = getViewport();
            viewport.content = viewport.content.replace(/,user-scalable=0$/, '');
        }

        function getViewport() {
            return $('meta[name="viewport"]', document.head) || append(document.head, '<meta name="viewport">');
        }

        var OverflowAuto = {

            mixins: [Class],

            props: {
                selContainer: String,
                selContent: String
            },

            data: {
                selContainer: '.uk-modal',
                selContent: '.uk-modal-dialog'
            },

            computed: {

                container: function(ref, $el) {
                    var selContainer = ref.selContainer;

                    return closest($el, selContainer);
                },

                content: function(ref, $el) {
                    var selContent = ref.selContent;

                    return closest($el, selContent);
                }

            },

            connected: function() {
                css(this.$el, 'minHeight', 150);
            },

            update: {

                read: function() {

                    if (!this.content || !this.container) {
                        return false;
                    }

                    return {
                        current: toFloat(css(this.$el, 'maxHeight')),
                        max: Math.max(150, height(this.container) - (offset(this.content).height - height(this.$el)))
                    };
                },

                write: function(ref) {
                    var current = ref.current;
                    var max = ref.max;

                    css(this.$el, 'maxHeight', max);
                    if (Math.round(current) !== Math.round(max)) {
                        trigger(this.$el, 'resize');
                    }
                },

                events: ['resize']

            }

        };

        var Responsive = {

            props: ['width', 'height'],

            connected: function() {
                addClass(this.$el, 'uk-responsive-width');
            },

            update: {

                read: function() {
                    return isVisible(this.$el) && this.width && this.height
                        ? {width: width(this.$el.parentNode), height: this.height}
                        : false;
                },

                write: function(dim) {
                    height(this.$el, Dimensions.contain({
                        height: this.height,
                        width: this.width
                    }, dim).height);
                },

                events: ['resize']

            }

        };

        var Scroll = {

            props: {
                duration: Number,
                offset: Number
            },

            data: {
                duration: 1000,
                offset: 0
            },

            methods: {

                scrollTo: function(el) {
                    var this$1 = this;


                    el = el && $(el) || document.body;

                    var docHeight = height(document);
                    var winHeight = height(window);

                    var target = offset(el).top - this.offset;
                    if (target + winHeight > docHeight) {
                        target = docHeight - winHeight;
                    }

                    if (!trigger(this.$el, 'beforescroll', [this, el])) {
                        return;
                    }

                    var start = Date.now();
                    var startY = window.pageYOffset;
                    var step = function () {

                        var currentY = startY + (target - startY) * ease(clamp((Date.now() - start) / this$1.duration));

                        scrollTop(window, currentY);

                        // scroll more if we have not reached our destination
                        if (currentY !== target) {
                            requestAnimationFrame(step);
                        } else {
                            trigger(this$1.$el, 'scrolled', [this$1, el]);
                        }

                    };

                    step();

                }

            },

            events: {

                click: function(e) {

                    if (e.defaultPrevented) {
                        return;
                    }

                    e.preventDefault();
                    this.scrollTo(escape(decodeURIComponent(this.$el.hash)).substr(1));
                }

            }

        };

        function ease(k) {
            return 0.5 * (1 - Math.cos(Math.PI * k));
        }

        var Scrollspy = {

            args: 'cls',

            props: {
                cls: String,
                target: String,
                hidden: Boolean,
                offsetTop: Number,
                offsetLeft: Number,
                repeat: Boolean,
                delay: Number
            },

            data: function () { return ({
                cls: false,
                target: false,
                hidden: true,
                offsetTop: 0,
                offsetLeft: 0,
                repeat: false,
                delay: 0,
                inViewClass: 'uk-scrollspy-inview'
            }); },

            computed: {

                elements: function(ref, $el) {
                    var target = ref.target;

                    return target ? $$(target, $el) : [$el];
                }

            },

            update: [

                {

                    write: function() {
                        if (this.hidden) {
                            css(filter(this.elements, (":not(." + (this.inViewClass) + ")")), 'visibility', 'hidden');
                        }
                    }

                },

                {

                    read: function(ref) {
                        var this$1 = this;
                        var update = ref.update;


                        if (!update) {
                            return;
                        }

                        this.elements.forEach(function (el) {

                            var state = el._ukScrollspyState;

                            if (!state) {
                                state = {cls: data(el, 'uk-scrollspy-class') || this$1.cls};
                            }

                            state.show = isInView(el, this$1.offsetTop, this$1.offsetLeft);
                            el._ukScrollspyState = state;

                        });

                    },

                    write: function(data) {
                        var this$1 = this;


                        // Let child components be applied at least once first
                        if (!data.update) {
                            this.$emit();
                            return data.update = true;
                        }

                        this.elements.forEach(function (el) {

                            var state = el._ukScrollspyState;
                            var cls = state.cls;

                            if (state.show && !state.inview && !state.queued) {

                                var show = function () {

                                    css(el, 'visibility', '');
                                    addClass(el, this$1.inViewClass);
                                    toggleClass(el, cls);

                                    trigger(el, 'inview');

                                    this$1.$update(el);

                                    state.inview = true;
                                    state.abort && state.abort();
                                };

                                if (this$1.delay) {

                                    state.queued = true;
                                    data.promise = (data.promise || Promise.resolve()).then(function () {
                                        return !state.inview && new Promise(function (resolve) {

                                            var timer = setTimeout(function () {

                                                show();
                                                resolve();

                                            }, data.promise || this$1.elements.length === 1 ? this$1.delay : 0);

                                            state.abort = function () {
                                                clearTimeout(timer);
                                                resolve();
                                                state.queued = false;
                                            };

                                        });

                                    });

                                } else {
                                    show();
                                }

                            } else if (!state.show && (state.inview || state.queued) && this$1.repeat) {

                                state.abort && state.abort();

                                if (!state.inview) {
                                    return;
                                }

                                css(el, 'visibility', this$1.hidden ? 'hidden' : '');
                                removeClass(el, this$1.inViewClass);
                                toggleClass(el, cls);

                                trigger(el, 'outview');

                                this$1.$update(el);

                                state.inview = false;

                            }


                        });

                    },

                    events: ['scroll', 'resize']

                }

            ]

        };

        var ScrollspyNav = {

            props: {
                cls: String,
                closest: String,
                scroll: Boolean,
                overflow: Boolean,
                offset: Number
            },

            data: {
                cls: 'uk-active',
                closest: false,
                scroll: false,
                overflow: true,
                offset: 0
            },

            computed: {

                links: function(_, $el) {
                    return $$('a[href^="#"]', $el).filter(function (el) { return el.hash; });
                },

                elements: function(ref) {
                    var selector = ref.closest;

                    return closest(this.links, selector || '*');
                },

                targets: function() {
                    return $$(this.links.map(function (el) { return escape(el.hash).substr(1); }).join(','));
                }

            },

            update: [

                {

                    read: function() {
                        if (this.scroll) {
                            this.$create('scroll', this.links, {offset: this.offset || 0});
                        }
                    }

                },

                {

                    read: function(data) {
                        var this$1 = this;


                        var scroll = window.pageYOffset + this.offset + 1;
                        var max = height(document) - height(window) + this.offset;

                        data.active = false;

                        this.targets.every(function (el, i) {

                            var ref = offset(el);
                            var top = ref.top;
                            var last = i + 1 === this$1.targets.length;

                            if (!this$1.overflow && (i === 0 && top > scroll || last && top + el.offsetTop < scroll)) {
                                return false;
                            }

                            if (!last && offset(this$1.targets[i + 1]).top <= scroll) {
                                return true;
                            }

                            if (scroll >= max) {
                                for (var j = this$1.targets.length - 1; j > i; j--) {
                                    if (isInView(this$1.targets[j])) {
                                        el = this$1.targets[j];
                                        break;
                                    }
                                }
                            }

                            return !(data.active = $(filter(this$1.links, ("[href=\"#" + (el.id) + "\"]"))));

                        });

                    },

                    write: function(ref) {
                        var active = ref.active;


                        this.links.forEach(function (el) { return el.blur(); });
                        removeClass(this.elements, this.cls);

                        if (active) {
                            trigger(this.$el, 'active', [active, addClass(this.closest ? closest(active, this.closest) : active, this.cls)]);
                        }

                    },

                    events: ['scroll', 'resize']

                }

            ]

        };

        var Sticky = {

            mixins: [Class, Media],

            props: {
                top: null,
                bottom: Boolean,
                offset: Number,
                animation: String,
                clsActive: String,
                clsInactive: String,
                clsFixed: String,
                clsBelow: String,
                selTarget: String,
                widthElement: Boolean,
                showOnUp: Boolean,
                targetOffset: Number
            },

            data: {
                top: 0,
                bottom: false,
                offset: 0,
                animation: '',
                clsActive: 'uk-active',
                clsInactive: '',
                clsFixed: 'uk-sticky-fixed',
                clsBelow: 'uk-sticky-below',
                selTarget: '',
                widthElement: false,
                showOnUp: false,
                targetOffset: false
            },

            computed: {

                selTarget: function(ref, $el) {
                    var selTarget = ref.selTarget;

                    return selTarget && $(selTarget, $el) || $el;
                },

                widthElement: function(ref, $el) {
                    var widthElement = ref.widthElement;

                    return query(widthElement, $el) || this.placeholder;
                },

                isActive: {

                    get: function() {
                        return hasClass(this.selTarget, this.clsActive);
                    },

                    set: function(value) {
                        if (value && !this.isActive) {
                            replaceClass(this.selTarget, this.clsInactive, this.clsActive);
                            trigger(this.$el, 'active');
                        } else if (!value && !hasClass(this.selTarget, this.clsInactive)) {
                            replaceClass(this.selTarget, this.clsActive, this.clsInactive);
                            trigger(this.$el, 'inactive');
                        }
                    }

                }

            },

            connected: function() {
                this.placeholder = $('+ .uk-sticky-placeholder', this.$el) || $('<div class="uk-sticky-placeholder"></div>');
                this.isFixed = false;
                this.isActive = false;
            },

            disconnected: function() {

                if (this.isFixed) {
                    this.hide();
                    removeClass(this.selTarget, this.clsInactive);
                }

                remove(this.placeholder);
                this.placeholder = null;
                this.widthElement = null;
            },

            events: [

                {

                    name: 'load hashchange popstate',

                    el: window,

                    handler: function() {
                        var this$1 = this;


                        if (!(this.targetOffset !== false && location.hash && window.pageYOffset > 0)) {
                            return;
                        }

                        var target = $(location.hash);

                        if (target) {
                            fastdom.read(function () {

                                var ref = offset(target);
                                var top = ref.top;
                                var elTop = offset(this$1.$el).top;
                                var elHeight = this$1.$el.offsetHeight;

                                if (this$1.isFixed && elTop + elHeight >= top && elTop <= top + target.offsetHeight) {
                                    scrollTop(window, top - elHeight - (isNumeric(this$1.targetOffset) ? this$1.targetOffset : 0) - this$1.offset);
                                }

                            });
                        }

                    }

                }

            ],

            update: [

                {

                    read: function(ref, type) {
                        var height = ref.height;


                        if (this.isActive && type !== 'update') {

                            this.hide();
                            height = this.$el.offsetHeight;
                            this.show();

                        }

                        height = !this.isActive ? this.$el.offsetHeight : height;

                        this.topOffset = offset(this.isFixed ? this.placeholder : this.$el).top;
                        this.bottomOffset = this.topOffset + height;

                        var bottom = parseProp('bottom', this);

                        this.top = Math.max(toFloat(parseProp('top', this)), this.topOffset) - this.offset;
                        this.bottom = bottom && bottom - height;
                        this.inactive = !this.matchMedia;

                        return {
                            lastScroll: false,
                            height: height,
                            margins: css(this.$el, ['marginTop', 'marginBottom', 'marginLeft', 'marginRight'])
                        };
                    },

                    write: function(ref) {
                        var height = ref.height;
                        var margins = ref.margins;


                        var ref$1 = this;
                        var placeholder = ref$1.placeholder;

                        css(placeholder, assign({height: height}, margins));

                        if (!within(placeholder, document)) {
                            after(this.$el, placeholder);
                            attr(placeholder, 'hidden', '');
                        }

                        // ensure active/inactive classes are applied
                        this.isActive = this.isActive;

                    },

                    events: ['resize']

                },

                {

                    read: function(ref) {
                        var scroll = ref.scroll; if ( scroll === void 0 ) scroll = 0;


                        this.width = (isVisible(this.widthElement) ? this.widthElement : this.$el).offsetWidth;

                        this.scroll = window.pageYOffset;

                        return {
                            dir: scroll <= this.scroll ? 'down' : 'up',
                            scroll: this.scroll,
                            visible: isVisible(this.$el),
                            top: offsetPosition(this.placeholder)[0]
                        };
                    },

                    write: function(data, type) {
                        var this$1 = this;


                        var initTimestamp = data.initTimestamp; if ( initTimestamp === void 0 ) initTimestamp = 0;
                        var dir = data.dir;
                        var lastDir = data.lastDir;
                        var lastScroll = data.lastScroll;
                        var scroll = data.scroll;
                        var top = data.top;
                        var visible = data.visible;
                        var now = performance.now();

                        data.lastScroll = scroll;

                        if (scroll < 0 || scroll === lastScroll || !visible || this.disabled || this.showOnUp && type !== 'scroll') {
                            return;
                        }

                        if (now - initTimestamp > 300 || dir !== lastDir) {
                            data.initScroll = scroll;
                            data.initTimestamp = now;
                        }

                        data.lastDir = dir;

                        if (this.showOnUp && Math.abs(data.initScroll - scroll) <= 30 && Math.abs(lastScroll - scroll) <= 10) {
                            return;
                        }

                        if (this.inactive
                            || scroll < this.top
                            || this.showOnUp && (scroll <= this.top || dir === 'down' || dir === 'up' && !this.isFixed && scroll <= this.bottomOffset)
                        ) {

                            if (!this.isFixed) {

                                if (Animation.inProgress(this.$el) && top > scroll) {
                                    Animation.cancel(this.$el);
                                    this.hide();
                                }

                                return;
                            }

                            this.isFixed = false;

                            if (this.animation && scroll > this.topOffset) {
                                Animation.cancel(this.$el);
                                Animation.out(this.$el, this.animation).then(function () { return this$1.hide(); }, noop);
                            } else {
                                this.hide();
                            }

                        } else if (this.isFixed) {

                            this.update();

                        } else if (this.animation) {

                            Animation.cancel(this.$el);
                            this.show();
                            Animation.in(this.$el, this.animation).catch(noop);

                        } else {
                            this.show();
                        }

                    },

                    events: ['resize', 'scroll']

                }

            ],

            methods: {

                show: function() {

                    this.isFixed = true;
                    this.update();
                    attr(this.placeholder, 'hidden', null);

                },

                hide: function() {

                    this.isActive = false;
                    removeClass(this.$el, this.clsFixed, this.clsBelow);
                    css(this.$el, {position: '', top: '', width: ''});
                    attr(this.placeholder, 'hidden', '');

                },

                update: function() {

                    var active = this.top !== 0 || this.scroll > this.top;
                    var top = Math.max(0, this.offset);

                    if (this.bottom && this.scroll > this.bottom - this.offset) {
                        top = this.bottom - this.scroll;
                    }

                    css(this.$el, {
                        position: 'fixed',
                        top: (top + "px"),
                        width: this.width
                    });

                    this.isActive = active;
                    toggleClass(this.$el, this.clsBelow, this.scroll > this.bottomOffset);
                    addClass(this.$el, this.clsFixed);

                }

            }

        };

        function parseProp(prop, ref) {
            var $props = ref.$props;
            var $el = ref.$el;
            var propOffset = ref[(prop + "Offset")];


            var value = $props[prop];

            if (!value) {
                return;
            }

            if (isNumeric(value)) {

                return propOffset + toFloat(value);

            } else if (isString(value) && value.match(/^-?\d+vh$/)) {

                return height(window) * toFloat(value) / 100;

            } else {

                var el = value === true ? $el.parentNode : query(value, $el);

                if (el) {
                    return offset(el).top + el.offsetHeight;
                }

            }
        }

        var Switcher = {

            mixins: [Togglable],

            args: 'connect',

            props: {
                connect: String,
                toggle: String,
                active: Number,
                swiping: Boolean
            },

            data: {
                connect: '~.uk-switcher',
                toggle: '> * > :first-child',
                active: 0,
                swiping: true,
                cls: 'uk-active',
                clsContainer: 'uk-switcher',
                attrItem: 'uk-switcher-item',
                queued: true
            },

            computed: {

                connects: function(ref, $el) {
                    var connect = ref.connect;

                    return queryAll(connect, $el);
                },

                toggles: function(ref, $el) {
                    var toggle = ref.toggle;

                    return $$(toggle, $el);
                }

            },

            events: [

                {

                    name: 'click',

                    delegate: function() {
                        return ((this.toggle) + ":not(.uk-disabled)");
                    },

                    handler: function(e) {
                        e.preventDefault();
                        this.show(toNodes(this.$el.children).filter(function (el) { return within(e.current, el); })[0]);
                    }

                },

                {
                    name: 'click',

                    el: function() {
                        return this.connects;
                    },

                    delegate: function() {
                        return ("[" + (this.attrItem) + "],[data-" + (this.attrItem) + "]");
                    },

                    handler: function(e) {
                        e.preventDefault();
                        this.show(data(e.current, this.attrItem));
                    }
                },

                {
                    name: 'swipeRight swipeLeft',

                    filter: function() {
                        return this.swiping;
                    },

                    el: function() {
                        return this.connects;
                    },

                    handler: function(ref) {
                        var type = ref.type;

                        this.show(endsWith(type, 'Left') ? 'next' : 'previous');
                    }
                }

            ],

            update: function() {
                var this$1 = this;


                this.connects.forEach(function (list) { return this$1.updateAria(list.children); });
                var ref = this.$el;
                var children = ref.children;
                this.show(filter(children, ("." + (this.cls)))[0] || children[this.active] || children[0]);

            },

            methods: {

                index: function() {
                    return !isEmpty(this.connects) && index(filter(this.connects[0].children, ("." + (this.cls)))[0]);
                },

                show: function(item) {
                    var this$1 = this;


                    var ref = this.$el;
                    var children = ref.children;
                    var length = children.length;
                    var prev = this.index();
                    var hasPrev = prev >= 0;
                    var dir = item === 'previous' ? -1 : 1;

                    var toggle, active, next = getIndex(item, children, prev);

                    for (var i = 0; i < length; i++, next = (next + dir + length) % length) {
                        if (!matches(this.toggles[next], '.uk-disabled *, .uk-disabled, [disabled]')) {
                            toggle = this.toggles[next];
                            active = children[next];
                            break;
                        }
                    }

                    if (!active || prev >= 0 && hasClass(active, this.cls) || prev === next) {
                        return;
                    }

                    removeClass(children, this.cls);
                    addClass(active, this.cls);
                    attr(this.toggles, 'aria-expanded', false);
                    attr(toggle, 'aria-expanded', true);

                    this.connects.forEach(function (list) {
                        if (!hasPrev) {
                            this$1.toggleNow(list.children[next]);
                        } else {
                            this$1.toggleElement([list.children[prev], list.children[next]]);
                        }
                    });

                }

            }

        };

        var Tab = {

            mixins: [Class],

            extends: Switcher,

            props: {
                media: Boolean
            },

            data: {
                media: 960,
                attrItem: 'uk-tab-item'
            },

            connected: function() {

                var cls = hasClass(this.$el, 'uk-tab-left')
                    ? 'uk-tab-left'
                    : hasClass(this.$el, 'uk-tab-right')
                        ? 'uk-tab-right'
                        : false;

                if (cls) {
                    this.$create('toggle', this.$el, {cls: cls, mode: 'media', media: this.media});
                }
            }

        };

        var Toggle = {

            mixins: [Media, Togglable],

            args: 'target',

            props: {
                href: String,
                target: null,
                mode: 'list'
            },

            data: {
                href: false,
                target: false,
                mode: 'click',
                queued: true
            },

            computed: {

                target: function(ref, $el) {
                    var href = ref.href;
                    var target = ref.target;

                    target = queryAll(target || href, $el);
                    return target.length && target || [$el];
                }

            },

            connected: function() {
                trigger(this.target, 'updatearia', [this]);
            },

            events: [

                {

                    name: (pointerEnter + " " + pointerLeave),

                    filter: function() {
                        return includes(this.mode, 'hover');
                    },

                    handler: function(e) {
                        if (!isTouch(e)) {
                            this.toggle(("toggle" + (e.type === pointerEnter ? 'show' : 'hide')));
                        }
                    }

                },

                {

                    name: 'click',

                    filter: function() {
                        return includes(this.mode, 'click') || hasTouch && includes(this.mode, 'hover');
                    },

                    handler: function(e) {

                        // TODO better isToggled handling
                        var link;
                        if (closest(e.target, 'a[href="#"], a[href=""]')
                            || (link = closest(e.target, 'a[href]')) && (
                                this.cls
                                || !isVisible(this.target)
                                || link.hash && matches(this.target, link.hash)
                            )
                        ) {
                            e.preventDefault();
                        }

                        this.toggle();
                    }

                }

            ],

            update: {

                read: function() {
                    return includes(this.mode, 'media') && this.media
                        ? {match: this.matchMedia}
                        : false;
                },

                write: function(ref) {
                    var match = ref.match;


                    var toggled = this.isToggled(this.target);
                    if (match ? !toggled : toggled) {
                        this.toggle();
                    }

                },

                events: ['resize']

            },

            methods: {

                toggle: function(type) {
                    if (trigger(this.target, type || 'toggle', [this])) {
                        this.toggleElement(this.target);
                    }
                }

            }

        };

        function core (UIkit) {

            // core components
            UIkit.component('accordion', Accordion);
            UIkit.component('alert', Alert);
            UIkit.component('cover', Cover);
            UIkit.component('drop', Drop);
            UIkit.component('dropdown', Dropdown);
            UIkit.component('formCustom', FormCustom);
            UIkit.component('gif', Gif);
            UIkit.component('grid', Grid);
            UIkit.component('heightMatch', HeightMatch);
            UIkit.component('heightViewport', HeightViewport);
            UIkit.component('icon', Icon);
            UIkit.component('img', Img);
            UIkit.component('leader', Leader);
            UIkit.component('margin', Margin);
            UIkit.component('modal', Modal$1);
            UIkit.component('nav', Nav);
            UIkit.component('navbar', Navbar);
            UIkit.component('offcanvas', Offcanvas);
            UIkit.component('overflowAuto', OverflowAuto);
            UIkit.component('responsive', Responsive);
            UIkit.component('scroll', Scroll);
            UIkit.component('scrollspy', Scrollspy);
            UIkit.component('scrollspyNav', ScrollspyNav);
            UIkit.component('sticky', Sticky);
            UIkit.component('svg', Svg);
            UIkit.component('switcher', Switcher);
            UIkit.component('tab', Tab);
            UIkit.component('toggle', Toggle);
            UIkit.component('video', Video);

            // Icon components
            UIkit.component('close', Close);
            UIkit.component('marker', IconComponent);
            UIkit.component('navbarToggleIcon', IconComponent);
            UIkit.component('overlayIcon', IconComponent);
            UIkit.component('paginationNext', IconComponent);
            UIkit.component('paginationPrevious', IconComponent);
            UIkit.component('searchIcon', Search);
            UIkit.component('slidenavNext', Slidenav);
            UIkit.component('slidenavPrevious', Slidenav);
            UIkit.component('spinner', Spinner);
            UIkit.component('totop', IconComponent);

            // core functionality
            UIkit.use(Core);

        }

        UIkit.version = '3.1.6';

        core(UIkit);

        var Countdown = {

            mixins: [Class],

            props: {
                date: String,
                clsWrapper: String
            },

            data: {
                date: '',
                clsWrapper: '.uk-countdown-%unit%'
            },

            computed: {

                date: function(ref) {
                    var date = ref.date;

                    return Date.parse(date);
                },

                days: function(ref, $el) {
                    var clsWrapper = ref.clsWrapper;

                    return $(clsWrapper.replace('%unit%', 'days'), $el);
                },

                hours: function(ref, $el) {
                    var clsWrapper = ref.clsWrapper;

                    return $(clsWrapper.replace('%unit%', 'hours'), $el);
                },

                minutes: function(ref, $el) {
                    var clsWrapper = ref.clsWrapper;

                    return $(clsWrapper.replace('%unit%', 'minutes'), $el);
                },

                seconds: function(ref, $el) {
                    var clsWrapper = ref.clsWrapper;

                    return $(clsWrapper.replace('%unit%', 'seconds'), $el);
                },

                units: function() {
                    var this$1 = this;

                    return ['days', 'hours', 'minutes', 'seconds'].filter(function (unit) { return this$1[unit]; });
                }

            },

            connected: function() {
                this.start();
            },

            disconnected: function() {
                var this$1 = this;

                this.stop();
                this.units.forEach(function (unit) { return empty(this$1[unit]); });
            },

            events: [

                {

                    name: 'visibilitychange',

                    el: document,

                    handler: function() {
                        if (document.hidden) {
                            this.stop();
                        } else {
                            this.start();
                        }
                    }

                }

            ],

            update: {

                write: function() {
                    var this$1 = this;


                    var timespan = getTimeSpan(this.date);

                    if (timespan.total <= 0) {

                        this.stop();

                        timespan.days
                            = timespan.hours
                            = timespan.minutes
                            = timespan.seconds
                            = 0;
                    }

                    this.units.forEach(function (unit) {

                        var digits = String(Math.floor(timespan[unit]));

                        digits = digits.length < 2 ? ("0" + digits) : digits;

                        var el = this$1[unit];
                        if (el.textContent !== digits) {
                            digits = digits.split('');

                            if (digits.length !== el.children.length) {
                                html(el, digits.map(function () { return '<span></span>'; }).join(''));
                            }

                            digits.forEach(function (digit, i) { return el.children[i].textContent = digit; });
                        }

                    });

                }

            },

            methods: {

                start: function() {
                    var this$1 = this;


                    this.stop();

                    if (this.date && this.units.length) {
                        this.$emit();
                        this.timer = setInterval(function () { return this$1.$emit(); }, 1000);
                    }

                },

                stop: function() {

                    if (this.timer) {
                        clearInterval(this.timer);
                        this.timer = null;
                    }

                }

            }

        };

        function getTimeSpan(date) {

            var total = date - Date.now();

            return {
                total: total,
                seconds: total / 1000 % 60,
                minutes: total / 1000 / 60 % 60,
                hours: total / 1000 / 60 / 60 % 24,
                days: total / 1000 / 60 / 60 / 24
            };
        }

        var targetClass = 'uk-animation-target';

        var Animate = {

            props: {
                animation: Number
            },

            data: {
                animation: 150
            },

            computed: {

                target: function() {
                    return this.$el;
                }

            },

            methods: {

                animate: function(action) {
                    var this$1 = this;


                    addStyle();

                    var children = toNodes(this.target.children);
                    var propsFrom = children.map(function (el) { return getProps(el, true); });

                    var oldHeight = height(this.target);
                    var oldScrollY = window.pageYOffset;

                    action();

                    Transition.cancel(this.target);
                    children.forEach(Transition.cancel);

                    reset(this.target);
                    this.$update(this.target);
                    fastdom.flush();

                    var newHeight = height(this.target);

                    children = children.concat(toNodes(this.target.children).filter(function (el) { return !includes(children, el); }));

                    var propsTo = children.map(function (el, i) { return el.parentNode && i in propsFrom
                            ? propsFrom[i]
                            ? isVisible(el)
                                ? getPositionWithMargin(el)
                                : {opacity: 0}
                            : {opacity: isVisible(el) ? 1 : 0}
                            : false; }
                    );

                    propsFrom = propsTo.map(function (props, i) {
                        var from = children[i].parentNode === this$1.target
                            ? propsFrom[i] || getProps(children[i])
                            : false;

                        if (from) {
                            if (!props) {
                                delete from.opacity;
                            } else if (!('opacity' in props)) {
                                var opacity = from.opacity;

                                if (opacity % 1) {
                                    props.opacity = 1;
                                } else {
                                    delete from.opacity;
                                }
                            }
                        }

                        return from;
                    });

                    addClass(this.target, targetClass);
                    children.forEach(function (el, i) { return propsFrom[i] && css(el, propsFrom[i]); });
                    css(this.target, 'height', oldHeight);
                    scrollTop(window, oldScrollY);

                    return Promise.all(children.map(function (el, i) { return propsFrom[i] && propsTo[i]
                            ? Transition.start(el, propsTo[i], this$1.animation, 'ease')
                            : Promise.resolve(); }
                    ).concat(Transition.start(this.target, {height: newHeight}, this.animation, 'ease'))).then(function () {
                        children.forEach(function (el, i) { return css(el, {display: propsTo[i].opacity === 0 ? 'none' : '', zIndex: ''}); });
                        reset(this$1.target);
                        this$1.$update(this$1.target);
                        fastdom.flush(); // needed for IE11
                    }, noop);

                }
            }
        };

        function getProps(el, opacity) {

            var zIndex = css(el, 'zIndex');

            return isVisible(el)
                ? assign({
                    display: '',
                    opacity: opacity ? css(el, 'opacity') : '0',
                    pointerEvents: 'none',
                    position: 'absolute',
                    zIndex: zIndex === 'auto' ? index(el) : zIndex
                }, getPositionWithMargin(el))
                : false;
        }

        function reset(el) {
            css(el.children, {
                height: '',
                left: '',
                opacity: '',
                pointerEvents: '',
                position: '',
                top: '',
                width: ''
            });
            removeClass(el, targetClass);
            css(el, 'height', '');
        }

        function getPositionWithMargin(el) {
            var ref = el.getBoundingClientRect();
            var height = ref.height;
            var width = ref.width;
            var ref$1 = position(el);
            var top = ref$1.top;
            var left = ref$1.left;
            top += toFloat(css(el, 'marginTop'));

            return {top: top, left: left, height: height, width: width};
        }

        var style;

        function addStyle() {
            if (style) {
                return;
            }
            style = append(document.head, '<style>').sheet;
            style.insertRule(
                ("." + targetClass + " > * {\n            margin-top: 0 !important;\n            transform: none !important;\n        }"), 0
            );
        }

        var Filter = {

            mixins: [Animate],

            args: 'target',

            props: {
                target: Boolean,
                selActive: Boolean
            },

            data: {
                target: null,
                selActive: false,
                attrItem: 'uk-filter-control',
                cls: 'uk-active',
                animation: 250
            },

            computed: {

                toggles: {

                    get: function(ref, $el) {
                        var attrItem = ref.attrItem;

                        return $$(("[" + (this.attrItem) + "],[data-" + (this.attrItem) + "]"), $el);
                    },

                    watch: function() {
                        this.updateState();
                    }

                },

                target: function(ref, $el) {
                    var target = ref.target;

                    return $(target, $el);
                },

                children: {

                    get: function() {
                        return toNodes(this.target && this.target.children);
                    },

                    watch: function(list, old) {
                        if (!isEqualList(list, old)) {
                            this.updateState();
                        }
                    }
                }

            },

            events: [

                {

                    name: 'click',

                    delegate: function() {
                        return ("[" + (this.attrItem) + "],[data-" + (this.attrItem) + "]");
                    },

                    handler: function(e) {

                        e.preventDefault();
                        this.apply(e.current);

                    }

                }

            ],

            connected: function() {
                var this$1 = this;


                this.updateState();

                if (this.selActive !== false) {
                    var actives = $$(this.selActive, this.$el);
                    this.toggles.forEach(function (el) { return toggleClass(el, this$1.cls, includes(actives, el)); });
                }

            },

            methods: {

                apply: function(el) {
                    this.setState(mergeState(el, this.attrItem, this.getState()));
                },

                getState: function() {
                    var this$1 = this;

                    return this.toggles
                        .filter(function (item) { return hasClass(item, this$1.cls); })
                        .reduce(function (state, el) { return mergeState(el, this$1.attrItem, state); }, {filter: {'': ''}, sort: []});
                },

                setState: function(state, animate) {
                    var this$1 = this;
                    if ( animate === void 0 ) animate = true;


                    state = assign({filter: {'': ''}, sort: []}, state);

                    trigger(this.$el, 'beforeFilter', [this, state]);

                    var ref = this;
                    var children = ref.children;

                    this.toggles.forEach(function (el) { return toggleClass(el, this$1.cls, !!matchFilter(el, this$1.attrItem, state)); });

                    var apply = function () {

                        var selector = getSelector(state);

                        children.forEach(function (el) { return css(el, 'display', selector && !matches(el, selector) ? 'none' : ''); });

                        var ref = state.sort;
                        var sort = ref[0];
                        var order = ref[1];

                        if (sort) {
                            var sorted = sortItems(children, sort, order);
                            if (!isEqual(sorted, children)) {
                                sorted.forEach(function (el) { return append(this$1.target, el); });
                            }
                        }

                    };

                    if (animate) {
                        this.animate(apply).then(function () { return trigger(this$1.$el, 'afterFilter', [this$1]); });
                    } else {
                        apply();
                        trigger(this.$el, 'afterFilter', [this]);
                    }

                },

                updateState: function() {
                    var this$1 = this;

                    fastdom.write(function () { return this$1.setState(this$1.getState(), false); });
                }

            }

        };

        function getFilter(el, attr) {
            return parseOptions(data(el, attr), ['filter']);
        }

        function mergeState(el, attr, state) {

            var filterBy = getFilter(el, attr);
            var filter = filterBy.filter;
            var group = filterBy.group;
            var sort = filterBy.sort;
            var order = filterBy.order; if ( order === void 0 ) order = 'asc';

            if (filter || isUndefined(sort)) {

                if (group) {

                    if (filter) {
                        delete state.filter[''];
                        state.filter[group] = filter;
                    } else {
                        delete state.filter[group];

                        if (isEmpty(state.filter) || '' in state.filter) {
                            state.filter = {'': filter || ''};
                        }

                    }

                } else {
                    state.filter = {'': filter || ''};
                }

            }

            if (!isUndefined(sort)) {
                state.sort = [sort, order];
            }

            return state;
        }

        function matchFilter(el, attr, ref) {
            var stateFilter = ref.filter; if ( stateFilter === void 0 ) stateFilter = {'': ''};
            var ref_sort = ref.sort;
            var stateSort = ref_sort[0];
            var stateOrder = ref_sort[1];


            var ref$1 = getFilter(el, attr);
            var filter = ref$1.filter; if ( filter === void 0 ) filter = '';
            var group = ref$1.group; if ( group === void 0 ) group = '';
            var sort = ref$1.sort;
            var order = ref$1.order; if ( order === void 0 ) order = 'asc';

            return isUndefined(sort)
                ? group in stateFilter && filter === stateFilter[group]
                    || !filter && group && !(group in stateFilter) && !stateFilter['']
                : stateSort === sort && stateOrder === order;
        }

        function isEqualList(listA, listB) {
            return listA.length === listB.length
                && listA.every(function (el) { return ~listB.indexOf(el); });
        }

        function getSelector(ref) {
            var filter = ref.filter;

            var selector = '';
            each(filter, function (value) { return selector += value || ''; });
            return selector;
        }

        function sortItems(nodes, sort, order) {
            return assign([], nodes).sort(function (a, b) { return data(a, sort).localeCompare(data(b, sort), undefined, {numeric: true}) * (order === 'asc' || -1); });
        }

        var Animations = {

            slide: {

                show: function(dir) {
                    return [
                        {transform: translate(dir * -100)},
                        {transform: translate()}
                    ];
                },

                percent: function(current) {
                    return translated(current);
                },

                translate: function(percent, dir) {
                    return [
                        {transform: translate(dir * -100 * percent)},
                        {transform: translate(dir * 100 * (1 - percent))}
                    ];
                }

            }

        };

        function translated(el) {
            return Math.abs(css(el, 'transform').split(',')[4] / el.offsetWidth) || 0;
        }

        function translate(value, unit) {
            if ( value === void 0 ) value = 0;
            if ( unit === void 0 ) unit = '%';

            value += value ? unit : '';
            return isIE ? ("translateX(" + value + ")") : ("translate3d(" + value + ", 0, 0)"); // currently not translate3d in IE, translate3d within translate3d does not work while transitioning
        }

        function scale3d(value) {
            return ("scale3d(" + value + ", " + value + ", 1)");
        }

        var Animations$1 = assign({}, Animations, {

            fade: {

                show: function() {
                    return [
                        {opacity: 0},
                        {opacity: 1}
                    ];
                },

                percent: function(current) {
                    return 1 - css(current, 'opacity');
                },

                translate: function(percent) {
                    return [
                        {opacity: 1 - percent},
                        {opacity: percent}
                    ];
                }

            },

            scale: {

                show: function() {
                    return [
                        {opacity: 0, transform: scale3d(1 - .2)},
                        {opacity: 1, transform: scale3d(1)}
                    ];
                },

                percent: function(current) {
                    return 1 - css(current, 'opacity');
                },

                translate: function(percent) {
                    return [
                        {opacity: 1 - percent, transform: scale3d(1 - .2 * percent)},
                        {opacity: percent, transform: scale3d(1 - .2 + .2 * percent)}
                    ];
                }

            }

        });

        function Transitioner(prev, next, dir, ref) {
            var animation = ref.animation;
            var easing = ref.easing;


            var percent = animation.percent;
            var translate = animation.translate;
            var show = animation.show; if ( show === void 0 ) show = noop;
            var props = show(dir);
            var deferred = new Deferred();

            return {

                dir: dir,

                show: function(duration, percent, linear) {
                    var this$1 = this;
                    if ( percent === void 0 ) percent = 0;


                    var timing = linear ? 'linear' : easing;
                    duration -= Math.round(duration * clamp(percent, -1, 1));

                    this.translate(percent);

                    triggerUpdate(next, 'itemin', {percent: percent, duration: duration, timing: timing, dir: dir});
                    triggerUpdate(prev, 'itemout', {percent: 1 - percent, duration: duration, timing: timing, dir: dir});

                    Promise.all([
                        Transition.start(next, props[1], duration, timing),
                        Transition.start(prev, props[0], duration, timing)
                    ]).then(function () {
                        this$1.reset();
                        deferred.resolve();
                    }, noop);

                    return deferred.promise;
                },

                stop: function() {
                    return Transition.stop([next, prev]);
                },

                cancel: function() {
                    Transition.cancel([next, prev]);
                },

                reset: function() {
                    for (var prop in props[0]) {
                        css([next, prev], prop, '');
                    }
                },

                forward: function(duration, percent) {
                    if ( percent === void 0 ) percent = this.percent();

                    Transition.cancel([next, prev]);
                    return this.show(duration, percent, true);

                },

                translate: function(percent) {

                    this.reset();

                    var props = translate(percent, dir);
                    css(next, props[1]);
                    css(prev, props[0]);
                    triggerUpdate(next, 'itemtranslatein', {percent: percent, dir: dir});
                    triggerUpdate(prev, 'itemtranslateout', {percent: 1 - percent, dir: dir});

                },

                percent: function() {
                    return percent(prev || next, next, dir);
                },

                getDistance: function() {
                    return prev && prev.offsetWidth;
                }

            };

        }

        function triggerUpdate(el, type, data) {
            trigger(el, createEvent(type, false, false, data));
        }

        var SliderAutoplay = {

            props: {
                autoplay: Boolean,
                autoplayInterval: Number,
                pauseOnHover: Boolean
            },

            data: {
                autoplay: false,
                autoplayInterval: 7000,
                pauseOnHover: true
            },

            connected: function() {
                this.autoplay && this.startAutoplay();
            },

            disconnected: function() {
                this.stopAutoplay();
            },

            update: function() {
                attr(this.slides, 'tabindex', '-1');
            },

            events: [

                {

                    name: 'visibilitychange',

                    el: document,

                    filter: function() {
                        return this.autoplay;
                    },

                    handler: function() {
                        if (document.hidden) {
                            this.stopAutoplay();
                        } else {
                            this.startAutoplay();
                        }
                    }

                },

                {

                    name: 'mouseenter',

                    filter: function() {
                        return this.autoplay && this.pauseOnHover;
                    },

                    handler: function() {
                        this.isHovering = true;
                    }

                },

                {

                    name: 'mouseleave',

                    filter: function() {
                        return this.autoplay && this.pauseOnHover;
                    },

                    handler: function() {
                        this.isHovering = false;
                    }

                }

            ],

            methods: {

                startAutoplay: function() {
                    var this$1 = this;


                    this.stopAutoplay();

                    this.interval = setInterval(
                        function () { return !within(document.activeElement, this$1.$el)
                            && !this$1.isHovering
                            && !this$1.stack.length
                            && this$1.show('next'); },
                        this.autoplayInterval
                    );

                },

                stopAutoplay: function() {
                    this.interval && clearInterval(this.interval);
                }

            }

        };

        var SliderDrag = {

            props: {
                draggable: Boolean
            },

            data: {
                draggable: true,
                threshold: 10
            },

            created: function() {
                var this$1 = this;


                ['start', 'move', 'end'].forEach(function (key) {

                    var fn = this$1[key];
                    this$1[key] = function (e) {

                        var pos = getEventPos(e).x * (isRtl ? -1 : 1);

                        this$1.prevPos = pos !== this$1.pos ? this$1.pos : this$1.prevPos;
                        this$1.pos = pos;

                        fn(e);
                    };

                });

            },

            events: [

                {

                    name: pointerDown,

                    delegate: function() {
                        return this.selSlides;
                    },

                    handler: function(e) {

                        if (!this.draggable
                            || !isTouch(e) && hasTextNodesOnly(e.target)
                            || e.button > 0
                            || this.length < 2
                        ) {
                            return;
                        }

                        this.start(e);
                    }

                },

                {

                    // Workaround for iOS 11 bug: https://bugs.webkit.org/show_bug.cgi?id=184250

                    name: 'touchmove',
                    passive: false,
                    handler: 'move',
                    delegate: function() {
                        return this.selSlides;
                    }

                },

                {
                    name: 'dragstart',

                    handler: function(e) {
                        e.preventDefault();
                    }
                }

            ],

            methods: {

                start: function() {
                    var this$1 = this;


                    this.drag = this.pos;

                    if (this._transitioner) {

                        this.percent = this._transitioner.percent();
                        this.drag += this._transitioner.getDistance() * this.percent * this.dir;

                        this._transitioner.cancel();
                        this._transitioner.translate(this.percent);

                        this.dragging = true;

                        this.stack = [];

                    } else {
                        this.prevIndex = this.index;
                    }

                    // See above workaround notice
                    var off = pointerMove !== 'touchmove'
                        ? on(document, pointerMove, this.move, {passive: false})
                        : noop;
                    this.unbindMove = function () {
                        off();
                        this$1.unbindMove = null;
                    };
                    on(window, 'scroll', this.unbindMove);
                    on(document, pointerUp, this.end, true);

                    css(this.list, 'userSelect', 'none');

                },

                move: function(e) {
                    var this$1 = this;


                    // See above workaround notice
                    if (!this.unbindMove) {
                        return;
                    }

                    var distance = this.pos - this.drag;

                    if (distance === 0 || this.prevPos === this.pos || !this.dragging && Math.abs(distance) < this.threshold) {
                        return;
                    }

                    css(this.list, 'pointerEvents', 'none');

                    e.cancelable && e.preventDefault();

                    this.dragging = true;
                    this.dir = (distance < 0 ? 1 : -1);

                    var ref = this;
                    var slides = ref.slides;
                    var ref$1 = this;
                    var prevIndex = ref$1.prevIndex;
                    var dis = Math.abs(distance);
                    var nextIndex = this.getIndex(prevIndex + this.dir, prevIndex);
                    var width = this._getDistance(prevIndex, nextIndex) || slides[prevIndex].offsetWidth;

                    while (nextIndex !== prevIndex && dis > width) {

                        this.drag -= width * this.dir;

                        prevIndex = nextIndex;
                        dis -= width;
                        nextIndex = this.getIndex(prevIndex + this.dir, prevIndex);
                        width = this._getDistance(prevIndex, nextIndex) || slides[prevIndex].offsetWidth;

                    }

                    this.percent = dis / width;

                    var prev = slides[prevIndex];
                    var next = slides[nextIndex];
                    var changed = this.index !== nextIndex;
                    var edge = prevIndex === nextIndex;

                    var itemShown;

                    [this.index, this.prevIndex].filter(function (i) { return !includes([nextIndex, prevIndex], i); }).forEach(function (i) {
                        trigger(slides[i], 'itemhidden', [this$1]);

                        if (edge) {
                            itemShown = true;
                            this$1.prevIndex = prevIndex;
                        }

                    });

                    if (this.index === prevIndex && this.prevIndex !== prevIndex || itemShown) {
                        trigger(slides[this.index], 'itemshown', [this]);
                    }

                    if (changed) {
                        this.prevIndex = prevIndex;
                        this.index = nextIndex;

                        !edge && trigger(prev, 'beforeitemhide', [this]);
                        trigger(next, 'beforeitemshow', [this]);
                    }

                    this._transitioner = this._translate(Math.abs(this.percent), prev, !edge && next);

                    if (changed) {
                        !edge && trigger(prev, 'itemhide', [this]);
                        trigger(next, 'itemshow', [this]);
                    }

                },

                end: function() {

                    off(window, 'scroll', this.unbindMove);
                    this.unbindMove && this.unbindMove();
                    off(document, pointerUp, this.end, true);

                    if (this.dragging) {

                        this.dragging = null;

                        if (this.index === this.prevIndex) {
                            this.percent = 1 - this.percent;
                            this.dir *= -1;
                            this._show(false, this.index, true);
                            this._transitioner = null;
                        } else {

                            var dirChange = (isRtl ? this.dir * (isRtl ? 1 : -1) : this.dir) < 0 === this.prevPos > this.pos;
                            this.index = dirChange ? this.index : this.prevIndex;

                            if (dirChange) {
                                this.percent = 1 - this.percent;
                            }

                            this.show(this.dir > 0 && !dirChange || this.dir < 0 && dirChange ? 'next' : 'previous', true);
                        }

                    }

                    css(this.list, {userSelect: '', pointerEvents: ''});

                    this.drag
                        = this.percent
                        = null;

                }

            }

        };

        function hasTextNodesOnly(el) {
            return !el.children.length && el.childNodes.length;
        }

        var SliderNav = {

            data: {
                selNav: false
            },

            computed: {

                nav: function(ref, $el) {
                    var selNav = ref.selNav;

                    return $(selNav, $el);
                },

                selNavItem: function(ref) {
                    var attrItem = ref.attrItem;

                    return ("[" + attrItem + "],[data-" + attrItem + "]");
                },

                navItems: function(_, $el) {
                    return $$(this.selNavItem, $el);
                }

            },

            update: {

                write: function() {
                    var this$1 = this;


                    if (this.nav && this.length !== this.nav.children.length) {
                        html(this.nav, this.slides.map(function (_, i) { return ("<li " + (this$1.attrItem) + "=\"" + i + "\"><a href=\"#\"></a></li>"); }).join(''));
                    }

                    toggleClass($$(this.selNavItem, this.$el).concat(this.nav), 'uk-hidden', !this.maxIndex);

                    this.updateNav();

                },

                events: ['resize']

            },

            events: [

                {

                    name: 'click',

                    delegate: function() {
                        return this.selNavItem;
                    },

                    handler: function(e) {
                        e.preventDefault();
                        this.show(data(e.current, this.attrItem));
                    }

                },

                {

                    name: 'itemshow',
                    handler: 'updateNav'

                }

            ],

            methods: {

                updateNav: function() {
                    var this$1 = this;


                    var i = this.getValidIndex();
                    this.navItems.forEach(function (el) {

                        var cmd = data(el, this$1.attrItem);

                        toggleClass(el, this$1.clsActive, toNumber(cmd) === i);
                        toggleClass(el, 'uk-invisible', this$1.finite && (cmd === 'previous' && i === 0 || cmd === 'next' && i >= this$1.maxIndex));
                    });

                }

            }

        };

        var Slider = {

            mixins: [SliderAutoplay, SliderDrag, SliderNav],

            props: {
                clsActivated: Boolean,
                easing: String,
                index: Number,
                finite: Boolean,
                velocity: Number
            },

            data: function () { return ({
                easing: 'ease',
                finite: false,
                velocity: 1,
                index: 0,
                stack: [],
                percent: 0,
                clsActive: 'uk-active',
                clsActivated: false,
                Transitioner: false,
                transitionOptions: {}
            }); },

            computed: {

                duration: function(ref, $el) {
                    var velocity = ref.velocity;

                    return speedUp($el.offsetWidth / velocity);
                },

                length: function() {
                    return this.slides.length;
                },

                list: function(ref, $el) {
                    var selList = ref.selList;

                    return $(selList, $el);
                },

                maxIndex: function() {
                    return this.length - 1;
                },

                selSlides: function(ref) {
                    var selList = ref.selList;

                    return (selList + " > *");
                },

                slides: function() {
                    return toNodes(this.list.children);
                }

            },

            events: {

                itemshown: function() {
                    this.$update(this.list);
                }

            },

            methods: {

                show: function(index, force) {
                    var this$1 = this;
                    if ( force === void 0 ) force = false;


                    if (this.dragging || !this.length) {
                        return;
                    }

                    var ref = this;
                    var stack = ref.stack;
                    var queueIndex = force ? 0 : stack.length;
                    var reset = function () {
                        stack.splice(queueIndex, 1);

                        if (stack.length) {
                            this$1.show(stack.shift(), true);
                        }
                    };

                    stack[force ? 'unshift' : 'push'](index);

                    if (!force && stack.length > 1) {

                        if (stack.length === 2) {
                            this._transitioner.forward(Math.min(this.duration, 200));
                        }

                        return;
                    }

                    var prevIndex = this.index;
                    var prev = hasClass(this.slides, this.clsActive) && this.slides[prevIndex];
                    var nextIndex = this.getIndex(index, this.index);
                    var next = this.slides[nextIndex];

                    if (prev === next) {
                        reset();
                        return;
                    }

                    this.dir = getDirection(index, prevIndex);
                    this.prevIndex = prevIndex;
                    this.index = nextIndex;

                    prev && trigger(prev, 'beforeitemhide', [this]);
                    if (!trigger(next, 'beforeitemshow', [this, prev])) {
                        this.index = this.prevIndex;
                        reset();
                        return;
                    }

                    var promise = this._show(prev, next, force).then(function () {

                        prev && trigger(prev, 'itemhidden', [this$1]);
                        trigger(next, 'itemshown', [this$1]);

                        return new Promise(function (resolve) {
                            fastdom.write(function () {
                                stack.shift();
                                if (stack.length) {
                                    this$1.show(stack.shift(), true);
                                } else {
                                    this$1._transitioner = null;
                                }
                                resolve();
                            });
                        });

                    });

                    prev && trigger(prev, 'itemhide', [this]);
                    trigger(next, 'itemshow', [this]);

                    return promise;

                },

                getIndex: function(index, prev) {
                    if ( index === void 0 ) index = this.index;
                    if ( prev === void 0 ) prev = this.index;

                    return clamp(getIndex(index, this.slides, prev, this.finite), 0, this.maxIndex);
                },

                getValidIndex: function(index, prevIndex) {
                    if ( index === void 0 ) index = this.index;
                    if ( prevIndex === void 0 ) prevIndex = this.prevIndex;

                    return this.getIndex(index, prevIndex);
                },

                _show: function(prev, next, force) {

                    this._transitioner = this._getTransitioner(
                        prev,
                        next,
                        this.dir,
                        assign({
                            easing: force
                                ? next.offsetWidth < 600
                                    ? 'cubic-bezier(0.25, 0.46, 0.45, 0.94)' /* easeOutQuad */
                                    : 'cubic-bezier(0.165, 0.84, 0.44, 1)' /* easeOutQuart */
                                : this.easing
                        }, this.transitionOptions)
                    );

                    if (!force && !prev) {
                        this._transitioner.translate(1);
                        return Promise.resolve();
                    }

                    var ref = this.stack;
                    var length = ref.length;
                    return this._transitioner[length > 1 ? 'forward' : 'show'](length > 1 ? Math.min(this.duration, 75 + 75 / (length - 1)) : this.duration, this.percent);

                },

                _getDistance: function(prev, next) {
                    return new this._getTransitioner(prev, prev !== next && next).getDistance();
                },

                _translate: function(percent, prev, next) {
                    if ( prev === void 0 ) prev = this.prevIndex;
                    if ( next === void 0 ) next = this.index;

                    var transitioner = this._getTransitioner(prev !== next ? prev : false, next);
                    transitioner.translate(percent);
                    return transitioner;
                },

                _getTransitioner: function(prev, next, dir, options) {
                    if ( prev === void 0 ) prev = this.prevIndex;
                    if ( next === void 0 ) next = this.index;
                    if ( dir === void 0 ) dir = this.dir || 1;
                    if ( options === void 0 ) options = this.transitionOptions;

                    return new this.Transitioner(
                        isNumber(prev) ? this.slides[prev] : prev,
                        isNumber(next) ? this.slides[next] : next,
                        dir * (isRtl ? -1 : 1),
                        options
                    );
                }

            }

        };

        function getDirection(index, prevIndex) {
            return index === 'next'
                ? 1
                : index === 'previous'
                    ? -1
                    : index < prevIndex
                        ? -1
                        : 1;
        }

        function speedUp(x) {
            return .5 * x + 300; // parabola through (400,500; 600,600; 1800,1200)
        }

        var Slideshow = {

            mixins: [Slider],

            props: {
                animation: String
            },

            data: {
                animation: 'slide',
                clsActivated: 'uk-transition-active',
                Animations: Animations,
                Transitioner: Transitioner
            },

            computed: {

                animation: function(ref) {
                    var animation = ref.animation;
                    var Animations = ref.Animations;

                    return assign(animation in Animations ? Animations[animation] : Animations.slide, {name: animation});
                },

                transitionOptions: function() {
                    return {animation: this.animation};
                }

            },

            events: {

                'itemshow itemhide itemshown itemhidden': function(ref) {
                    var target = ref.target;

                    this.$update(target);
                },

                beforeitemshow: function(ref) {
                    var target = ref.target;

                    addClass(target, this.clsActive);
                },

                itemshown: function(ref) {
                    var target = ref.target;

                    addClass(target, this.clsActivated);
                },

                itemhidden: function(ref) {
                    var target = ref.target;

                    removeClass(target, this.clsActive, this.clsActivated);
                }

            }

        };

        var lightboxPanel = {

            mixins: [Container, Modal, Togglable, Slideshow],

            functional: true,

            props: {
                delayControls: Number,
                preload: Number,
                videoAutoplay: Boolean,
                template: String
            },

            data: function () { return ({
                preload: 1,
                videoAutoplay: false,
                delayControls: 3000,
                items: [],
                cls: 'uk-open',
                clsPage: 'uk-lightbox-page',
                selList: '.uk-lightbox-items',
                attrItem: 'uk-lightbox-item',
                selClose: '.uk-close-large',
                pauseOnHover: false,
                velocity: 2,
                Animations: Animations$1,
                template: "<div class=\"uk-lightbox uk-overflow-hidden\"> <ul class=\"uk-lightbox-items\"></ul> <div class=\"uk-lightbox-toolbar uk-position-top uk-text-right uk-transition-slide-top uk-transition-opaque\"> <button class=\"uk-lightbox-toolbar-icon uk-close-large\" type=\"button\" uk-close></button> </div> <a class=\"uk-lightbox-button uk-position-center-left uk-position-medium uk-transition-fade\" href=\"#\" uk-slidenav-previous uk-lightbox-item=\"previous\"></a> <a class=\"uk-lightbox-button uk-position-center-right uk-position-medium uk-transition-fade\" href=\"#\" uk-slidenav-next uk-lightbox-item=\"next\"></a> <div class=\"uk-lightbox-toolbar uk-lightbox-caption uk-position-bottom uk-text-center uk-transition-slide-bottom uk-transition-opaque\"></div> </div>"
            }); },

            created: function() {
                var this$1 = this;


                this.$mount(append(this.container, this.template));

                this.caption = $('.uk-lightbox-caption', this.$el);

                this.items.forEach(function () { return append(this$1.list, '<li></li>'); });

            },

            events: [

                {

                    name: (pointerMove + " " + pointerDown + " keydown"),

                    handler: 'showControls'

                },

                {

                    name: 'click',

                    self: true,

                    delegate: function() {
                        return this.selSlides;
                    },

                    handler: function(e) {

                        if (e.defaultPrevented) {
                            return;
                        }

                        this.hide();
                    }

                },

                {

                    name: 'shown',

                    self: true,

                    handler: function() {
                        this.showControls();
                    }

                },

                {

                    name: 'hide',

                    self: true,

                    handler: function() {

                        this.hideControls();

                        removeClass(this.slides, this.clsActive);
                        Transition.stop(this.slides);

                    }
                },

                {

                    name: 'hidden',

                    self: true,

                    handler: function() {
                        this.$destroy(true);
                    }

                },

                {

                    name: 'keyup',

                    el: document,

                    handler: function(e) {

                        if (!this.isToggled(this.$el)) {
                            return;
                        }

                        switch (e.keyCode) {
                            case 37:
                                this.show('previous');
                                break;
                            case 39:
                                this.show('next');
                                break;
                        }
                    }
                },

                {

                    name: 'beforeitemshow',

                    handler: function(e) {

                        if (this.isToggled()) {
                            return;
                        }

                        this.draggable = false;

                        e.preventDefault();

                        this.toggleNow(this.$el, true);

                        this.animation = Animations$1['scale'];
                        removeClass(e.target, this.clsActive);
                        this.stack.splice(1, 0, this.index);

                    }

                },

                {

                    name: 'itemshow',

                    handler: function(ref) {
                        var target = ref.target;


                        var i = index(target);
                        var ref$1 = this.getItem(i);
                        var caption = ref$1.caption;

                        css(this.caption, 'display', caption ? '' : 'none');
                        html(this.caption, caption);

                        for (var j = 0; j <= this.preload; j++) {
                            this.loadItem(this.getIndex(i + j));
                            this.loadItem(this.getIndex(i - j));
                        }

                    }

                },

                {

                    name: 'itemshown',

                    handler: function() {
                        this.draggable = this.$props.draggable;
                    }

                },

                {

                    name: 'itemload',

                    handler: function(_, item) {
                        var this$1 = this;


                        var source = item.source;
                        var type = item.type;
                        var alt = item.alt;

                        this.setItem(item, '<span uk-spinner></span>');

                        if (!source) {
                            return;
                        }

                        var matches;

                        // Image
                        if (type === 'image' || source.match(/\.(jp(e)?g|png|gif|svg|webp)($|\?)/i)) {

                            getImage(source).then(
                                function (img) { return this$1.setItem(item, ("<img width=\"" + (img.width) + "\" height=\"" + (img.height) + "\" src=\"" + source + "\" alt=\"" + (alt ? alt : '') + "\">")); },
                                function () { return this$1.setError(item); }
                            );

                            // Video
                        } else if (type === 'video' || source.match(/\.(mp4|webm|ogv)($|\?)/i)) {

                            var video = $(("<video controls playsinline" + (item.poster ? (" poster=\"" + (item.poster) + "\"") : '') + " uk-video=\"" + (this.videoAutoplay) + "\"></video>"));
                            attr(video, 'src', source);

                            once(video, 'error loadedmetadata', function (type) {
                                if (type === 'error') {
                                    this$1.setError(item);
                                } else {
                                    attr(video, {width: video.videoWidth, height: video.videoHeight});
                                    this$1.setItem(item, video);
                                }
                            });

                            // Iframe
                        } else if (type === 'iframe' || source.match(/\.(html|php)($|\?)/i)) {

                            this.setItem(item, ("<iframe class=\"uk-lightbox-iframe\" src=\"" + source + "\" frameborder=\"0\" allowfullscreen></iframe>"));

                            // YouTube
                        } else if ((matches = source.match(/\/\/.*?youtube(-nocookie)?\.[a-z]+\/watch\?v=([^&\s]+)/) || source.match(/()youtu\.be\/(.*)/))) {

                            var id = matches[2];
                            var setIframe = function (width, height) {
                                if ( width === void 0 ) width = 640;
                                if ( height === void 0 ) height = 450;

                                return this$1.setItem(item, getIframe(("https://www.youtube" + (matches[1] || '') + ".com/embed/" + id), width, height, this$1.videoAutoplay));
                            };

                            getImage(("https://img.youtube.com/vi/" + id + "/maxresdefault.jpg")).then(
                                function (ref) {
                                    var width = ref.width;
                                    var height = ref.height;

                                    // YouTube default 404 thumb, fall back to low resolution
                                    if (width === 120 && height === 90) {
                                        getImage(("https://img.youtube.com/vi/" + id + "/0.jpg")).then(
                                            function (ref) {
                                                var width = ref.width;
                                                var height = ref.height;

                                                return setIframe(width, height);
                                        },
                                            setIframe
                                        );
                                    } else {
                                        setIframe(width, height);
                                    }
                                },
                                setIframe
                            );

                            // Vimeo
                        } else if ((matches = source.match(/(\/\/.*?)vimeo\.[a-z]+\/([0-9]+).*?/))) {

                            ajax(("https://vimeo.com/api/oembed.json?maxwidth=1920&url=" + (encodeURI(source))), {responseType: 'json', withCredentials: false})
                                .then(
                                    function (ref) {
                                        var ref_response = ref.response;
                                        var height = ref_response.height;
                                        var width = ref_response.width;

                                        return this$1.setItem(item, getIframe(("https://player.vimeo.com/video/" + (matches[2])), width, height, this$1.videoAutoplay));
                            },
                                    function () { return this$1.setError(item); }
                                );

                        }

                    }

                }

            ],

            methods: {

                loadItem: function(index) {
                    if ( index === void 0 ) index = this.index;


                    var item = this.getItem(index);

                    if (item.content) {
                        return;
                    }

                    trigger(this.$el, 'itemload', [item]);
                },

                getItem: function(index) {
                    if ( index === void 0 ) index = this.index;

                    return this.items[index] || {};
                },

                setItem: function(item, content) {
                    assign(item, {content: content});
                    var el = html(this.slides[this.items.indexOf(item)], content);
                    trigger(this.$el, 'itemloaded', [this, el]);
                    this.$update(el);
                },

                setError: function(item) {
                    this.setItem(item, '<span uk-icon="icon: bolt; ratio: 2"></span>');
                },

                showControls: function() {

                    clearTimeout(this.controlsTimer);
                    this.controlsTimer = setTimeout(this.hideControls, this.delayControls);

                    addClass(this.$el, 'uk-active', 'uk-transition-active');

                },

                hideControls: function() {
                    removeClass(this.$el, 'uk-active', 'uk-transition-active');
                }

            }

        };

        function getIframe(src, width, height, autoplay) {
            return ("<iframe src=\"" + src + "\" width=\"" + width + "\" height=\"" + height + "\" style=\"max-width: 100%; box-sizing: border-box;\" frameborder=\"0\" allowfullscreen uk-video=\"autoplay: " + autoplay + "\" uk-responsive></iframe>");
        }

        var Lightbox = {

            install: install$2,

            props: {toggle: String},

            data: {toggle: 'a'},

            computed: {

                toggles: {

                    get: function(ref, $el) {
                        var toggle = ref.toggle;

                        return $$(toggle, $el);
                    },

                    watch: function() {
                        this.hide();
                    }

                },

                items: function() {
                    return uniqueBy(this.toggles.map(toItem), 'source');
                }

            },

            disconnected: function() {
                this.hide();
            },

            events: [

                {

                    name: 'click',

                    delegate: function() {
                        return ((this.toggle) + ":not(.uk-disabled)");
                    },

                    handler: function(e) {
                        e.preventDefault();
                        var src = data(e.current, 'href');
                        this.show(findIndex(this.items, function (ref) {
                            var source = ref.source;

                            return source === src;
                        }));
                    }

                }

            ],

            methods: {

                show: function(index) {
                    var this$1 = this;


                    this.panel = this.panel || this.$create('lightboxPanel', assign({}, this.$props, {items: this.items}));

                    on(this.panel.$el, 'hidden', function () { return this$1.panel = false; });

                    return this.panel.show(index);

                },

                hide: function() {

                    return this.panel && this.panel.hide();

                }

            }

        };

        function install$2(UIkit, Lightbox) {

            if (!UIkit.lightboxPanel) {
                UIkit.component('lightboxPanel', lightboxPanel);
            }

            assign(
                Lightbox.props,
                UIkit.component('lightboxPanel').options.props
            );

        }

        function toItem(el) {
            return ['href', 'caption', 'type', 'poster', 'alt'].reduce(function (obj, attr) {
                obj[attr === 'href' ? 'source' : attr] = data(el, attr);
                return obj;
            }, {});
        }

        var obj;

        var containers = {};

        var Notification = {

            functional: true,

            args: ['message', 'status'],

            data: {
                message: '',
                status: '',
                timeout: 5000,
                group: null,
                pos: 'top-center',
                clsClose: 'uk-notification-close',
                clsMsg: 'uk-notification-message'
            },

            install: install$3,

            computed: {

                marginProp: function(ref) {
                    var pos = ref.pos;

                    return ("margin" + (startsWith(pos, 'top') ? 'Top' : 'Bottom'));
                },

                startProps: function() {
                    var obj;

                    return ( obj = {opacity: 0}, obj[this.marginProp] = -this.$el.offsetHeight, obj );
                }

            },

            created: function() {

                if (!containers[this.pos]) {
                    containers[this.pos] = append(this.$container, ("<div class=\"uk-notification uk-notification-" + (this.pos) + "\"></div>"));
                }

                var container = css(containers[this.pos], 'display', 'block');

                this.$mount(append(container,
                    ("<div class=\"" + (this.clsMsg) + (this.status ? (" " + (this.clsMsg) + "-" + (this.status)) : '') + "\"> <a href=\"#\" class=\"" + (this.clsClose) + "\" data-uk-close></a> <div>" + (this.message) + "</div> </div>")
                ));

            },

            connected: function() {
                var this$1 = this;
                var obj;


                var margin = toFloat(css(this.$el, this.marginProp));
                Transition.start(
                    css(this.$el, this.startProps),
                    ( obj = {opacity: 1}, obj[this.marginProp] = margin, obj )
                ).then(function () {
                    if (this$1.timeout) {
                        this$1.timer = setTimeout(this$1.close, this$1.timeout);
                    }
                });

            },

            events: ( obj = {

                click: function(e) {
                    if (closest(e.target, 'a[href="#"],a[href=""]')) {
                        e.preventDefault();
                    }
                    this.close();
                }

            }, obj[pointerEnter] = function () {
                    if (this.timer) {
                        clearTimeout(this.timer);
                    }
                }, obj[pointerLeave] = function () {
                    if (this.timeout) {
                        this.timer = setTimeout(this.close, this.timeout);
                    }
                }, obj ),

            methods: {

                close: function(immediate) {
                    var this$1 = this;


                    var removeFn = function () {

                        trigger(this$1.$el, 'close', [this$1]);
                        remove(this$1.$el);

                        if (!containers[this$1.pos].children.length) {
                            css(containers[this$1.pos], 'display', 'none');
                        }

                    };

                    if (this.timer) {
                        clearTimeout(this.timer);
                    }

                    if (immediate) {
                        removeFn();
                    } else {
                        Transition.start(this.$el, this.startProps).then(removeFn);
                    }
                }

            }

        };

        function install$3(UIkit) {
            UIkit.notification.closeAll = function (group, immediate) {
                apply(document.body, function (el) {
                    var notification = UIkit.getComponent(el, 'notification');
                    if (notification && (!group || group === notification.group)) {
                        notification.close(immediate);
                    }
                });
            };
        }

        var props = ['x', 'y', 'bgx', 'bgy', 'rotate', 'scale', 'color', 'backgroundColor', 'borderColor', 'opacity', 'blur', 'hue', 'grayscale', 'invert', 'saturate', 'sepia', 'fopacity', 'stroke'];

        var Parallax = {

            mixins: [Media],

            props: props.reduce(function (props, prop) {
                props[prop] = 'list';
                return props;
            }, {}),

            data: props.reduce(function (data, prop) {
                data[prop] = undefined;
                return data;
            }, {}),

            computed: {

                props: function(properties, $el) {
                    var this$1 = this;


                    return props.reduce(function (props, prop) {

                        if (isUndefined(properties[prop])) {
                            return props;
                        }

                        var isColor = prop.match(/color/i);
                        var isCssProp = isColor || prop === 'opacity';

                        var pos, bgPos, diff;
                        var steps = properties[prop].slice(0);

                        if (isCssProp) {
                            css($el, prop, '');
                        }

                        if (steps.length < 2) {
                            steps.unshift((prop === 'scale'
                                ? 1
                                : isCssProp
                                    ? css($el, prop)
                                    : 0) || 0);
                        }

                        var unit = getUnit(steps);

                        if (isColor) {

                            var ref = $el.style;
                            var color = ref.color;
                            steps = steps.map(function (step) { return parseColor($el, step); });
                            $el.style.color = color;

                        } else if (startsWith(prop, 'bg')) {

                            var attr = prop === 'bgy' ? 'height' : 'width';
                            steps = steps.map(function (step) { return toPx(step, attr, this$1.$el); });

                            css($el, ("background-position-" + (prop[2])), '');
                            bgPos = css($el, 'backgroundPosition').split(' ')[prop[2] === 'x' ? 0 : 1]; // IE 11 can't read background-position-[x|y]

                            if (this$1.covers) {

                                var min = Math.min.apply(Math, steps);
                                var max = Math.max.apply(Math, steps);
                                var down = steps.indexOf(min) < steps.indexOf(max);

                                diff = max - min;

                                steps = steps.map(function (step) { return step - (down ? min : max); });
                                pos = (down ? -diff : 0) + "px";

                            } else {

                                pos = bgPos;

                            }

                        } else {

                            steps = steps.map(toFloat);

                        }

                        if (prop === 'stroke') {

                            if (!steps.some(function (step) { return step; })) {
                                return props;
                            }

                            var length = getMaxPathLength(this$1.$el);
                            css($el, 'strokeDasharray', length);

                            if (unit === '%') {
                                steps = steps.map(function (step) { return step * length / 100; });
                            }

                            steps = steps.reverse();

                            prop = 'strokeDashoffset';
                        }

                        props[prop] = {steps: steps, unit: unit, pos: pos, bgPos: bgPos, diff: diff};

                        return props;

                    }, {});

                },

                bgProps: function() {
                    var this$1 = this;

                    return ['bgx', 'bgy'].filter(function (bg) { return bg in this$1.props; });
                },

                covers: function(_, $el) {
                    return covers($el);
                }

            },

            disconnected: function() {
                delete this._image;
            },

            update: {

                read: function(data) {
                    var this$1 = this;


                    data.active = this.matchMedia;

                    if (!data.active) {
                        return;
                    }

                    if (!data.image && this.covers && this.bgProps.length) {
                        var src = css(this.$el, 'backgroundImage').replace(/^none|url\(["']?(.+?)["']?\)$/, '$1');

                        if (src) {
                            var img = new Image();
                            img.src = src;
                            data.image = img;

                            if (!img.naturalWidth) {
                                img.onload = function () { return this$1.$emit(); };
                            }
                        }

                    }

                    var image = data.image;

                    if (!image || !image.naturalWidth) {
                        return;
                    }

                    var dimEl = {
                        width: this.$el.offsetWidth,
                        height: this.$el.offsetHeight
                    };
                    var dimImage = {
                        width: image.naturalWidth,
                        height: image.naturalHeight
                    };

                    var dim = Dimensions.cover(dimImage, dimEl);

                    this.bgProps.forEach(function (prop) {

                        var ref = this$1.props[prop];
                        var diff = ref.diff;
                        var bgPos = ref.bgPos;
                        var steps = ref.steps;
                        var attr = prop === 'bgy' ? 'height' : 'width';
                        var span = dim[attr] - dimEl[attr];

                        if (span < diff) {
                            dimEl[attr] = dim[attr] + diff - span;
                        } else if (span > diff) {

                            var posPercentage = dimEl[attr] / toPx(bgPos, attr, this$1.$el);

                            if (posPercentage) {
                                this$1.props[prop].steps = steps.map(function (step) { return step - (span - diff) / posPercentage; });
                            }
                        }

                        dim = Dimensions.cover(dimImage, dimEl);
                    });

                    data.dim = dim;
                },

                write: function(ref) {
                    var dim = ref.dim;
                    var active = ref.active;


                    if (!active) {
                        css(this.$el, {backgroundSize: '', backgroundRepeat: ''});
                        return;
                    }

                    dim && css(this.$el, {
                        backgroundSize: ((dim.width) + "px " + (dim.height) + "px"),
                        backgroundRepeat: 'no-repeat'
                    });

                },

                events: ['resize']

            },

            methods: {

                reset: function() {
                    var this$1 = this;

                    each(this.getCss(0), function (_, prop) { return css(this$1.$el, prop, ''); });
                },

                getCss: function(percent) {

                    var ref = this;
                    var props = ref.props;
                    return Object.keys(props).reduce(function (css, prop) {

                        var ref = props[prop];
                        var steps = ref.steps;
                        var unit = ref.unit;
                        var pos = ref.pos;
                        var value = getValue(steps, percent);

                        switch (prop) {

                            // transforms
                            case 'x':
                            case 'y': {
                                unit = unit || 'px';
                                css.transform += " translate" + (ucfirst(prop)) + "(" + (toFloat(value).toFixed(unit === 'px' ? 0 : 2)) + unit + ")";
                                break;
                            }
                            case 'rotate':
                                unit = unit || 'deg';
                                css.transform += " rotate(" + (value + unit) + ")";
                                break;
                            case 'scale':
                                css.transform += " scale(" + value + ")";
                                break;

                            // bg image
                            case 'bgy':
                            case 'bgx':
                                css[("background-position-" + (prop[2]))] = "calc(" + pos + " + " + value + "px)";
                                break;

                            // color
                            case 'color':
                            case 'backgroundColor':
                            case 'borderColor': {

                                var ref$1 = getStep(steps, percent);
                                var start = ref$1[0];
                                var end = ref$1[1];
                                var p = ref$1[2];

                                css[prop] = "rgba(" + (start.map(function (value, i) {
                                        value = value + p * (end[i] - value);
                                        return i === 3 ? toFloat(value) : parseInt(value, 10);
                                    }).join(',')) + ")";
                                break;
                            }
                            // CSS Filter
                            case 'blur':
                                unit = unit || 'px';
                                css.filter += " blur(" + (value + unit) + ")";
                                break;
                            case 'hue':
                                unit = unit || 'deg';
                                css.filter += " hue-rotate(" + (value + unit) + ")";
                                break;
                            case 'fopacity':
                                unit = unit || '%';
                                css.filter += " opacity(" + (value + unit) + ")";
                                break;
                            case 'grayscale':
                            case 'invert':
                            case 'saturate':
                            case 'sepia':
                                unit = unit || '%';
                                css.filter += " " + prop + "(" + (value + unit) + ")";
                                break;
                            default:
                                css[prop] = value;
                        }

                        return css;

                    }, {transform: '', filter: ''});

                }

            }

        };

        function parseColor(el, color) {
            return css(css(el, 'color', color), 'color')
                .split(/[(),]/g)
                .slice(1, -1)
                .concat(1)
                .slice(0, 4)
                .map(toFloat);
        }

        function getStep(steps, percent) {
            var count = steps.length - 1;
            var index = Math.min(Math.floor(count * percent), count - 1);
            var step = steps.slice(index, index + 2);

            step.push(percent === 1 ? 1 : percent % (1 / count) * count);

            return step;
        }

        function getValue(steps, percent, digits) {
            if ( digits === void 0 ) digits = 2;

            var ref = getStep(steps, percent);
            var start = ref[0];
            var end = ref[1];
            var p = ref[2];
            return (isNumber(start)
                ? start + Math.abs(start - end) * p * (start < end ? 1 : -1)
                : +end
            ).toFixed(digits);
        }

        function getUnit(steps) {
            return steps.reduce(function (unit, step) { return isString(step) && step.replace(/-|\d/g, '').trim() || unit; }, '');
        }

        function covers(el) {
            var ref = el.style;
            var backgroundSize = ref.backgroundSize;
            var covers = css(css(el, 'backgroundSize', ''), 'backgroundSize') === 'cover';
            el.style.backgroundSize = backgroundSize;
            return covers;
        }

        var Parallax$1 = {

            mixins: [Parallax],

            props: {
                target: String,
                viewport: Number,
                easing: Number
            },

            data: {
                target: false,
                viewport: 1,
                easing: 1
            },

            computed: {

                target: function(ref, $el) {
                    var target = ref.target;

                    return getOffsetElement(target && query(target, $el) || $el);
                }

            },

            update: {

                read: function(ref, type) {
                    var percent = ref.percent;
                    var active = ref.active;


                    if (type !== 'scroll') {
                        percent = false;
                    }

                    if (!active) {
                        return;
                    }

                    var prev = percent;
                    percent = ease$1(scrolledOver(this.target) / (this.viewport || 1), this.easing);

                    return {
                        percent: percent,
                        style: prev !== percent ? this.getCss(percent) : false
                    };
                },

                write: function(ref) {
                    var style = ref.style;
                    var active = ref.active;


                    if (!active) {
                        this.reset();
                        return;
                    }

                    style && css(this.$el, style);

                },

                events: ['scroll', 'resize']
            }

        };

        function ease$1(percent, easing) {
            return clamp(percent * (1 - (easing - easing * percent)));
        }

        // SVG elements do not inherit from HTMLElement
        function getOffsetElement(el) {
            return el
                ? 'offsetTop' in el
                    ? el
                    : getOffsetElement(el.parentNode)
                : document.body;
        }

        var SliderReactive = {

            update: {

                write: function() {

                    if (this.stack.length || this.dragging) {
                        return;
                    }

                    var index = this.getValidIndex();
                    delete this.index;
                    removeClass(this.slides, this.clsActive, this.clsActivated);
                    this.show(index);

                },

                events: ['resize']

            }

        };

        function Transitioner$1 (prev, next, dir, ref) {
            var center = ref.center;
            var easing = ref.easing;
            var list = ref.list;


            var deferred = new Deferred();

            var from = prev
                ? getLeft(prev, list, center)
                : getLeft(next, list, center) + bounds(next).width * dir;
            var to = next
                ? getLeft(next, list, center)
                : from + bounds(prev).width * dir * (isRtl ? -1 : 1);

            return {

                dir: dir,

                show: function(duration, percent, linear) {
                    if ( percent === void 0 ) percent = 0;


                    var timing = linear ? 'linear' : easing;
                    duration -= Math.round(duration * clamp(percent, -1, 1));

                    this.translate(percent);

                    prev && this.updateTranslates();
                    percent = prev ? percent : clamp(percent, 0, 1);
                    triggerUpdate$1(this.getItemIn(), 'itemin', {percent: percent, duration: duration, timing: timing, dir: dir});
                    prev && triggerUpdate$1(this.getItemIn(true), 'itemout', {percent: 1 - percent, duration: duration, timing: timing, dir: dir});

                    Transition
                        .start(list, {transform: translate(-to * (isRtl ? -1 : 1), 'px')}, duration, timing)
                        .then(deferred.resolve, noop);

                    return deferred.promise;

                },

                stop: function() {
                    return Transition.stop(list);
                },

                cancel: function() {
                    Transition.cancel(list);
                },

                reset: function() {
                    css(list, 'transform', '');
                },

                forward: function(duration, percent) {
                    if ( percent === void 0 ) percent = this.percent();

                    Transition.cancel(list);
                    return this.show(duration, percent, true);
                },

                translate: function(percent) {

                    var distance = this.getDistance() * dir * (isRtl ? -1 : 1);

                    css(list, 'transform', translate(clamp(
                        -to + (distance - distance * percent),
                        -getWidth(list),
                        bounds(list).width
                    ) * (isRtl ? -1 : 1), 'px'));

                    this.updateTranslates();

                    if (prev) {
                        percent = clamp(percent, -1, 1);
                        triggerUpdate$1(this.getItemIn(), 'itemtranslatein', {percent: percent, dir: dir});
                        triggerUpdate$1(this.getItemIn(true), 'itemtranslateout', {percent: 1 - percent, dir: dir});
                    }

                },

                percent: function() {
                    return Math.abs((css(list, 'transform').split(',')[4] * (isRtl ? -1 : 1) + from) / (to - from));
                },

                getDistance: function() {
                    return Math.abs(to - from);
                },

                getItemIn: function(out) {
                    if ( out === void 0 ) out = false;


                    var actives = this.getActives();
                    var all = sortBy(slides(list), 'offsetLeft');
                    var i = index(all, actives[dir * (out ? -1 : 1) > 0 ? actives.length - 1 : 0]);

                    return ~i && all[i + (prev && !out ? dir : 0)];

                },

                getActives: function() {

                    var left = getLeft(prev || next, list, center);

                    return sortBy(slides(list).filter(function (slide) {
                        var slideLeft = getElLeft(slide, list);
                        return slideLeft >= left && slideLeft + bounds(slide).width <= bounds(list).width + left;
                    }), 'offsetLeft');

                },

                updateTranslates: function() {

                    var actives = this.getActives();

                    slides(list).forEach(function (slide) {
                        var isActive = includes(actives, slide);

                        triggerUpdate$1(slide, ("itemtranslate" + (isActive ? 'in' : 'out')), {
                            percent: isActive ? 1 : 0,
                            dir: slide.offsetLeft <= next.offsetLeft ? 1 : -1
                        });
                    });
                }

            };

        }

        function getLeft(el, list, center) {

            var left = getElLeft(el, list);

            return center
                ? left - centerEl(el, list)
                : Math.min(left, getMax(list));

        }

        function getMax(list) {
            return Math.max(0, getWidth(list) - bounds(list).width);
        }

        function getWidth(list) {
            return slides(list).reduce(function (right, el) { return bounds(el).width + right; }, 0);
        }

        function getMaxWidth(list) {
            return slides(list).reduce(function (right, el) { return Math.max(right, bounds(el).width); }, 0);
        }

        function centerEl(el, list) {
            return bounds(list).width / 2 - bounds(el).width / 2;
        }

        function getElLeft(el, list) {
            return (position(el).left + (isRtl ? bounds(el).width - bounds(list).width : 0)) * (isRtl ? -1 : 1);
        }

        function bounds(el) {
            return el.getBoundingClientRect();
        }

        function triggerUpdate$1(el, type, data) {
            trigger(el, createEvent(type, false, false, data));
        }

        function slides(list) {
            return toNodes(list.children);
        }

        var Slider$1 = {

            mixins: [Class, Slider, SliderReactive],

            props: {
                center: Boolean,
                sets: Boolean
            },

            data: {
                center: false,
                sets: false,
                attrItem: 'uk-slider-item',
                selList: '.uk-slider-items',
                selNav: '.uk-slider-nav',
                clsContainer: 'uk-slider-container',
                Transitioner: Transitioner$1
            },

            computed: {

                avgWidth: function() {
                    return getWidth(this.list) / this.length;
                },

                finite: function(ref) {
                    var finite = ref.finite;

                    return finite || getWidth(this.list) < bounds(this.list).width + getMaxWidth(this.list) + this.center;
                },

                maxIndex: function() {

                    if (!this.finite || this.center && !this.sets) {
                        return this.length - 1;
                    }

                    if (this.center) {
                        return this.sets[this.sets.length - 1];
                    }

                    css(this.slides, 'order', '');

                    var max = getMax(this.list);
                    var i = this.length;

                    while (i--) {
                        if (getElLeft(this.list.children[i], this.list) < max) {
                            return Math.min(i + 1, this.length - 1);
                        }
                    }

                    return 0;
                },

                sets: function(ref) {
                    var this$1 = this;
                    var sets = ref.sets;


                    var width = bounds(this.list).width / (this.center ? 2 : 1);

                    var left = 0;
                    var leftCenter = width;
                    var slideLeft = 0;

                    sets = sets && this.slides.reduce(function (sets, slide, i) {

                        var ref = bounds(slide);
                        var slideWidth = ref.width;
                        var slideRight = slideLeft + slideWidth;

                        if (slideRight > left) {

                            if (!this$1.center && i > this$1.maxIndex) {
                                i = this$1.maxIndex;
                            }

                            if (!includes(sets, i)) {

                                var cmp = this$1.slides[i + 1];
                                if (this$1.center && cmp && slideWidth < leftCenter - bounds(cmp).width / 2) {
                                    leftCenter -= slideWidth;
                                } else {
                                    leftCenter = width;
                                    sets.push(i);
                                    left = slideLeft + width + (this$1.center ? slideWidth / 2 : 0);
                                }

                            }
                        }

                        slideLeft += slideWidth;

                        return sets;

                    }, []);

                    return !isEmpty(sets) && sets;

                },

                transitionOptions: function() {
                    return {
                        center: this.center,
                        list: this.list
                    };
                }

            },

            connected: function() {
                toggleClass(this.$el, this.clsContainer, !$(("." + (this.clsContainer)), this.$el));
            },

            update: {

                write: function() {
                    var this$1 = this;


                    $$(("[" + (this.attrItem) + "],[data-" + (this.attrItem) + "]"), this.$el).forEach(function (el) {
                        var index = data(el, this$1.attrItem);
                        this$1.maxIndex && toggleClass(el, 'uk-hidden', isNumeric(index) && (this$1.sets && !includes(this$1.sets, toFloat(index)) || index > this$1.maxIndex));
                    });

                },

                events: ['resize']

            },

            events: {

                beforeitemshow: function(e) {

                    if (!this.dragging && this.sets && this.stack.length < 2 && !includes(this.sets, this.index)) {
                        this.index = this.getValidIndex();
                    }

                    var diff = Math.abs(
                        this.index
                        - this.prevIndex
                        + (this.dir > 0 && this.index < this.prevIndex || this.dir < 0 && this.index > this.prevIndex ? (this.maxIndex + 1) * this.dir : 0)
                    );

                    if (!this.dragging && diff > 1) {

                        for (var i = 0; i < diff; i++) {
                            this.stack.splice(1, 0, this.dir > 0 ? 'next' : 'previous');
                        }

                        e.preventDefault();
                        return;
                    }

                    this.duration = speedUp(this.avgWidth / this.velocity)
                        * (bounds(
                            this.dir < 0 || !this.slides[this.prevIndex]
                                ? this.slides[this.index]
                                : this.slides[this.prevIndex]
                        ).width / this.avgWidth);

                    this.reorder();

                },

                itemshow: function() {
                    !isUndefined(this.prevIndex) && addClass(this._getTransitioner().getItemIn(), this.clsActive);
                },

                itemshown: function() {
                    var this$1 = this;

                    var actives = this._getTransitioner(this.index).getActives();
                    this.slides.forEach(function (slide) { return toggleClass(slide, this$1.clsActive, includes(actives, slide)); });
                    (!this.sets || includes(this.sets, toFloat(this.index))) && this.slides.forEach(function (slide) { return toggleClass(slide, this$1.clsActivated, includes(actives, slide)); });
                }

            },

            methods: {

                reorder: function() {
                    var this$1 = this;


                    css(this.slides, 'order', '');

                    if (this.finite) {
                        return;
                    }

                    var index = this.dir > 0 && this.slides[this.prevIndex] ? this.prevIndex : this.index;

                    this.slides.forEach(function (slide, i) { return css(slide, 'order', this$1.dir > 0 && i < index
                            ? 1
                            : this$1.dir < 0 && i >= this$1.index
                                ? -1
                                : ''
                        ); }
                    );

                    if (!this.center) {
                        return;
                    }

                    var next = this.slides[index];
                    var width = bounds(this.list).width / 2 - bounds(next).width / 2;
                    var j = 0;

                    while (width > 0) {
                        var slideIndex = this.getIndex(--j + index, index);
                        var slide = this.slides[slideIndex];

                        css(slide, 'order', slideIndex > index ? -2 : -1);
                        width -= bounds(slide).width;
                    }

                },

                getValidIndex: function(index, prevIndex) {
                    if ( index === void 0 ) index = this.index;
                    if ( prevIndex === void 0 ) prevIndex = this.prevIndex;


                    index = this.getIndex(index, prevIndex);

                    if (!this.sets) {
                        return index;
                    }

                    var prev;

                    do {

                        if (includes(this.sets, index)) {
                            return index;
                        }

                        prev = index;
                        index = this.getIndex(index + this.dir, prevIndex);

                    } while (index !== prev);

                    return index;
                }

            }

        };

        var SliderParallax = {

            mixins: [Parallax],

            data: {
                selItem: '!li'
            },

            computed: {

                item: function(ref, $el) {
                    var selItem = ref.selItem;

                    return query(selItem, $el);
                }

            },

            events: [

                {

                    name: 'itemshown',

                    self: true,

                    el: function() {
                        return this.item;
                    },

                    handler: function() {
                        css(this.$el, this.getCss(.5));
                    }

                },

                {
                    name: 'itemin itemout',

                    self: true,

                    el: function() {
                        return this.item;
                    },

                    handler: function(ref) {
                        var type = ref.type;
                        var ref_detail = ref.detail;
                        var percent = ref_detail.percent;
                        var duration = ref_detail.duration;
                        var timing = ref_detail.timing;
                        var dir = ref_detail.dir;


                        Transition.cancel(this.$el);
                        css(this.$el, this.getCss(getCurrent(type, dir, percent)));

                        Transition.start(this.$el, this.getCss(isIn(type)
                            ? .5
                            : dir > 0
                                ? 1
                                : 0
                        ), duration, timing).catch(noop);

                    }
                },

                {
                    name: 'transitioncanceled transitionend',

                    self: true,

                    el: function() {
                        return this.item;
                    },

                    handler: function() {
                        Transition.cancel(this.$el);
                    }

                },

                {
                    name: 'itemtranslatein itemtranslateout',

                    self: true,

                    el: function() {
                        return this.item;
                    },

                    handler: function(ref) {
                        var type = ref.type;
                        var ref_detail = ref.detail;
                        var percent = ref_detail.percent;
                        var dir = ref_detail.dir;

                        Transition.cancel(this.$el);
                        css(this.$el, this.getCss(getCurrent(type, dir, percent)));
                    }
                }

            ]

        };

        function isIn(type) {
            return endsWith(type, 'in');
        }

        function getCurrent(type, dir, percent) {

            percent /= 2;

            return !isIn(type)
                ? dir < 0
                    ? percent
                    : 1 - percent
                : dir < 0
                    ? 1 - percent
                    : percent;
        }

        var Animations$2 = assign({}, Animations, {

            fade: {

                show: function() {
                    return [
                        {opacity: 0, zIndex: 0},
                        {zIndex: -1}
                    ];
                },

                percent: function(current) {
                    return 1 - css(current, 'opacity');
                },

                translate: function(percent) {
                    return [
                        {opacity: 1 - percent, zIndex: 0},
                        {zIndex: -1}
                    ];
                }

            },

            scale: {

                show: function() {
                    return [
                        {opacity: 0, transform: scale3d(1 + .5), zIndex: 0},
                        {zIndex: -1}
                    ];
                },

                percent: function(current) {
                    return 1 - css(current, 'opacity');
                },

                translate: function(percent) {
                    return [
                        {opacity: 1 - percent, transform: scale3d(1 + .5 * percent), zIndex: 0},
                        {zIndex: -1}
                    ];
                }

            },

            pull: {

                show: function(dir) {
                    return dir < 0
                        ? [
                            {transform: translate(30), zIndex: -1},
                            {transform: translate(), zIndex: 0}
                        ]
                        : [
                            {transform: translate(-100), zIndex: 0},
                            {transform: translate(), zIndex: -1}
                        ];
                },

                percent: function(current, next, dir) {
                    return dir < 0
                        ? 1 - translated(next)
                        : translated(current);
                },

                translate: function(percent, dir) {
                    return dir < 0
                        ? [
                            {transform: translate(30 * percent), zIndex: -1},
                            {transform: translate(-100 * (1 - percent)), zIndex: 0}
                        ]
                        : [
                            {transform: translate(-percent * 100), zIndex: 0},
                            {transform: translate(30 * (1 - percent)), zIndex: -1}
                        ];
                }

            },

            push: {

                show: function(dir) {
                    return dir < 0
                        ? [
                            {transform: translate(100), zIndex: 0},
                            {transform: translate(), zIndex: -1}
                        ]
                        : [
                            {transform: translate(-30), zIndex: -1},
                            {transform: translate(), zIndex: 0}
                        ];
                },

                percent: function(current, next, dir) {
                    return dir > 0
                        ? 1 - translated(next)
                        : translated(current);
                },

                translate: function(percent, dir) {
                    return dir < 0
                        ? [
                            {transform: translate(percent * 100), zIndex: 0},
                            {transform: translate(-30 * (1 - percent)), zIndex: -1}
                        ]
                        : [
                            {transform: translate(-30 * percent), zIndex: -1},
                            {transform: translate(100 * (1 - percent)), zIndex: 0}
                        ];
                }

            }

        });

        var Slideshow$1 = {

            mixins: [Class, Slideshow, SliderReactive],

            props: {
                ratio: String,
                minHeight: Number,
                maxHeight: Number
            },

            data: {
                ratio: '16:9',
                minHeight: false,
                maxHeight: false,
                selList: '.uk-slideshow-items',
                attrItem: 'uk-slideshow-item',
                selNav: '.uk-slideshow-nav',
                Animations: Animations$2
            },

            update: {

                read: function() {

                    var ref = this.ratio.split(':').map(Number);
                    var width = ref[0];
                    var height = ref[1];

                    height = height * this.list.offsetWidth / width || 0;

                    if (this.minHeight) {
                        height = Math.max(this.minHeight, height);
                    }

                    if (this.maxHeight) {
                        height = Math.min(this.maxHeight, height);
                    }

                    return {height: height - boxModelAdjust(this.list, 'content-box')};
                },

                write: function(ref) {
                    var height = ref.height;

                    css(this.list, 'minHeight', height);
                },

                events: ['resize']

            }

        };

        var Sortable = {

            mixins: [Class, Animate],

            props: {
                group: String,
                threshold: Number,
                clsItem: String,
                clsPlaceholder: String,
                clsDrag: String,
                clsDragState: String,
                clsBase: String,
                clsNoDrag: String,
                clsEmpty: String,
                clsCustom: String,
                handle: String
            },

            data: {
                group: false,
                threshold: 5,
                clsItem: 'uk-sortable-item',
                clsPlaceholder: 'uk-sortable-placeholder',
                clsDrag: 'uk-sortable-drag',
                clsDragState: 'uk-drag',
                clsBase: 'uk-sortable',
                clsNoDrag: 'uk-sortable-nodrag',
                clsEmpty: 'uk-sortable-empty',
                clsCustom: '',
                handle: false
            },

            created: function() {
                var this$1 = this;

                ['init', 'start', 'move', 'end'].forEach(function (key) {
                    var fn = this$1[key];
                    this$1[key] = function (e) {
                        this$1.scrollY = window.pageYOffset;
                        var ref = getEventPos(e, 'page');
                        var x = ref.x;
                        var y = ref.y;
                        this$1.pos = {x: x, y: y};

                        fn(e);
                    };
                });
            },

            events: {

                name: pointerDown,
                passive: false,
                handler: 'init'

            },

            update: {

                write: function() {

                    if (this.clsEmpty) {
                        toggleClass(this.$el, this.clsEmpty, isEmpty(this.$el.children));
                    }

                    css(this.handle ? $$(this.handle, this.$el) : this.$el.children, {touchAction: 'none', userSelect: 'none'});

                    if (!this.drag) {
                        return;
                    }

                    offset(this.drag, {top: this.pos.y + this.origin.top, left: this.pos.x + this.origin.left});

                    var ref = offset(this.drag);
                    var top = ref.top;
                    var offsetHeight = ref.height;
                    var bottom = top + offsetHeight;
                    var scroll;

                    if (top > 0 && top < this.scrollY) {
                        scroll = this.scrollY - 5;
                    } else if (bottom < height(document) && bottom > height(window) + this.scrollY) {
                        scroll = this.scrollY + 5;
                    }

                    scroll && setTimeout(function () { return scrollTop(window, scroll); }, 5);
                }

            },

            methods: {

                init: function(e) {

                    var target = e.target;
                    var button = e.button;
                    var defaultPrevented = e.defaultPrevented;
                    var ref = toNodes(this.$el.children).filter(function (el) { return within(target, el); });
                    var placeholder = ref[0];

                    if (!placeholder
                        || defaultPrevented
                        || button > 0
                        || isInput(target)
                        || within(target, ("." + (this.clsNoDrag)))
                        || this.handle && !within(target, this.handle)
                    ) {
                        return;
                    }

                    e.preventDefault();

                    this.touched = [this];
                    this.placeholder = placeholder;
                    this.origin = assign({target: target, index: index(placeholder)}, this.pos);

                    on(document, pointerMove, this.move);
                    on(document, pointerUp, this.end);
                    on(window, 'scroll', this.scroll);

                    if (!this.threshold) {
                        this.start(e);
                    }

                },

                start: function(e) {

                    this.drag = append(this.$container, this.placeholder.outerHTML.replace(/^<li/i, '<div').replace(/li>$/i, 'div>'));

                    css(this.drag, assign({
                        boxSizing: 'border-box',
                        width: this.placeholder.offsetWidth,
                        height: this.placeholder.offsetHeight
                    }, css(this.placeholder, ['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom'])));
                    attr(this.drag, 'uk-no-boot', '');
                    addClass(this.drag, this.clsDrag, this.clsCustom);

                    height(this.drag.firstElementChild, height(this.placeholder.firstElementChild));

                    var ref = offset(this.placeholder);
                    var left = ref.left;
                    var top = ref.top;
                    assign(this.origin, {left: left - this.pos.x, top: top - this.pos.y});

                    addClass(this.placeholder, this.clsPlaceholder);
                    addClass(this.$el.children, this.clsItem);
                    addClass(document.documentElement, this.clsDragState);

                    trigger(this.$el, 'start', [this, this.placeholder]);

                    this.move(e);
                },

                move: function(e) {

                    if (!this.drag) {

                        if (Math.abs(this.pos.x - this.origin.x) > this.threshold || Math.abs(this.pos.y - this.origin.y) > this.threshold) {
                            this.start(e);
                        }

                        return;
                    }

                    this.$emit();

                    var target = e.type === 'mousemove' ? e.target : document.elementFromPoint(this.pos.x - window.pageXOffset, this.pos.y - window.pageYOffset);

                    var sortable = this.getSortable(target);
                    var previous = this.getSortable(this.placeholder);
                    var move = sortable !== previous;

                    if (!sortable || within(target, this.placeholder) || move && (!sortable.group || sortable.group !== previous.group)) {
                        return;
                    }

                    target = sortable.$el === target.parentNode && target || toNodes(sortable.$el.children).filter(function (element) { return within(target, element); })[0];

                    if (move) {
                        previous.remove(this.placeholder);
                    } else if (!target) {
                        return;
                    }

                    sortable.insert(this.placeholder, target);

                    if (!includes(this.touched, sortable)) {
                        this.touched.push(sortable);
                    }

                },

                end: function(e) {

                    off(document, pointerMove, this.move);
                    off(document, pointerUp, this.end);
                    off(window, 'scroll', this.scroll);

                    if (!this.drag) {
                        if (e.type === 'touchend') {
                            e.target.click();
                        }

                        return;
                    }

                    var sortable = this.getSortable(this.placeholder);

                    if (this === sortable) {
                        if (this.origin.index !== index(this.placeholder)) {
                            trigger(this.$el, 'moved', [this, this.placeholder]);
                        }
                    } else {
                        trigger(sortable.$el, 'added', [sortable, this.placeholder]);
                        trigger(this.$el, 'removed', [this, this.placeholder]);
                    }

                    trigger(this.$el, 'stop', [this, this.placeholder]);

                    remove(this.drag);
                    this.drag = null;

                    var classes = this.touched.map(function (sortable) { return ((sortable.clsPlaceholder) + " " + (sortable.clsItem)); }).join(' ');
                    this.touched.forEach(function (sortable) { return removeClass(sortable.$el.children, classes); });

                    removeClass(document.documentElement, this.clsDragState);

                },

                scroll: function() {
                    var scroll = window.pageYOffset;
                    if (scroll !== this.scrollY) {
                        this.pos.y += scroll - this.scrollY;
                        this.scrollY = scroll;
                        this.$emit();
                    }
                },

                insert: function(element, target) {
                    var this$1 = this;


                    addClass(this.$el.children, this.clsItem);

                    var insert = function () {

                        if (target) {

                            if (!within(element, this$1.$el) || isPredecessor(element, target)) {
                                before(target, element);
                            } else {
                                after(target, element);
                            }

                        } else {
                            append(this$1.$el, element);
                        }

                    };

                    if (this.animation) {
                        this.animate(insert);
                    } else {
                        insert();
                    }

                },

                remove: function(element) {

                    if (!within(element, this.$el)) {
                        return;
                    }

                    css(this.handle ? $$(this.handle, element) : element, {touchAction: '', userSelect: ''});

                    if (this.animation) {
                        this.animate(function () { return remove(element); });
                    } else {
                        remove(element);
                    }

                },

                getSortable: function(element) {
                    return element && (this.$getComponent(element, 'sortable') || this.getSortable(element.parentNode));
                }

            }

        };

        function isPredecessor(element, target) {
            return element.parentNode === target.parentNode && index(element) > index(target);
        }

        var obj$1;

        var actives = [];

        var Tooltip = {

            mixins: [Container, Togglable, Position],

            args: 'title',

            props: {
                delay: Number,
                title: String
            },

            data: {
                pos: 'top',
                title: '',
                delay: 0,
                animation: ['uk-animation-scale-up'],
                duration: 100,
                cls: 'uk-active',
                clsPos: 'uk-tooltip'
            },

            beforeConnect: function() {
                this._hasTitle = hasAttr(this.$el, 'title');
                attr(this.$el, {title: '', 'aria-expanded': false});
            },

            disconnected: function() {
                this.hide();
                attr(this.$el, {title: this._hasTitle ? this.title : null, 'aria-expanded': null});
            },

            methods: {

                show: function() {
                    var this$1 = this;


                    if (this.isActive()) {
                        return;
                    }

                    actives.forEach(function (active) { return active.hide(); });
                    actives.push(this);

                    this._unbind = on(document, pointerUp, function (e) { return !within(e.target, this$1.$el) && this$1.hide(); });

                    clearTimeout(this.showTimer);
                    this.showTimer = setTimeout(function () {
                        this$1._show();
                        this$1.hideTimer = setInterval(function () {

                            if (!isVisible(this$1.$el)) {
                                this$1.hide();
                            }

                        }, 150);
                    }, this.delay);
                },

                hide: function() {

                    if (!this.isActive() || matches(this.$el, 'input') && this.$el === document.activeElement) {
                        return;
                    }

                    actives.splice(actives.indexOf(this), 1);

                    clearTimeout(this.showTimer);
                    clearInterval(this.hideTimer);
                    attr(this.$el, 'aria-expanded', false);
                    this.toggleElement(this.tooltip, false);
                    this.tooltip && remove(this.tooltip);
                    this.tooltip = false;
                    this._unbind();

                },

                _show: function() {

                    this.tooltip = append(this.container,
                        ("<div class=\"" + (this.clsPos) + "\" aria-expanded=\"true\" aria-hidden> <div class=\"" + (this.clsPos) + "-inner\">" + (this.title) + "</div> </div>")
                    );

                    this.positionAt(this.tooltip, this.$el);

                    this.origin = this.getAxis() === 'y'
                        ? ((flipPosition(this.dir)) + "-" + (this.align))
                        : ((this.align) + "-" + (flipPosition(this.dir)));

                    this.toggleElement(this.tooltip, true);

                },

                isActive: function() {
                    return includes(actives, this);
                }

            },

            events: ( obj$1 = {

                focus: 'show',
                blur: 'hide'

            }, obj$1[(pointerEnter + " " + pointerLeave)] = function (e) {
                    if (isTouch(e)) {
                        return;
                    }
                    e.type === pointerEnter
                        ? this.show()
                        : this.hide();
                }, obj$1[pointerDown] = function (e) {
                    if (!isTouch(e)) {
                        return;
                    }
                    this.isActive()
                        ? this.hide()
                        : this.show();
                }, obj$1 )

        };

        var Upload = {

            props: {
                allow: String,
                clsDragover: String,
                concurrent: Number,
                maxSize: Number,
                method: String,
                mime: String,
                msgInvalidMime: String,
                msgInvalidName: String,
                msgInvalidSize: String,
                multiple: Boolean,
                name: String,
                params: Object,
                type: String,
                url: String
            },

            data: {
                allow: false,
                clsDragover: 'uk-dragover',
                concurrent: 1,
                maxSize: 0,
                method: 'POST',
                mime: false,
                msgInvalidMime: 'Invalid File Type: %s',
                msgInvalidName: 'Invalid File Name: %s',
                msgInvalidSize: 'Invalid File Size: %s Kilobytes Max',
                multiple: false,
                name: 'files[]',
                params: {},
                type: '',
                url: '',
                abort: noop,
                beforeAll: noop,
                beforeSend: noop,
                complete: noop,
                completeAll: noop,
                error: noop,
                fail: noop,
                load: noop,
                loadEnd: noop,
                loadStart: noop,
                progress: noop
            },

            events: {

                change: function(e) {

                    if (!matches(e.target, 'input[type="file"]')) {
                        return;
                    }

                    e.preventDefault();

                    if (e.target.files) {
                        this.upload(e.target.files);
                    }

                    e.target.value = '';
                },

                drop: function(e) {
                    stop(e);

                    var transfer = e.dataTransfer;

                    if (!transfer || !transfer.files) {
                        return;
                    }

                    removeClass(this.$el, this.clsDragover);

                    this.upload(transfer.files);
                },

                dragenter: function(e) {
                    stop(e);
                },

                dragover: function(e) {
                    stop(e);
                    addClass(this.$el, this.clsDragover);
                },

                dragleave: function(e) {
                    stop(e);
                    removeClass(this.$el, this.clsDragover);
                }

            },

            methods: {

                upload: function(files) {
                    var this$1 = this;


                    if (!files.length) {
                        return;
                    }

                    trigger(this.$el, 'upload', [files]);

                    for (var i = 0; i < files.length; i++) {

                        if (this.maxSize && this.maxSize * 1000 < files[i].size) {
                            this.fail(this.msgInvalidSize.replace('%s', this.maxSize));
                            return;
                        }

                        if (this.allow && !match$1(this.allow, files[i].name)) {
                            this.fail(this.msgInvalidName.replace('%s', this.allow));
                            return;
                        }

                        if (this.mime && !match$1(this.mime, files[i].type)) {
                            this.fail(this.msgInvalidMime.replace('%s', this.mime));
                            return;
                        }

                    }

                    if (!this.multiple) {
                        files = [files[0]];
                    }

                    this.beforeAll(this, files);

                    var chunks = chunk(files, this.concurrent);
                    var upload = function (files) {

                        var data = new FormData();

                        files.forEach(function (file) { return data.append(this$1.name, file); });

                        for (var key in this$1.params) {
                            data.append(key, this$1.params[key]);
                        }

                        ajax(this$1.url, {
                            data: data,
                            method: this$1.method,
                            responseType: this$1.type,
                            beforeSend: function (env) {

                                var xhr = env.xhr;
                                xhr.upload && on(xhr.upload, 'progress', this$1.progress);
                                ['loadStart', 'load', 'loadEnd', 'abort'].forEach(function (type) { return on(xhr, type.toLowerCase(), this$1[type]); }
                                );

                                this$1.beforeSend(env);

                            }
                        }).then(
                            function (xhr) {

                                this$1.complete(xhr);

                                if (chunks.length) {
                                    upload(chunks.shift());
                                } else {
                                    this$1.completeAll(xhr);
                                }

                            },
                            function (e) { return this$1.error(e); }
                        );

                    };

                    upload(chunks.shift());

                }

            }

        };

        function match$1(pattern, path) {
            return path.match(new RegExp(("^" + (pattern.replace(/\//g, '\\/').replace(/\*\*/g, '(\\/[^\\/]+)*').replace(/\*/g, '[^\\/]+').replace(/((?!\\))\?/g, '$1.')) + "$"), 'i'));
        }

        function chunk(files, size) {
            var chunks = [];
            for (var i = 0; i < files.length; i += size) {
                var chunk = [];
                for (var j = 0; j < size; j++) {
                    chunk.push(files[i + j]);
                }
                chunks.push(chunk);
            }
            return chunks;
        }

        function stop(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        UIkit.component('countdown', Countdown);
        UIkit.component('filter', Filter);
        UIkit.component('lightbox', Lightbox);
        UIkit.component('lightboxPanel', lightboxPanel);
        UIkit.component('notification', Notification);
        UIkit.component('parallax', Parallax$1);
        UIkit.component('slider', Slider$1);
        UIkit.component('sliderParallax', SliderParallax);
        UIkit.component('slideshow', Slideshow$1);
        UIkit.component('slideshowParallax', SliderParallax);
        UIkit.component('sortable', Sortable);
        UIkit.component('tooltip', Tooltip);
        UIkit.component('upload', Upload);

        {
            boot(UIkit);
        }

        return UIkit;

    }));
    });

    /* src\common\Modal.svelte generated by Svelte v3.6.9 */

    const file$f = "src\\common\\Modal.svelte";

    function create_fragment$e(ctx) {
    	var div1, div0, current;

    	const default_slot_1 = ctx.$$slots.default;
    	const default_slot = create_slot(default_slot_1, ctx, null);

    	return {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");

    			if (default_slot) default_slot.c();

    			attr(div0, "class", "uk-modal-dialog uk-modal-body");
    			attr(div0, "uk-overflow-auto", "");
    			add_location(div0, file$f, 27, 4, 490);
    			attr(div1, "uk-modal", "");
    			add_location(div1, file$f, 26, 0, 449);
    		},

    		l: function claim(nodes) {
    			if (default_slot) default_slot.l(div0_nodes);
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			ctx.div1_binding(div1);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (default_slot && default_slot.p && changed.$$scope) {
    				default_slot.p(get_slot_changes(default_slot_1, ctx, changed, null), get_slot_context(default_slot_1, ctx, null));
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div1);
    			}

    			if (default_slot) default_slot.d(detaching);
    			ctx.div1_binding(null);
    		}
    	};
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { isOpen = false, onClosed = () => {} } = $$props;

    let ukModal;
    let listenerAdded = false;

    	const writable_props = ['isOpen', 'onClosed'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Modal> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('ukModal', ukModal = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ('isOpen' in $$props) $$invalidate('isOpen', isOpen = $$props.isOpen);
    		if ('onClosed' in $$props) $$invalidate('onClosed', onClosed = $$props.onClosed);
    		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
    	};

    	$$self.$$.update = ($$dirty = { ukModal: 1, listenerAdded: 1, onClosed: 1, isOpen: 1 }) => {
    		if ($$dirty.ukModal || $$dirty.listenerAdded || $$dirty.onClosed) { if(ukModal && !listenerAdded) {
                $$invalidate('listenerAdded', listenerAdded = true);
                ukModal.addEventListener("hide", onClosed);
            } }
    		if ($$dirty.ukModal || $$dirty.isOpen) { {
                if(ukModal) {
                    if(isOpen) {
                        uikit.modal(ukModal).show();
                    } else {
                        uikit.modal(ukModal).hide();
                    }
                }
            } }
    	};

    	return {
    		isOpen,
    		onClosed,
    		ukModal,
    		div1_binding,
    		$$slots,
    		$$scope
    	};
    }

    class Modal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, ["isOpen", "onClosed"]);
    	}

    	get isOpen() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isOpen(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClosed() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClosed(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\database\RecordView.svelte generated by Svelte v3.6.9 */

    const file$g = "src\\database\\RecordView.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.index = list[i];
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.field = list[i];
    	return child_ctx;
    }

    // (89:4) {#if !record.isSingle}
    function create_if_block_3$1(ctx) {
    	var updating_text, t, updating_text_1, current;

    	function textbox0_text_binding(value) {
    		ctx.textbox0_text_binding.call(null, value);
    		updating_text = true;
    		add_flush_callback(() => updating_text = false);
    	}

    	let textbox0_props = { label: "Collection Name" };
    	if (ctx.record.collectionName !== void 0) {
    		textbox0_props.text = ctx.record.collectionName;
    	}
    	var textbox0 = new Textbox({ props: textbox0_props, $$inline: true });

    	binding_callbacks.push(() => bind(textbox0, 'text', textbox0_text_binding));

    	function textbox1_text_binding(value_1) {
    		ctx.textbox1_text_binding.call(null, value_1);
    		updating_text_1 = true;
    		add_flush_callback(() => updating_text_1 = false);
    	}

    	let textbox1_props = { label: "Shard Factor" };
    	if (ctx.record.allidsShardFactor !== void 0) {
    		textbox1_props.text = ctx.record.allidsShardFactor;
    	}
    	var textbox1 = new Textbox({ props: textbox1_props, $$inline: true });

    	binding_callbacks.push(() => bind(textbox1, 'text', textbox1_text_binding));

    	return {
    		c: function create() {
    			textbox0.$$.fragment.c();
    			t = space();
    			textbox1.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(textbox0, target, anchor);
    			insert(target, t, anchor);
    			mount_component(textbox1, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var textbox0_changes = {};
    			if (!updating_text && changed.record) {
    				textbox0_changes.text = ctx.record.collectionName;
    			}
    			textbox0.$set(textbox0_changes);

    			var textbox1_changes = {};
    			if (!updating_text_1 && changed.record) {
    				textbox1_changes.text = ctx.record.allidsShardFactor;
    			}
    			textbox1.$set(textbox1_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(textbox0.$$.fragment, local);

    			transition_in(textbox1.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(textbox0.$$.fragment, local);
    			transition_out(textbox1.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(textbox0, detaching);

    			if (detaching) {
    				detach(t);
    			}

    			destroy_component(textbox1, detaching);
    		}
    	};
    }

    // (125:4) {:else}
    function create_else_block_1(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("(no fields added)");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		p: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (98:4) {#if record.fields.length > 0}
    function create_if_block_2$1(ctx) {
    	var table, thead, tr, th0, t1, th1, t3, th2, t5, th3, t6, tbody;

    	var each_value_1 = ctx.record.fields;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	return {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Name";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Type";
    			t3 = space();
    			th2 = element("th");
    			th2.textContent = "Options";
    			t5 = space();
    			th3 = element("th");
    			t6 = space();
    			tbody = element("tbody");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			attr(th0, "class", "svelte-gq7l8x");
    			add_location(th0, file$g, 101, 16, 2903);
    			attr(th1, "class", "svelte-gq7l8x");
    			add_location(th1, file$g, 102, 16, 2934);
    			attr(th2, "class", "svelte-gq7l8x");
    			add_location(th2, file$g, 103, 16, 2965);
    			attr(th3, "class", "svelte-gq7l8x");
    			add_location(th3, file$g, 104, 16, 2999);
    			attr(tr, "class", "svelte-gq7l8x");
    			add_location(tr, file$g, 100, 12, 2881);
    			attr(thead, "class", "svelte-gq7l8x");
    			add_location(thead, file$g, 99, 8, 2860);
    			attr(tbody, "class", "svelte-gq7l8x");
    			add_location(tbody, file$g, 107, 8, 3055);
    			attr(table, "class", "fields-table uk-table svelte-gq7l8x");
    			add_location(table, file$g, 98, 4, 2813);
    		},

    		m: function mount(target, anchor) {
    			insert(target, table, anchor);
    			append(table, thead);
    			append(thead, tr);
    			append(tr, th0);
    			append(tr, t1);
    			append(tr, th1);
    			append(tr, t3);
    			append(tr, th2);
    			append(tr, t5);
    			append(tr, th3);
    			append(table, t6);
    			append(table, tbody);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (changed.getIcon || changed.getTypeOptions || changed.record) {
    				each_value_1 = ctx.record.fields;

    				for (var i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value_1.length;
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(table);
    			}

    			destroy_each(each_blocks, detaching);
    		}
    	};
    }

    // (109:12) {#each record.fields as field}
    function create_each_block_1$1(ctx) {
    	var tr, td0, div0, t0_value = ctx.field.label, t0, t1, div1, t2_value = ctx.field.name, t2, t3, td1, t4_value = ctx.field.type, t4, t5, td2, raw0_value = ctx.getTypeOptions(ctx.field.typeOptions), t6, td3, span0, raw1_value = getIcon("edit"), t7, span1, raw2_value = getIcon("trash"), t8, dispose;

    	function click_handler() {
    		return ctx.click_handler(ctx);
    	}

    	function click_handler_1() {
    		return ctx.click_handler_1(ctx);
    	}

    	return {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			t2 = text(t2_value);
    			t3 = space();
    			td1 = element("td");
    			t4 = text(t4_value);
    			t5 = space();
    			td2 = element("td");
    			t6 = space();
    			td3 = element("td");
    			span0 = element("span");
    			t7 = space();
    			span1 = element("span");
    			t8 = space();
    			add_location(div0, file$g, 111, 20, 3169);
    			set_style(div1, "font-size", "0.7em");
    			set_style(div1, "color", "var(--slate)");
    			add_location(div1, file$g, 112, 20, 3215);
    			attr(td0, "class", "svelte-gq7l8x");
    			add_location(td0, file$g, 110, 16, 3142);
    			attr(td1, "class", "svelte-gq7l8x");
    			add_location(td1, file$g, 114, 16, 3325);
    			attr(td2, "class", "svelte-gq7l8x");
    			add_location(td2, file$g, 115, 16, 3365);
    			attr(span0, "class", "edit-button svelte-gq7l8x");
    			add_location(span0, file$g, 117, 20, 3460);
    			attr(span1, "class", "edit-button svelte-gq7l8x");
    			add_location(span1, file$g, 118, 20, 3572);
    			attr(td3, "class", "svelte-gq7l8x");
    			add_location(td3, file$g, 116, 16, 3434);
    			attr(tr, "class", "svelte-gq7l8x");
    			add_location(tr, file$g, 109, 12, 3120);

    			dispose = [
    				listen(span0, "click", click_handler),
    				listen(span1, "click", click_handler_1)
    			];
    		},

    		m: function mount(target, anchor) {
    			insert(target, tr, anchor);
    			append(tr, td0);
    			append(td0, div0);
    			append(div0, t0);
    			append(td0, t1);
    			append(td0, div1);
    			append(div1, t2);
    			append(tr, t3);
    			append(tr, td1);
    			append(td1, t4);
    			append(tr, t5);
    			append(tr, td2);
    			td2.innerHTML = raw0_value;
    			append(tr, t6);
    			append(tr, td3);
    			append(td3, span0);
    			span0.innerHTML = raw1_value;
    			append(td3, t7);
    			append(td3, span1);
    			span1.innerHTML = raw2_value;
    			append(tr, t8);
    		},

    		p: function update(changed, new_ctx) {
    			ctx = new_ctx;
    			if ((changed.record) && t0_value !== (t0_value = ctx.field.label)) {
    				set_data(t0, t0_value);
    			}

    			if ((changed.record) && t2_value !== (t2_value = ctx.field.name)) {
    				set_data(t2, t2_value);
    			}

    			if ((changed.record) && t4_value !== (t4_value = ctx.field.type)) {
    				set_data(t4, t4_value);
    			}

    			if ((changed.record) && raw0_value !== (raw0_value = ctx.getTypeOptions(ctx.field.typeOptions))) {
    				td2.innerHTML = raw0_value;
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(tr);
    			}

    			run_all(dispose);
    		}
    	};
    }

    // (129:4) {#if editingField}
    function create_if_block_1$1(ctx) {
    	var updating_isOpen, current;

    	function modal_isOpen_binding(value) {
    		ctx.modal_isOpen_binding.call(null, value);
    		updating_isOpen = true;
    		add_flush_callback(() => updating_isOpen = false);
    	}

    	let modal_props = {
    		$$slots: { default: [create_default_slot$1] },
    		$$scope: { ctx }
    	};
    	if (ctx.editingField !== void 0) {
    		modal_props.isOpen = ctx.editingField;
    	}
    	var modal = new Modal({ props: modal_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal, 'isOpen', modal_isOpen_binding));

    	return {
    		c: function create() {
    			modal.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(modal, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var modal_changes = {};
    			if (changed.$$scope || changed.fieldToEdit || changed.onFinishedFieldEdit || changed.record || changed.$database) modal_changes.$$scope = { changed, ctx };
    			if (!updating_isOpen && changed.editingField) {
    				modal_changes.isOpen = ctx.editingField;
    			}
    			modal.$set(modal_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(modal, detaching);
    		}
    	};
    }

    // (130:4) <Modal bind:isOpen={editingField}>
    function create_default_slot$1(ctx) {
    	var current;

    	var fieldview = new FieldView({
    		props: {
    		field: ctx.fieldToEdit,
    		onFinished: ctx.onFinishedFieldEdit,
    		allFields: ctx.record.fields,
    		database: ctx.$database
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			fieldview.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(fieldview, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var fieldview_changes = {};
    			if (changed.fieldToEdit) fieldview_changes.field = ctx.fieldToEdit;
    			if (changed.onFinishedFieldEdit) fieldview_changes.onFinished = ctx.onFinishedFieldEdit;
    			if (changed.record) fieldview_changes.allFields = ctx.record.fields;
    			if (changed.$database) fieldview_changes.database = ctx.$database;
    			fieldview.$set(fieldview_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(fieldview.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(fieldview.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(fieldview, detaching);
    		}
    	};
    }

    // (165:4) {:else}
    function create_else_block$2(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("(no indexes added)");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (158:8) {#if index.filter}
    function create_if_block$4(ctx) {
    	var div, span, t1, code, t2_value = ctx.index.filter, t2;

    	return {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			span.textContent = "filter:";
    			t1 = space();
    			code = element("code");
    			t2 = text(t2_value);
    			attr(span, "class", "index-label svelte-gq7l8x");
    			add_location(span, file$g, 159, 12, 4932);
    			attr(code, "class", "index-mapfilter svelte-gq7l8x");
    			add_location(code, file$g, 160, 12, 4986);
    			attr(div, "class", "index-field-row svelte-gq7l8x");
    			add_location(div, file$g, 158, 8, 4889);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, span);
    			append(div, t1);
    			append(div, code);
    			append(code, t2);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.record) && t2_value !== (t2_value = ctx.index.filter)) {
    				set_data(t2, t2_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}
    		}
    	};
    }

    // (142:4) {#each record.indexes as index}
    function create_each_block$4(ctx) {
    	var div3, div0, t0_value = ctx.index.name, t0, t1, span0, raw_value = getIcon("edit"), t2, div1, span1, t4, span2, t5_value = ctx.getIndexAllowedRecords(ctx.index), t5, t6, span3, t8, span4, t9_value = ctx.index.indexType, t9, t10, div2, span5, t12, code, t13_value = ctx.index.map, t13, t14, t15, dispose;

    	function click_handler_2() {
    		return ctx.click_handler_2(ctx);
    	}

    	var if_block = (ctx.index.filter) && create_if_block$4(ctx);

    	return {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			span0 = element("span");
    			t2 = space();
    			div1 = element("div");
    			span1 = element("span");
    			span1.textContent = "records indexed:";
    			t4 = space();
    			span2 = element("span");
    			t5 = text(t5_value);
    			t6 = space();
    			span3 = element("span");
    			span3.textContent = "type:";
    			t8 = space();
    			span4 = element("span");
    			t9 = text(t9_value);
    			t10 = space();
    			div2 = element("div");
    			span5 = element("span");
    			span5.textContent = "map:";
    			t12 = space();
    			code = element("code");
    			t13 = text(t13_value);
    			t14 = space();
    			if (if_block) if_block.c();
    			t15 = space();
    			set_style(span0, "margin-left", "7px");
    			add_location(span0, file$g, 145, 12, 4271);
    			attr(div0, "class", "index-name svelte-gq7l8x");
    			add_location(div0, file$g, 143, 8, 4207);
    			attr(span1, "class", "index-label svelte-gq7l8x");
    			add_location(span1, file$g, 148, 12, 4435);
    			add_location(span2, file$g, 149, 12, 4500);
    			attr(span3, "class", "index-label svelte-gq7l8x");
    			set_style(span3, "margin-left", "15px");
    			add_location(span3, file$g, 150, 12, 4558);
    			add_location(span4, file$g, 151, 12, 4637);
    			attr(div1, "class", "index-field-row svelte-gq7l8x");
    			add_location(div1, file$g, 147, 8, 4392);
    			attr(span5, "class", "index-label svelte-gq7l8x");
    			add_location(span5, file$g, 154, 12, 4736);
    			attr(code, "class", "index-mapfilter svelte-gq7l8x");
    			add_location(code, file$g, 155, 12, 4787);
    			attr(div2, "class", "index-field-row svelte-gq7l8x");
    			add_location(div2, file$g, 153, 8, 4693);
    			attr(div3, "class", "index-container svelte-gq7l8x");
    			add_location(div3, file$g, 142, 4, 4168);
    			dispose = listen(span0, "click", click_handler_2);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div3, anchor);
    			append(div3, div0);
    			append(div0, t0);
    			append(div0, t1);
    			append(div0, span0);
    			span0.innerHTML = raw_value;
    			append(div3, t2);
    			append(div3, div1);
    			append(div1, span1);
    			append(div1, t4);
    			append(div1, span2);
    			append(span2, t5);
    			append(div1, t6);
    			append(div1, span3);
    			append(div1, t8);
    			append(div1, span4);
    			append(span4, t9);
    			append(div3, t10);
    			append(div3, div2);
    			append(div2, span5);
    			append(div2, t12);
    			append(div2, code);
    			append(code, t13);
    			append(div3, t14);
    			if (if_block) if_block.m(div3, null);
    			append(div3, t15);
    		},

    		p: function update(changed, new_ctx) {
    			ctx = new_ctx;
    			if ((changed.record) && t0_value !== (t0_value = ctx.index.name)) {
    				set_data(t0, t0_value);
    			}

    			if ((changed.getIndexAllowedRecords || changed.record) && t5_value !== (t5_value = ctx.getIndexAllowedRecords(ctx.index))) {
    				set_data(t5, t5_value);
    			}

    			if ((changed.record) && t9_value !== (t9_value = ctx.index.indexType)) {
    				set_data(t9, t9_value);
    			}

    			if ((changed.record) && t13_value !== (t13_value = ctx.index.map)) {
    				set_data(t13, t13_value);
    			}

    			if (ctx.index.filter) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$4(ctx);
    					if_block.c();
    					if_block.m(div3, t15);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div3);
    			}

    			if (if_block) if_block.d();
    			dispose();
    		}
    	};
    }

    function create_fragment$f(ctx) {
    	var div1, updating_text, t0, div0, t1_value = ctx.record.nodeKey(), t1, t2, t3, h40, t4, span, raw_value = getIcon("plus"), t5, t6, t7, h41, t9, current, dispose;

    	function textbox_text_binding(value) {
    		ctx.textbox_text_binding.call(null, value);
    		updating_text = true;
    		add_flush_callback(() => updating_text = false);
    	}

    	let textbox_props = { label: "Name" };
    	if (ctx.record.name !== void 0) {
    		textbox_props.text = ctx.record.name;
    	}
    	var textbox = new Textbox({ props: textbox_props, $$inline: true });

    	binding_callbacks.push(() => bind(textbox, 'text', textbox_text_binding));

    	var if_block0 = (!ctx.record.isSingle) && create_if_block_3$1(ctx);

    	function select_block_type(ctx) {
    		if (ctx.record.fields.length > 0) return create_if_block_2$1;
    		return create_else_block_1;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block1 = current_block_type(ctx);

    	var if_block2 = (ctx.editingField) && create_if_block_1$1(ctx);

    	var each_value = ctx.record.indexes;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	var each_1_else = null;

    	if (!each_value.length) {
    		each_1_else = create_else_block$2();
    		each_1_else.c();
    	}

    	return {
    		c: function create() {
    			div1 = element("div");
    			textbox.$$.fragment.c();
    			t0 = space();
    			div0 = element("div");
    			t1 = text(t1_value);
    			t2 = space();
    			if (if_block0) if_block0.c();
    			t3 = space();
    			h40 = element("h4");
    			t4 = text("Fields ");
    			span = element("span");
    			t5 = space();
    			if_block1.c();
    			t6 = space();
    			if (if_block2) if_block2.c();
    			t7 = space();
    			h41 = element("h4");
    			h41.textContent = "Indexes";
    			t9 = space();

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			add_location(div0, file$g, 87, 4, 2430);
    			attr(span, "class", "add-field-button svelte-gq7l8x");
    			add_location(span, file$g, 94, 15, 2677);
    			add_location(h40, file$g, 93, 4, 2656);
    			add_location(h41, file$g, 137, 4, 4090);
    			attr(div1, "class", "root svelte-gq7l8x");
    			add_location(div1, file$g, 84, 0, 2350);
    			dispose = listen(span, "click", ctx.newField);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div1, anchor);
    			mount_component(textbox, div1, null);
    			append(div1, t0);
    			append(div1, div0);
    			append(div0, t1);
    			append(div1, t2);
    			if (if_block0) if_block0.m(div1, null);
    			append(div1, t3);
    			append(div1, h40);
    			append(h40, t4);
    			append(h40, span);
    			span.innerHTML = raw_value;
    			append(div1, t5);
    			if_block1.m(div1, null);
    			append(div1, t6);
    			if (if_block2) if_block2.m(div1, null);
    			append(div1, t7);
    			append(div1, h41);
    			append(div1, t9);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			if (each_1_else) {
    				each_1_else.m(div1, null);
    			}

    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var textbox_changes = {};
    			if (!updating_text && changed.record) {
    				textbox_changes.text = ctx.record.name;
    			}
    			textbox.$set(textbox_changes);

    			if ((!current || changed.record) && t1_value !== (t1_value = ctx.record.nodeKey())) {
    				set_data(t1, t1_value);
    			}

    			if (!ctx.record.isSingle) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    					transition_in(if_block0, 1);
    				} else {
    					if_block0 = create_if_block_3$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div1, t3);
    				}
    			} else if (if_block0) {
    				group_outros();
    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});
    				check_outros();
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block1) {
    				if_block1.p(changed, ctx);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type(ctx);
    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(div1, t6);
    				}
    			}

    			if (ctx.editingField) {
    				if (if_block2) {
    					if_block2.p(changed, ctx);
    					transition_in(if_block2, 1);
    				} else {
    					if_block2 = create_if_block_1$1(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div1, t7);
    				}
    			} else if (if_block2) {
    				group_outros();
    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});
    				check_outros();
    			}

    			if (changed.record || changed.getIndexAllowedRecords || changed.getIcon) {
    				each_value = ctx.record.indexes;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}

    			if (each_value.length) {
    				if (each_1_else) {
    					each_1_else.d(1);
    					each_1_else = null;
    				}
    			} else if (!each_1_else) {
    				each_1_else = create_else_block$2();
    				each_1_else.c();
    				each_1_else.m(div1, null);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(textbox.$$.fragment, local);

    			transition_in(if_block0);
    			transition_in(if_block2);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(textbox.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block2);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div1);
    			}

    			destroy_component(textbox);

    			if (if_block0) if_block0.d();
    			if_block1.d();
    			if (if_block2) if_block2.d();

    			destroy_each(each_blocks, detaching);

    			if (each_1_else) each_1_else.d();

    			dispose();
    		}
    	};
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let $database;

    	validate_store(database, 'database');
    	subscribe($$self, database, $$value => { $database = $$value; $$invalidate('$database', $database); });

    	

    let record;
    let getIndexAllowedRecords;
    let editingField = false;
    let fieldToEdit;
    let newField;
    let editField;
    let deleteField;
    let onFinishedFieldEdit;
    let editIndex;

    database.subscribe($database => {
        $$invalidate('record', record = $database.currentNode);
        const flattened = hierarchy.getFlattenedHierarchy($database.hierarchy);
        $$invalidate('getIndexAllowedRecords', getIndexAllowedRecords = index => 
            chain(index.allowedRecordNodeIds, [
                fp.filter(id => fp.some(n => n.nodeId === id)(flattened)),
                fp.map(id => fp.find(n => n.nodeId === id)
                              (flattened).name),
                fp.join(", ")
            ]));

        $$invalidate('newField', newField = () => {
            $$invalidate('fieldToEdit', fieldToEdit = templateApi($database.hierarchy).getNewField("string"));
            $$invalidate('editingField', editingField = true);
        });

        $$invalidate('onFinishedFieldEdit', onFinishedFieldEdit = (field) => {
            if(field) {
                database.saveField(field);
            }
            $$invalidate('editingField', editingField = false);
        });

        $$invalidate('editField', editField = (field) => {
            $$invalidate('fieldToEdit', fieldToEdit = field);
            $$invalidate('editingField', editingField = true);
        });

        $$invalidate('deleteField', deleteField = (field) => {
            database.deleteField(field);
        });

        $$invalidate('editIndex', editIndex = index => {
            database.selectExistingNode(index.nodeId);
        });

    });

    let getTypeOptionsValueText = value => {
        if(value === Number.MAX_SAFE_INTEGER
           || value === Number.MIN_SAFE_INTEGER
           || new Date(value).getTime() === new Date(8640000000000000).getTime()
           || new Date(value).getTime() === new Date(-8640000000000000).getTime()) return "(any)";
        
        if(value === null) return "(not set)";
        return value;
    };

    let getTypeOptions = typeOptions => 
        chain(typeOptions, [
            fp.keys,
            fp.map(k => `<span style="color:var(--slate)">${k}: </span>${getTypeOptionsValueText(typeOptions[k])}`),
            fp.join("<br>")
        ]);

    	function textbox_text_binding(value) {
    		record.name = value;
    		$$invalidate('record', record);
    	}

    	function textbox0_text_binding(value) {
    		record.collectionName = value;
    		$$invalidate('record', record);
    	}

    	function textbox1_text_binding(value_1) {
    		record.allidsShardFactor = value_1;
    		$$invalidate('record', record);
    	}

    	function click_handler({ field }) {
    		return editField(field);
    	}

    	function click_handler_1({ field }) {
    		return deleteField(field);
    	}

    	function modal_isOpen_binding(value) {
    		editingField = value;
    		$$invalidate('editingField', editingField);
    	}

    	function click_handler_2({ index }) {
    		return editIndex(index);
    	}

    	return {
    		record,
    		getIndexAllowedRecords,
    		editingField,
    		fieldToEdit,
    		newField,
    		editField,
    		deleteField,
    		onFinishedFieldEdit,
    		editIndex,
    		getTypeOptions,
    		$database,
    		textbox_text_binding,
    		textbox0_text_binding,
    		textbox1_text_binding,
    		click_handler,
    		click_handler_1,
    		modal_isOpen_binding,
    		click_handler_2
    	};
    }

    class RecordView extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, []);
    	}
    }

    /* src\common\CodeArea.svelte generated by Svelte v3.6.9 */

    const file$h = "src\\common\\CodeArea.svelte";

    function create_fragment$g(ctx) {
    	var div, t0, t1, textarea, dispose;

    	return {
    		c: function create() {
    			div = element("div");
    			t0 = text(ctx.label);
    			t1 = space();
    			textarea = element("textarea");
    			add_location(div, file$h, 6, 0, 102);
    			attr(textarea, "class", "svelte-1ooq0hh");
    			add_location(textarea, file$h, 7, 0, 122);
    			dispose = listen(textarea, "input", ctx.textarea_input_handler);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, t0);
    			insert(target, t1, anchor);
    			insert(target, textarea, anchor);

    			textarea.value = ctx.text;
    		},

    		p: function update(changed, ctx) {
    			if (changed.label) {
    				set_data(t0, ctx.label);
    			}

    			if (changed.text) textarea.value = ctx.text;
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    				detach(t1);
    				detach(textarea);
    			}

    			dispose();
    		}
    	};
    }

    function instance$g($$self, $$props, $$invalidate) {
    	// todo: use https://ace.c9.io
    let { text = "", label = "" } = $$props;

    	const writable_props = ['text', 'label'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<CodeArea> was created with unknown prop '${key}'`);
    	});

    	function textarea_input_handler() {
    		text = this.value;
    		$$invalidate('text', text);
    	}

    	$$self.$set = $$props => {
    		if ('text' in $$props) $$invalidate('text', text = $$props.text);
    		if ('label' in $$props) $$invalidate('label', label = $$props.label);
    	};

    	return { text, label, textarea_input_handler };
    }

    class CodeArea extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, ["text", "label"]);
    	}

    	get text() {
    		throw new Error("<CodeArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<CodeArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<CodeArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<CodeArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\database\IndexView.svelte generated by Svelte v3.6.9 */

    const file$i = "src\\database\\IndexView.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.rec = list[i];
    	return child_ctx;
    }

    // (45:8) {#each indexableRecords as rec}
    function create_each_block$5(ctx) {
    	var input, input_checked_value, t0, span, t1_value = ctx.rec.node.name, t1, dispose;

    	function change_handler() {
    		return ctx.change_handler(ctx);
    	}

    	return {
    		c: function create() {
    			input = element("input");
    			t0 = space();
    			span = element("span");
    			t1 = text(t1_value);
    			attr(input, "type", "checkbox");
    			input.checked = input_checked_value = ctx.rec.isallowed;
    			add_location(input, file$i, 45, 8, 1400);
    			attr(span, "class", "svelte-1fkfoam");
    			add_location(span, file$i, 46, 8, 1501);
    			dispose = listen(input, "change", change_handler);
    		},

    		m: function mount(target, anchor) {
    			insert(target, input, anchor);
    			insert(target, t0, anchor);
    			insert(target, span, anchor);
    			append(span, t1);
    		},

    		p: function update(changed, new_ctx) {
    			ctx = new_ctx;
    			if ((changed.indexableRecords) && input_checked_value !== (input_checked_value = ctx.rec.isallowed)) {
    				input.checked = input_checked_value;
    			}

    			if ((changed.indexableRecords) && t1_value !== (t1_value = ctx.rec.node.name)) {
    				set_data(t1, t1_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(input);
    				detach(t0);
    				detach(span);
    			}

    			dispose();
    		}
    	};
    }

    function create_fragment$h(ctx) {
    	var div2, updating_text, t0, div1, div0, t2, t3, updating_selected, t4, updating_text_1, t5, updating_text_2, t6, updating_text_3, current;

    	function textbox_text_binding(value) {
    		ctx.textbox_text_binding.call(null, value);
    		updating_text = true;
    		add_flush_callback(() => updating_text = false);
    	}

    	let textbox_props = { label: "Name" };
    	if (ctx.index.name !== void 0) {
    		textbox_props.text = ctx.index.name;
    	}
    	var textbox = new Textbox({ props: textbox_props, $$inline: true });

    	binding_callbacks.push(() => bind(textbox, 'text', textbox_text_binding));

    	var each_value = ctx.indexableRecords;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	function dropdown_selected_binding(value_1) {
    		ctx.dropdown_selected_binding.call(null, value_1);
    		updating_selected = true;
    		add_flush_callback(() => updating_selected = false);
    	}

    	let dropdown_props = {
    		label: "Index Type",
    		options: ["ancestor", "reference"]
    	};
    	if (ctx.index.indexType !== void 0) {
    		dropdown_props.selected = ctx.index.indexType;
    	}
    	var dropdown = new Dropdown({ props: dropdown_props, $$inline: true });

    	binding_callbacks.push(() => bind(dropdown, 'selected', dropdown_selected_binding));

    	function codearea0_text_binding(value_2) {
    		ctx.codearea0_text_binding.call(null, value_2);
    		updating_text_1 = true;
    		add_flush_callback(() => updating_text_1 = false);
    	}

    	let codearea0_props = { label: "Map (javascript)" };
    	if (ctx.index.map !== void 0) {
    		codearea0_props.text = ctx.index.map;
    	}
    	var codearea0 = new CodeArea({ props: codearea0_props, $$inline: true });

    	binding_callbacks.push(() => bind(codearea0, 'text', codearea0_text_binding));

    	function codearea1_text_binding(value_3) {
    		ctx.codearea1_text_binding.call(null, value_3);
    		updating_text_2 = true;
    		add_flush_callback(() => updating_text_2 = false);
    	}

    	let codearea1_props = { label: "Filter (javascript expression)" };
    	if (ctx.index.filter !== void 0) {
    		codearea1_props.text = ctx.index.filter;
    	}
    	var codearea1 = new CodeArea({ props: codearea1_props, $$inline: true });

    	binding_callbacks.push(() => bind(codearea1, 'text', codearea1_text_binding));

    	function codearea2_text_binding(value_4) {
    		ctx.codearea2_text_binding.call(null, value_4);
    		updating_text_3 = true;
    		add_flush_callback(() => updating_text_3 = false);
    	}

    	let codearea2_props = {
    		label: "Shard Name (javascript expression)"
    	};
    	if (ctx.index.getShardName !== void 0) {
    		codearea2_props.text = ctx.index.getShardName;
    	}
    	var codearea2 = new CodeArea({ props: codearea2_props, $$inline: true });

    	binding_callbacks.push(() => bind(codearea2, 'text', codearea2_text_binding));

    	return {
    		c: function create() {
    			div2 = element("div");
    			textbox.$$.fragment.c();
    			t0 = space();
    			div1 = element("div");
    			div0 = element("div");
    			div0.textContent = "Records to Index";
    			t2 = space();

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t3 = space();
    			dropdown.$$.fragment.c();
    			t4 = space();
    			codearea0.$$.fragment.c();
    			t5 = space();
    			codearea1.$$.fragment.c();
    			t6 = space();
    			codearea2.$$.fragment.c();
    			add_location(div0, file$i, 43, 8, 1322);
    			attr(div1, "class", "allowed-records svelte-1fkfoam");
    			add_location(div1, file$i, 42, 4, 1283);
    			attr(div2, "class", "root svelte-1fkfoam");
    			add_location(div2, file$i, 39, 0, 1201);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div2, anchor);
    			mount_component(textbox, div2, null);
    			append(div2, t0);
    			append(div2, div1);
    			append(div1, div0);
    			append(div1, t2);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append(div2, t3);
    			mount_component(dropdown, div2, null);
    			append(div2, t4);
    			mount_component(codearea0, div2, null);
    			append(div2, t5);
    			mount_component(codearea1, div2, null);
    			append(div2, t6);
    			mount_component(codearea2, div2, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var textbox_changes = {};
    			if (!updating_text && changed.index) {
    				textbox_changes.text = ctx.index.name;
    			}
    			textbox.$set(textbox_changes);

    			if (changed.indexableRecords) {
    				each_value = ctx.indexableRecords;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}

    			var dropdown_changes = {};
    			if (!updating_selected && changed.index) {
    				dropdown_changes.selected = ctx.index.indexType;
    			}
    			dropdown.$set(dropdown_changes);

    			var codearea0_changes = {};
    			if (!updating_text_1 && changed.index) {
    				codearea0_changes.text = ctx.index.map;
    			}
    			codearea0.$set(codearea0_changes);

    			var codearea1_changes = {};
    			if (!updating_text_2 && changed.index) {
    				codearea1_changes.text = ctx.index.filter;
    			}
    			codearea1.$set(codearea1_changes);

    			var codearea2_changes = {};
    			if (!updating_text_3 && changed.index) {
    				codearea2_changes.text = ctx.index.getShardName;
    			}
    			codearea2.$set(codearea2_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(textbox.$$.fragment, local);

    			transition_in(dropdown.$$.fragment, local);

    			transition_in(codearea0.$$.fragment, local);

    			transition_in(codearea1.$$.fragment, local);

    			transition_in(codearea2.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(textbox.$$.fragment, local);
    			transition_out(dropdown.$$.fragment, local);
    			transition_out(codearea0.$$.fragment, local);
    			transition_out(codearea1.$$.fragment, local);
    			transition_out(codearea2.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div2);
    			}

    			destroy_component(textbox);

    			destroy_each(each_blocks, detaching);

    			destroy_component(dropdown);

    			destroy_component(codearea0);

    			destroy_component(codearea1);

    			destroy_component(codearea2);
    		}
    	};
    }

    function instance$h($$self, $$props, $$invalidate) {
    	

    const chain = index.$;

    let index$1;
    let indexableRecords = [];

    database.subscribe($database => {
        $$invalidate('index', index$1 = $database.currentNode);
        $$invalidate('indexableRecords', indexableRecords = chain($database.hierarchy,[
            hierarchy.getFlattenedHierarchy,
            fp.filter(hierarchy.isDecendant(index$1.parent())),
            fp.filter(hierarchy.isRecord),
            fp.map(n => ({
                node:n,
                isallowed: fp.some(id => n.nodeId === id)(index$1.allowedRecordNodeIds)
            }))
        ]));
    });

    const toggleAllowedRecord = record => {
        if(record.isallowed) {
            index$1.allowedRecordNodeIds = fp.filter(id => id !== record.node.nodeId)
                                               (index$1.allowedRecordNodeIds); $$invalidate('index', index$1);
        } else {
            index$1.allowedRecordNodeIds.push(record.node.nodeId);
        }
    };

    	function textbox_text_binding(value) {
    		index$1.name = value;
    		$$invalidate('index', index$1);
    	}

    	function change_handler({ rec }) {
    		return toggleAllowedRecord(rec);
    	}

    	function dropdown_selected_binding(value_1) {
    		index$1.indexType = value_1;
    		$$invalidate('index', index$1);
    	}

    	function codearea0_text_binding(value_2) {
    		index$1.map = value_2;
    		$$invalidate('index', index$1);
    	}

    	function codearea1_text_binding(value_3) {
    		index$1.filter = value_3;
    		$$invalidate('index', index$1);
    	}

    	function codearea2_text_binding(value_4) {
    		index$1.getShardName = value_4;
    		$$invalidate('index', index$1);
    	}

    	return {
    		index: index$1,
    		indexableRecords,
    		toggleAllowedRecord,
    		textbox_text_binding,
    		change_handler,
    		dropdown_selected_binding,
    		codearea0_text_binding,
    		codearea1_text_binding,
    		codearea2_text_binding
    	};
    }

    class IndexView extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, []);
    	}
    }

    /* src\database\ActionsHeader.svelte generated by Svelte v3.6.9 */

    const file$j = "src\\database\\ActionsHeader.svelte";

    // (27:12) {:else}
    function create_else_block$3(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Update");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (25:12) {#if $database.currentNodeIsNew}
    function create_if_block_2$2(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Create");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (24:8) <Button color="secondary" grouped on:click={database.saveCurrentNode}>
    function create_default_slot_5(ctx) {
    	var if_block_anchor;

    	function select_block_type(ctx) {
    		if (ctx.$database.currentNodeIsNew) return create_if_block_2$2;
    		return create_else_block$3;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);
    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},

    		d: function destroy(detaching) {
    			if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    // (32:8) {#if !$database.currentNodeIsNew}
    function create_if_block_1$2(ctx) {
    	var current;

    	var button = new Button({
    		props: {
    		color: "secondary",
    		grouped: true,
    		$$slots: { default: [create_default_slot_4] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});
    	button.$on("click", ctx.openConfirmDelete);

    	return {
    		c: function create() {
    			button.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};
    }

    // (33:8) <Button color="secondary" grouped on:click={openConfirmDelete}>
    function create_default_slot_4(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Delete");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (23:4) <ButtonGroup>
    function create_default_slot_3(ctx) {
    	var t, if_block_anchor, current;

    	var button = new Button({
    		props: {
    		color: "secondary",
    		grouped: true,
    		$$slots: { default: [create_default_slot_5] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});
    	button.$on("click", database.saveCurrentNode);

    	var if_block = (!ctx.$database.currentNodeIsNew) && create_if_block_1$2(ctx);

    	return {
    		c: function create() {
    			button.$$.fragment.c();
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			insert(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var button_changes = {};
    			if (changed.$$scope || changed.$database) button_changes.$$scope = { changed, ctx };
    			button.$set(button_changes);

    			if (!ctx.$database.currentNodeIsNew) {
    				if (!if_block) {
    					if_block = create_if_block_1$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    									transition_in(if_block, 1);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);

    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(button, detaching);

    			if (detaching) {
    				detach(t);
    			}

    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    // (39:4) {#if !!$database.errors && $database.errors.length > 0}
    function create_if_block$5(ctx) {
    	var div, current;

    	var errorsbox = new ErrorsBox({
    		props: { errors: ctx.$database.errors },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			div = element("div");
    			errorsbox.$$.fragment.c();
    			set_style(div, "width", "500px");
    			add_location(div, file$j, 39, 4, 1032);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			mount_component(errorsbox, div, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var errorsbox_changes = {};
    			if (changed.$database) errorsbox_changes.errors = ctx.$database.errors;
    			errorsbox.$set(errorsbox_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(errorsbox.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(errorsbox.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			destroy_component(errorsbox);
    		}
    	};
    }

    // (48:12) <Button color="primary"  on:click={deleteCurrentNode}>
    function create_default_slot_2$1(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Yes");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (49:12) <Button color="secondary" on:click={() => confirmDelete = false}>
    function create_default_slot_1$1(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("No");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (45:4) <Modal bind:isOpen={confirmDelete}>
    function create_default_slot$2(ctx) {
    	var div0, t0, t1_value = ctx.$database.currentNode.name, t1, t2, t3, div1, t4, current;

    	var button0 = new Button({
    		props: {
    		color: "primary",
    		$$slots: { default: [create_default_slot_2$1] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});
    	button0.$on("click", ctx.deleteCurrentNode);

    	var button1 = new Button({
    		props: {
    		color: "secondary",
    		$$slots: { default: [create_default_slot_1$1] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});
    	button1.$on("click", ctx.click_handler);

    	return {
    		c: function create() {
    			div0 = element("div");
    			t0 = text("Are you sure you want to delete ");
    			t1 = text(t1_value);
    			t2 = text(" ?");
    			t3 = space();
    			div1 = element("div");
    			button0.$$.fragment.c();
    			t4 = space();
    			button1.$$.fragment.c();
    			set_style(div0, "margin", "10px 0px 20px 0px");
    			add_location(div0, file$j, 45, 8, 1186);
    			set_style(div1, "float", "right");
    			add_location(div1, file$j, 46, 8, 1303);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div0, anchor);
    			append(div0, t0);
    			append(div0, t1);
    			append(div0, t2);
    			insert(target, t3, anchor);
    			insert(target, div1, anchor);
    			mount_component(button0, div1, null);
    			append(div1, t4);
    			mount_component(button1, div1, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.$database) && t1_value !== (t1_value = ctx.$database.currentNode.name)) {
    				set_data(t1, t1_value);
    			}

    			var button0_changes = {};
    			if (changed.$$scope) button0_changes.$$scope = { changed, ctx };
    			button0.$set(button0_changes);

    			var button1_changes = {};
    			if (changed.$$scope) button1_changes.$$scope = { changed, ctx };
    			button1.$set(button1_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);

    			transition_in(button1.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div0);
    				detach(t3);
    				detach(div1);
    			}

    			destroy_component(button0);

    			destroy_component(button1);
    		}
    	};
    }

    function create_fragment$i(ctx) {
    	var div, t0, t1, updating_isOpen, current;

    	var buttongroup = new ButtonGroup({
    		props: {
    		$$slots: { default: [create_default_slot_3] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});

    	var if_block = (!!ctx.$database.errors && ctx.$database.errors.length > 0) && create_if_block$5(ctx);

    	function modal_isOpen_binding(value) {
    		ctx.modal_isOpen_binding.call(null, value);
    		updating_isOpen = true;
    		add_flush_callback(() => updating_isOpen = false);
    	}

    	let modal_props = {
    		$$slots: { default: [create_default_slot$2] },
    		$$scope: { ctx }
    	};
    	if (ctx.confirmDelete !== void 0) {
    		modal_props.isOpen = ctx.confirmDelete;
    	}
    	var modal = new Modal({ props: modal_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal, 'isOpen', modal_isOpen_binding));

    	return {
    		c: function create() {
    			div = element("div");
    			buttongroup.$$.fragment.c();
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			modal.$$.fragment.c();
    			attr(div, "class", "root svelte-160njkp");
    			set_style(div, "left", ctx.left);
    			add_location(div, file$j, 20, 0, 486);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			mount_component(buttongroup, div, null);
    			append(div, t0);
    			if (if_block) if_block.m(div, null);
    			append(div, t1);
    			mount_component(modal, div, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var buttongroup_changes = {};
    			if (changed.$$scope || changed.$database) buttongroup_changes.$$scope = { changed, ctx };
    			buttongroup.$set(buttongroup_changes);

    			if (!!ctx.$database.errors && ctx.$database.errors.length > 0) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$5(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, t1);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}

    			var modal_changes = {};
    			if (changed.$$scope || changed.$database) modal_changes.$$scope = { changed, ctx };
    			if (!updating_isOpen && changed.confirmDelete) {
    				modal_changes.isOpen = ctx.confirmDelete;
    			}
    			modal.$set(modal_changes);

    			if (!current || changed.left) {
    				set_style(div, "left", ctx.left);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(buttongroup.$$.fragment, local);

    			transition_in(if_block);

    			transition_in(modal.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(buttongroup.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			destroy_component(buttongroup);

    			if (if_block) if_block.d();

    			destroy_component(modal);
    		}
    	};
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let $database;

    	validate_store(database, 'database');
    	subscribe($$self, database, $$value => { $database = $$value; $$invalidate('$database', $database); });

    	

    let { left } = $$props;
    let confirmDelete = false;
    const openConfirmDelete = () => {
        $$invalidate('confirmDelete', confirmDelete = true);
    };

    const deleteCurrentNode = () => {
        $$invalidate('confirmDelete', confirmDelete = false);
        database.deleteCurrentNode();
    };

    	const writable_props = ['left'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<ActionsHeader> was created with unknown prop '${key}'`);
    	});

    	function click_handler() {
    		const $$result = confirmDelete = false;
    		$$invalidate('confirmDelete', confirmDelete);
    		return $$result;
    	}

    	function modal_isOpen_binding(value) {
    		confirmDelete = value;
    		$$invalidate('confirmDelete', confirmDelete);
    	}

    	$$self.$set = $$props => {
    		if ('left' in $$props) $$invalidate('left', left = $$props.left);
    	};

    	return {
    		left,
    		confirmDelete,
    		openConfirmDelete,
    		deleteCurrentNode,
    		$database,
    		click_handler,
    		modal_isOpen_binding
    	};
    }

    class ActionsHeader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, ["left"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.left === undefined && !('left' in props)) {
    			console.warn("<ActionsHeader> was created without expected prop 'left'");
    		}
    	}

    	get left() {
    		throw new Error("<ActionsHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set left(value) {
    		throw new Error("<ActionsHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\common\DropdownButton.svelte generated by Svelte v3.6.9 */

    const file$k = "src\\common\\DropdownButton.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.action = list[i];
    	return child_ctx;
    }

    // (17:8) {#each actions as action}
    function create_each_block$6(ctx) {
    	var div, t0_value = ctx.action.label, t0, t1, dispose;

    	return {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			attr(div, "class", "action-row svelte-179p8ge");
    			add_location(div, file$k, 17, 8, 586);
    			dispose = listen(div, "click", ctx.action.onclick);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, t0);
    			append(div, t1);
    		},

    		p: function update(changed, new_ctx) {
    			ctx = new_ctx;
    			if ((changed.actions) && t0_value !== (t0_value = ctx.action.label)) {
    				set_data(t0, t0_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			dispose();
    		}
    	};
    }

    function create_fragment$j(ctx) {
    	var div2, raw_value = getIcon(ctx.iconName), raw_after, t0, div0, t1, div1, dispose;

    	var each_value = ctx.actions;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			div2 = element("div");
    			raw_after = element('noscript');
    			t0 = space();
    			div0 = element("div");
    			t1 = space();
    			div1 = element("div");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			attr(div0, "class", "dropdown-background svelte-179p8ge");
    			set_style(div0, "display", (ctx.isDroppedDown ? 'block' : 'none'));
    			add_location(div0, file$k, 13, 4, 298);
    			attr(div1, "class", "dropdown-content svelte-179p8ge");
    			set_style(div1, "display", (ctx.isDroppedDown ? 'inline-block' : 'none'));
    			add_location(div1, file$k, 15, 4, 452);
    			attr(div2, "class", "root svelte-179p8ge");
    			add_location(div2, file$k, 10, 0, 189);

    			dispose = [
    				listen(div0, "click", stop_propagation(ctx.click_handler)),
    				listen(div2, "click", ctx.click_handler_1)
    			];
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div2, anchor);
    			append(div2, raw_after);
    			raw_after.insertAdjacentHTML("beforebegin", raw_value);
    			append(div2, t0);
    			append(div2, div0);
    			append(div2, t1);
    			append(div2, div1);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if ((changed.iconName) && raw_value !== (raw_value = getIcon(ctx.iconName))) {
    				detach_before(raw_after);
    				raw_after.insertAdjacentHTML("beforebegin", raw_value);
    			}

    			if (changed.isDroppedDown) {
    				set_style(div0, "display", (ctx.isDroppedDown ? 'block' : 'none'));
    			}

    			if (changed.actions) {
    				each_value = ctx.actions;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}

    			if (changed.isDroppedDown) {
    				set_style(div1, "display", (ctx.isDroppedDown ? 'inline-block' : 'none'));
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div2);
    			}

    			destroy_each(each_blocks, detaching);

    			run_all(dispose);
    		}
    	};
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let { iconName, actions = [] } = $$props; // [ {label: "Action Name", onclick: () => {...} } ]
    let isDroppedDown = false;

    	const writable_props = ['iconName', 'actions'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<DropdownButton> was created with unknown prop '${key}'`);
    	});

    	function click_handler() {
    		const $$result = isDroppedDown = false;
    		$$invalidate('isDroppedDown', isDroppedDown);
    		return $$result;
    	}

    	function click_handler_1() {
    		const $$result = isDroppedDown = !isDroppedDown;
    		$$invalidate('isDroppedDown', isDroppedDown);
    		return $$result;
    	}

    	$$self.$set = $$props => {
    		if ('iconName' in $$props) $$invalidate('iconName', iconName = $$props.iconName);
    		if ('actions' in $$props) $$invalidate('actions', actions = $$props.actions);
    	};

    	return {
    		iconName,
    		actions,
    		isDroppedDown,
    		click_handler,
    		click_handler_1
    	};
    }

    class DropdownButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, ["iconName", "actions"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.iconName === undefined && !('iconName' in props)) {
    			console.warn("<DropdownButton> was created without expected prop 'iconName'");
    		}
    	}

    	get iconName() {
    		throw new Error("<DropdownButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconName(value) {
    		throw new Error("<DropdownButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get actions() {
    		throw new Error("<DropdownButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set actions(value) {
    		throw new Error("<DropdownButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\database\DatabaseRoot.svelte generated by Svelte v3.6.9 */

    const file$l = "src\\database\\DatabaseRoot.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.index = list[i];
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.record = list[i];
    	return child_ctx;
    }

    // (55:8) {#each $database.hierarchy.children as record}
    function create_each_block_1$2(ctx) {
    	var current;

    	var hierarchyrow = new HierarchyRow({
    		props: { node: ctx.record },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			hierarchyrow.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(hierarchyrow, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var hierarchyrow_changes = {};
    			if (changed.$database) hierarchyrow_changes.node = ctx.record;
    			hierarchyrow.$set(hierarchyrow_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(hierarchyrow.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(hierarchyrow.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(hierarchyrow, detaching);
    		}
    	};
    }

    // (63:8) {#each $database.hierarchy.indexes as index}
    function create_each_block$7(ctx) {
    	var current;

    	var hierarchyrow = new HierarchyRow({
    		props: { node: ctx.index },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			hierarchyrow.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(hierarchyrow, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var hierarchyrow_changes = {};
    			if (changed.$database) hierarchyrow_changes.node = ctx.index;
    			hierarchyrow.$set(hierarchyrow_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(hierarchyrow.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(hierarchyrow.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(hierarchyrow, detaching);
    		}
    	};
    }

    // (69:12) {#if $database.currentNode}
    function create_if_block_2$3(ctx) {
    	var current;

    	var actionsheader = new ActionsHeader({
    		props: { left: hierarchyWidth },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			actionsheader.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(actionsheader, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var actionsheader_changes = {};
    			if (changed.hierarchyWidth) actionsheader_changes.left = hierarchyWidth;
    			actionsheader.$set(actionsheader_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(actionsheader.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(actionsheader.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(actionsheader, detaching);
    		}
    	};
    }

    // (78:12) {:else}
    function create_else_block$4(ctx) {
    	var current;

    	var indexview = new IndexView({ $$inline: true });

    	return {
    		c: function create() {
    			indexview.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(indexview, target, anchor);
    			current = true;
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(indexview.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(indexview.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(indexview, detaching);
    		}
    	};
    }

    // (76:62) 
    function create_if_block_1$3(ctx) {
    	var current;

    	var recordview = new RecordView({ $$inline: true });

    	return {
    		c: function create() {
    			recordview.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(recordview, target, anchor);
    			current = true;
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(recordview.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(recordview.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(recordview, detaching);
    		}
    	};
    }

    // (74:12) {#if !$database.currentNode}
    function create_if_block$6(ctx) {
    	var h1;

    	return {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = ":)";
    			set_style(h1, "margin-left", "100px");
    			add_location(h1, file$l, 74, 12, 2417);
    		},

    		m: function mount(target, anchor) {
    			insert(target, h1, anchor);
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h1);
    			}
    		}
    	};
    }

    function create_fragment$k(ctx) {
    	var div8, div4, div1, div0, t1, t2, t3, div3, div2, t5, t6, t7, div7, div5, t8, div6, current_block_type_index, if_block1, current;

    	var dropdownbutton0 = new DropdownButton({
    		props: { iconName: "plus", actions: ctx.newRecordActions },
    		$$inline: true
    	});

    	var each_value_1 = ctx.$database.hierarchy.children;

    	var each_blocks_1 = [];

    	for (var i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
    		each_blocks_1[i] = null;
    	});

    	var dropdownbutton1 = new DropdownButton({
    		props: { iconName: "plus", actions: ctx.newIndexActions },
    		$$inline: true
    	});

    	var each_value = ctx.$database.hierarchy.indexes;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const out_1 = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	var if_block0 = (ctx.$database.currentNode) && create_if_block_2$3();

    	var if_block_creators = [
    		create_if_block$6,
    		create_if_block_1$3,
    		create_else_block$4
    	];

    	var if_blocks = [];

    	function select_block_type(ctx) {
    		if (!ctx.$database.currentNode) return 0;
    		if (ctx.$database.currentNode.type === "record") return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	return {
    		c: function create() {
    			div8 = element("div");
    			div4 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			div0.textContent = "Records";
    			t1 = space();
    			dropdownbutton0.$$.fragment.c();
    			t2 = space();

    			for (var i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t3 = space();
    			div3 = element("div");
    			div2 = element("div");
    			div2.textContent = "Indexes";
    			t5 = space();
    			dropdownbutton1.$$.fragment.c();
    			t6 = space();

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t7 = space();
    			div7 = element("div");
    			div5 = element("div");
    			if (if_block0) if_block0.c();
    			t8 = space();
    			div6 = element("div");
    			if_block1.c();
    			attr(div0, "class", "hierarchy-title svelte-z7gm0t");
    			add_location(div0, file$l, 51, 12, 1544);
    			attr(div1, "class", "hierarchy-title-row svelte-z7gm0t");
    			add_location(div1, file$l, 50, 8, 1497);
    			attr(div2, "class", "hierarchy-title svelte-z7gm0t");
    			add_location(div2, file$l, 59, 12, 1874);
    			attr(div3, "class", "hierarchy-title-row svelte-z7gm0t");
    			set_style(div3, "margin-top", "20px");
    			add_location(div3, file$l, 58, 8, 1802);
    			attr(div4, "class", "hierarchy svelte-z7gm0t");
    			set_style(div4, "width", hierarchyWidth);
    			add_location(div4, file$l, 49, 4, 1432);
    			attr(div5, "class", "actions-header svelte-z7gm0t");
    			add_location(div5, file$l, 67, 8, 2172);
    			attr(div6, "class", "node-view svelte-z7gm0t");
    			add_location(div6, file$l, 72, 8, 2338);
    			attr(div7, "class", "node-container svelte-z7gm0t");
    			add_location(div7, file$l, 66, 4, 2134);
    			attr(div8, "class", "root svelte-z7gm0t");
    			add_location(div8, file$l, 48, 0, 1408);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div8, anchor);
    			append(div8, div4);
    			append(div4, div1);
    			append(div1, div0);
    			append(div1, t1);
    			mount_component(dropdownbutton0, div1, null);
    			append(div4, t2);

    			for (var i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div4, null);
    			}

    			append(div4, t3);
    			append(div4, div3);
    			append(div3, div2);
    			append(div3, t5);
    			mount_component(dropdownbutton1, div3, null);
    			append(div4, t6);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div4, null);
    			}

    			append(div8, t7);
    			append(div8, div7);
    			append(div7, div5);
    			if (if_block0) if_block0.m(div5, null);
    			append(div7, t8);
    			append(div7, div6);
    			if_blocks[current_block_type_index].m(div6, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var dropdownbutton0_changes = {};
    			if (changed.newRecordActions) dropdownbutton0_changes.actions = ctx.newRecordActions;
    			dropdownbutton0.$set(dropdownbutton0_changes);

    			if (changed.$database) {
    				each_value_1 = ctx.$database.hierarchy.children;

    				for (var i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(changed, child_ctx);
    						transition_in(each_blocks_1[i], 1);
    					} else {
    						each_blocks_1[i] = create_each_block_1$2(child_ctx);
    						each_blocks_1[i].c();
    						transition_in(each_blocks_1[i], 1);
    						each_blocks_1[i].m(div4, t3);
    					}
    				}

    				group_outros();
    				for (i = each_value_1.length; i < each_blocks_1.length; i += 1) out(i);
    				check_outros();
    			}

    			var dropdownbutton1_changes = {};
    			if (changed.newIndexActions) dropdownbutton1_changes.actions = ctx.newIndexActions;
    			dropdownbutton1.$set(dropdownbutton1_changes);

    			if (changed.$database) {
    				each_value = ctx.$database.hierarchy.indexes;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div4, null);
    					}
    				}

    				group_outros();
    				for (i = each_value.length; i < each_blocks.length; i += 1) out_1(i);
    				check_outros();
    			}

    			if (!current || changed.hierarchyWidth) {
    				set_style(div4, "width", hierarchyWidth);
    			}

    			if (ctx.$database.currentNode) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    					transition_in(if_block0, 1);
    				} else {
    					if_block0 = create_if_block_2$3();
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div5, null);
    				}
    			} else if (if_block0) {
    				group_outros();
    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});
    				check_outros();
    			}

    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);
    			if (current_block_type_index !== previous_block_index) {
    				group_outros();
    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});
    				check_outros();

    				if_block1 = if_blocks[current_block_type_index];
    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}
    				transition_in(if_block1, 1);
    				if_block1.m(div6, null);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdownbutton0.$$.fragment, local);

    			for (var i = 0; i < each_value_1.length; i += 1) transition_in(each_blocks_1[i]);

    			transition_in(dropdownbutton1.$$.fragment, local);

    			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(dropdownbutton0.$$.fragment, local);

    			each_blocks_1 = each_blocks_1.filter(Boolean);
    			for (let i = 0; i < each_blocks_1.length; i += 1) transition_out(each_blocks_1[i]);

    			transition_out(dropdownbutton1.$$.fragment, local);

    			each_blocks = each_blocks.filter(Boolean);
    			for (let i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div8);
    			}

    			destroy_component(dropdownbutton0);

    			destroy_each(each_blocks_1, detaching);

    			destroy_component(dropdownbutton1);

    			destroy_each(each_blocks, detaching);

    			if (if_block0) if_block0.d();
    			if_blocks[current_block_type_index].d();
    		}
    	};
    }

    const hierarchyWidth = "200px";

    function instance$k($$self, $$props, $$invalidate) {
    	let $database;

    	validate_store(database, 'database');
    	subscribe($$self, database, $$value => { $database = $$value; $$invalidate('$database', $database); });

    	

    const defaultNewIndexActions =  [{
        label:"New Root Index", 
        onclick: database.newRootIndex
    }];

    const defaultNewRecordActions = [{
        label:"New Root Record", 
        onclick: database.newRootRecord
    }];

    let newIndexActions = defaultNewIndexActions;
    let newRecordActions = defaultNewRecordActions;

    database.subscribe(db => {
        if(!db.currentNode || hierarchy.isIndex(db.currentNode)) {
            $$invalidate('newRecordActions', newRecordActions = defaultNewRecordActions);
            $$invalidate('newIndexActions', newIndexActions = defaultNewIndexActions);
        } else {
            $$invalidate('newRecordActions', newRecordActions = [
                ...defaultNewRecordActions,
                {label: `New Child Record of ${db.currentNode.name}`, 
                onclick: database.newChildRecord}
            ]);

            $$invalidate('newIndexActions', newIndexActions = [
                ...defaultNewIndexActions,
                {label: `New Index on ${db.currentNode.name}`, 
                onclick: database.newChildIndex}
            ]);
        }
    });

    	return {
    		newIndexActions,
    		newRecordActions,
    		$database
    	};
    }

    class DatabaseRoot extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, []);
    	}
    }

    /* src\userInterface\UserInterfaceRoot.svelte generated by Svelte v3.6.9 */

    const file$m = "src\\userInterface\\UserInterfaceRoot.svelte";

    function create_fragment$l(ctx) {
    	var div2, div0, t, div1;

    	return {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t = space();
    			div1 = element("div");
    			attr(div0, "class", "ui-nav svelte-1bhe8g7");
    			add_location(div0, file$m, 8, 4, 112);
    			attr(div1, "class", "component-preview svelte-1bhe8g7");
    			add_location(div1, file$m, 12, 4, 158);
    			attr(div2, "class", "root svelte-1bhe8g7");
    			add_location(div2, file$m, 6, 0, 82);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div2, anchor);
    			append(div2, div0);
    			append(div2, t);
    			append(div2, div1);
    		},

    		p: noop,
    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div2);
    			}
    		}
    	};
    }

    class UserInterfaceRoot extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, null, create_fragment$l, safe_not_equal, []);
    	}
    }

    /* src\actionsAndTriggers\ActionView.svelte generated by Svelte v3.6.9 */

    const file$n = "src\\actionsAndTriggers\\ActionView.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.option = list[i];
    	return child_ctx;
    }

    // (83:12) <Button color="primary-outline uk-width-1-4" on:click={addNewOption}>
    function create_default_slot_3$1(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Add");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (86:12) {#each initialOptions as option}
    function create_each_block$8(ctx) {
    	var span1, t0_value = ctx.option.key, t0, t1, t2_value = ctx.option.value, t2, t3, span0, raw_value = getIcon("trash-2"), dispose;

    	function click_handler() {
    		return ctx.click_handler(ctx);
    	}

    	return {
    		c: function create() {
    			span1 = element("span");
    			t0 = text(t0_value);
    			t1 = text(" : ");
    			t2 = text(t2_value);
    			t3 = space();
    			span0 = element("span");
    			set_style(span0, "font-size", "10pt");
    			set_style(span0, "cursor", "pointer");
    			add_location(span0, file$n, 86, 73, 2561);
    			attr(span1, "class", "option-container svelte-emcy8y");
    			add_location(span1, file$n, 86, 12, 2500);
    			dispose = listen(span0, "click", click_handler);
    		},

    		m: function mount(target, anchor) {
    			insert(target, span1, anchor);
    			append(span1, t0);
    			append(span1, t1);
    			append(span1, t2);
    			append(span1, t3);
    			append(span1, span0);
    			span0.innerHTML = raw_value;
    		},

    		p: function update(changed, new_ctx) {
    			ctx = new_ctx;
    			if ((changed.initialOptions) && t0_value !== (t0_value = ctx.option.key)) {
    				set_data(t0, t0_value);
    			}

    			if ((changed.initialOptions) && t2_value !== (t2_value = ctx.option.value)) {
    				set_data(t2, t2_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(span1);
    			}

    			dispose();
    		}
    	};
    }

    // (93:8) <Button color="primary" grouped on:click={save}>
    function create_default_slot_2$2(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Save");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (94:8) <Button color="secondary" grouped on:click={cancel}>
    function create_default_slot_1$2(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Cancel");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (92:4) <ButtonGroup>
    function create_default_slot$3(ctx) {
    	var t, current;

    	var button0 = new Button({
    		props: {
    		color: "primary",
    		grouped: true,
    		$$slots: { default: [create_default_slot_2$2] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});
    	button0.$on("click", ctx.save);

    	var button1 = new Button({
    		props: {
    		color: "secondary",
    		grouped: true,
    		$$slots: { default: [create_default_slot_1$2] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});
    	button1.$on("click", ctx.cancel);

    	return {
    		c: function create() {
    			button0.$$.fragment.c();
    			t = space();
    			button1.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert(target, t, anchor);
    			mount_component(button1, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var button0_changes = {};
    			if (changed.$$scope) button0_changes.$$scope = { changed, ctx };
    			button0.$set(button0_changes);

    			var button1_changes = {};
    			if (changed.$$scope) button1_changes.$$scope = { changed, ctx };
    			button1.$set(button1_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);

    			transition_in(button1.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);

    			if (detaching) {
    				detach(t);
    			}

    			destroy_component(button1, detaching);
    		}
    	};
    }

    function create_fragment$m(ctx) {
    	var div3, t0, updating_text, t1, updating_text_1, t2, updating_text_2, t3, div2, label, t5, div0, input0, t6, input1, t7, t8, div1, t9, current, dispose;

    	var errorsbox = new ErrorsBox({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	function textbox0_text_binding(value) {
    		ctx.textbox0_text_binding.call(null, value);
    		updating_text = true;
    		add_flush_callback(() => updating_text = false);
    	}

    	let textbox0_props = { label: "Name" };
    	if (ctx.clonedAction.name !== void 0) {
    		textbox0_props.text = ctx.clonedAction.name;
    	}
    	var textbox0 = new Textbox({ props: textbox0_props, $$inline: true });

    	binding_callbacks.push(() => bind(textbox0, 'text', textbox0_text_binding));

    	function textbox1_text_binding(value_1) {
    		ctx.textbox1_text_binding.call(null, value_1);
    		updating_text_1 = true;
    		add_flush_callback(() => updating_text_1 = false);
    	}

    	let textbox1_props = { label: "Behaviour Source" };
    	if (ctx.clonedAction.behaviourSource !== void 0) {
    		textbox1_props.text = ctx.clonedAction.behaviourSource;
    	}
    	var textbox1 = new Textbox({ props: textbox1_props, $$inline: true });

    	binding_callbacks.push(() => bind(textbox1, 'text', textbox1_text_binding));

    	function textbox2_text_binding(value_2) {
    		ctx.textbox2_text_binding.call(null, value_2);
    		updating_text_2 = true;
    		add_flush_callback(() => updating_text_2 = false);
    	}

    	let textbox2_props = { label: "Behaviour" };
    	if (ctx.clonedAction.behaviourName !== void 0) {
    		textbox2_props.text = ctx.clonedAction.behaviourName;
    	}
    	var textbox2 = new Textbox({ props: textbox2_props, $$inline: true });

    	binding_callbacks.push(() => bind(textbox2, 'text', textbox2_text_binding));

    	var button = new Button({
    		props: {
    		color: "primary-outline uk-width-1-4",
    		$$slots: { default: [create_default_slot_3$1] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});
    	button.$on("click", ctx.addNewOption);

    	var each_value = ctx.initialOptions;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	var buttongroup = new ButtonGroup({
    		props: {
    		$$slots: { default: [create_default_slot$3] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			div3 = element("div");
    			errorsbox.$$.fragment.c();
    			t0 = space();
    			textbox0.$$.fragment.c();
    			t1 = space();
    			textbox1.$$.fragment.c();
    			t2 = space();
    			textbox2.$$.fragment.c();
    			t3 = space();
    			div2 = element("div");
    			label = element("label");
    			label.textContent = "Default Options";
    			t5 = space();
    			div0 = element("div");
    			input0 = element("input");
    			t6 = space();
    			input1 = element("input");
    			t7 = space();
    			button.$$.fragment.c();
    			t8 = space();
    			div1 = element("div");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t9 = space();
    			buttongroup.$$.fragment.c();
    			attr(label, "class", "uk-form-label");
    			add_location(label, file$n, 78, 8, 1992);
    			attr(input0, "class", "uk-input uk-width-1-4");
    			attr(input0, "placeholder", "key");
    			add_location(input0, file$n, 80, 12, 2103);
    			attr(input1, "class", "uk-input uk-width-1-4");
    			attr(input1, "placeholder", "value");
    			add_location(input1, file$n, 81, 12, 2201);
    			attr(div0, "class", "uk-grid-small");
    			attr(div0, "uk-grid", "");
    			add_location(div0, file$n, 79, 8, 2054);
    			set_style(div1, "margin-top", "10px");
    			add_location(div1, file$n, 84, 8, 2410);
    			attr(div2, "class", " uk-form-stacked");
    			set_style(div2, "margin-bottom", "20px");
    			add_location(div2, file$n, 77, 4, 1924);
    			attr(div3, "class", "root svelte-emcy8y");
    			add_location(div3, file$n, 68, 0, 1647);

    			dispose = [
    				listen(input0, "input", ctx.input0_input_handler),
    				listen(input1, "input", ctx.input1_input_handler)
    			];
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div3, anchor);
    			mount_component(errorsbox, div3, null);
    			append(div3, t0);
    			mount_component(textbox0, div3, null);
    			append(div3, t1);
    			mount_component(textbox1, div3, null);
    			append(div3, t2);
    			mount_component(textbox2, div3, null);
    			append(div3, t3);
    			append(div3, div2);
    			append(div2, label);
    			append(div2, t5);
    			append(div2, div0);
    			append(div0, input0);

    			input0.value = ctx.optKey;

    			append(div0, t6);
    			append(div0, input1);

    			input1.value = ctx.optValue;

    			append(div0, t7);
    			mount_component(button, div0, null);
    			append(div2, t8);
    			append(div2, div1);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append(div3, t9);
    			mount_component(buttongroup, div3, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var errorsbox_changes = {};
    			if (changed.errors) errorsbox_changes.errors = ctx.errors;
    			errorsbox.$set(errorsbox_changes);

    			var textbox0_changes = {};
    			if (!updating_text && changed.clonedAction) {
    				textbox0_changes.text = ctx.clonedAction.name;
    			}
    			textbox0.$set(textbox0_changes);

    			var textbox1_changes = {};
    			if (!updating_text_1 && changed.clonedAction) {
    				textbox1_changes.text = ctx.clonedAction.behaviourSource;
    			}
    			textbox1.$set(textbox1_changes);

    			var textbox2_changes = {};
    			if (!updating_text_2 && changed.clonedAction) {
    				textbox2_changes.text = ctx.clonedAction.behaviourName;
    			}
    			textbox2.$set(textbox2_changes);

    			if (changed.optKey && (input0.value !== ctx.optKey)) input0.value = ctx.optKey;
    			if (changed.optValue && (input1.value !== ctx.optValue)) input1.value = ctx.optValue;

    			var button_changes = {};
    			if (changed.$$scope) button_changes.$$scope = { changed, ctx };
    			button.$set(button_changes);

    			if (changed.getIcon || changed.initialOptions) {
    				each_value = ctx.initialOptions;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}

    			var buttongroup_changes = {};
    			if (changed.$$scope) buttongroup_changes.$$scope = { changed, ctx };
    			buttongroup.$set(buttongroup_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(errorsbox.$$.fragment, local);

    			transition_in(textbox0.$$.fragment, local);

    			transition_in(textbox1.$$.fragment, local);

    			transition_in(textbox2.$$.fragment, local);

    			transition_in(button.$$.fragment, local);

    			transition_in(buttongroup.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(errorsbox.$$.fragment, local);
    			transition_out(textbox0.$$.fragment, local);
    			transition_out(textbox1.$$.fragment, local);
    			transition_out(textbox2.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			transition_out(buttongroup.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div3);
    			}

    			destroy_component(errorsbox);

    			destroy_component(textbox0);

    			destroy_component(textbox1);

    			destroy_component(textbox2);

    			destroy_component(button);

    			destroy_each(each_blocks, detaching);

    			destroy_component(buttongroup);

    			run_all(dispose);
    		}
    	};
    }

    function instance$l($$self, $$props, $$invalidate) {
    	

    let { action, onFinished = (action) => {} } = $$props;
    let { allActions, isNew = true } = $$props;

    let optKey = "";
    let optValue = "";

    let clonedAction = fp.cloneDeep(action); 
    let initialOptions = chain(action.initialOptions, [
        fp.keys,
        fp.map(k => ({key:k, value:action.initialOptions[k]}))
    ]);
    let errors = [];

    const addNewOption = () => {

        if(optKey && optValue && fp.isUndefined(clonedAction.initialOptions[optKey])) {
            clonedAction.initialOptions[optKey] = optValue; $$invalidate('clonedAction', clonedAction);
            $$invalidate('initialOptions', initialOptions = [...initialOptions, {
                key:optKey, value: optValue
            }]);
            $$invalidate('optKey', optKey = "");
            $$invalidate('optValue', optValue = "");
        }
    };

    const removeOption = (opt) => {
        if(opt) {
            delete clonedAction.initialOptions[opt.key];
            $$invalidate('initialOptions', initialOptions = chain(initialOptions, [
                fp.filter(o => o.key !== opt.key)
            ]));
        }
    };

    const save = () => {

        const newActionsList = [
            ...chain(allActions ,[fp.filter(a => a !== action)]),
            clonedAction];

        $$invalidate('errors', errors = chain(newActionsList ,[
            validateActions$1,
            fp.map(e => e.error)
        ]));

        if(errors.length === 0)
            onFinished(clonedAction);
    };

    const cancel = () => {
        onFinished();
    };

    	const writable_props = ['action', 'onFinished', 'allActions', 'isNew'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<ActionView> was created with unknown prop '${key}'`);
    	});

    	function textbox0_text_binding(value) {
    		clonedAction.name = value;
    		$$invalidate('clonedAction', clonedAction);
    	}

    	function textbox1_text_binding(value_1) {
    		clonedAction.behaviourSource = value_1;
    		$$invalidate('clonedAction', clonedAction);
    	}

    	function textbox2_text_binding(value_2) {
    		clonedAction.behaviourName = value_2;
    		$$invalidate('clonedAction', clonedAction);
    	}

    	function input0_input_handler() {
    		optKey = this.value;
    		$$invalidate('optKey', optKey);
    	}

    	function input1_input_handler() {
    		optValue = this.value;
    		$$invalidate('optValue', optValue);
    	}

    	function click_handler({ option }) {
    		return removeOption(option);
    	}

    	$$self.$set = $$props => {
    		if ('action' in $$props) $$invalidate('action', action = $$props.action);
    		if ('onFinished' in $$props) $$invalidate('onFinished', onFinished = $$props.onFinished);
    		if ('allActions' in $$props) $$invalidate('allActions', allActions = $$props.allActions);
    		if ('isNew' in $$props) $$invalidate('isNew', isNew = $$props.isNew);
    	};

    	return {
    		action,
    		onFinished,
    		allActions,
    		isNew,
    		optKey,
    		optValue,
    		clonedAction,
    		initialOptions,
    		errors,
    		addNewOption,
    		removeOption,
    		save,
    		cancel,
    		textbox0_text_binding,
    		textbox1_text_binding,
    		textbox2_text_binding,
    		input0_input_handler,
    		input1_input_handler,
    		click_handler
    	};
    }

    class ActionView extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$m, safe_not_equal, ["action", "onFinished", "allActions", "isNew"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.action === undefined && !('action' in props)) {
    			console.warn("<ActionView> was created without expected prop 'action'");
    		}
    		if (ctx.allActions === undefined && !('allActions' in props)) {
    			console.warn("<ActionView> was created without expected prop 'allActions'");
    		}
    	}

    	get action() {
    		throw new Error("<ActionView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set action(value) {
    		throw new Error("<ActionView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onFinished() {
    		throw new Error("<ActionView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onFinished(value) {
    		throw new Error("<ActionView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get allActions() {
    		throw new Error("<ActionView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set allActions(value) {
    		throw new Error("<ActionView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isNew() {
    		throw new Error("<ActionView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isNew(value) {
    		throw new Error("<ActionView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\actionsAndTriggers\Actions.svelte generated by Svelte v3.6.9 */

    const file$o = "src\\actionsAndTriggers\\Actions.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.action = list[i];
    	return child_ctx;
    }

    // (68:0) {:else}
    function create_else_block$5(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("(no actions added)");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		p: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (42:0) {#if $database.actions}
    function create_if_block_1$4(ctx) {
    	var table, thead, tr, th0, t1, th1, t3, th2, t5, th3, t7, th4, t8, tbody;

    	var each_value = ctx.$database.actions;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Description";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Behaviour Source";
    			t3 = space();
    			th2 = element("th");
    			th2.textContent = "Behaviour Name";
    			t5 = space();
    			th3 = element("th");
    			th3.textContent = "Default Options";
    			t7 = space();
    			th4 = element("th");
    			t8 = space();
    			tbody = element("tbody");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			add_location(th0, file$o, 45, 12, 1199);
    			add_location(th1, file$o, 46, 12, 1233);
    			add_location(th2, file$o, 47, 12, 1272);
    			add_location(th3, file$o, 48, 12, 1309);
    			add_location(th4, file$o, 49, 12, 1347);
    			add_location(tr, file$o, 44, 8, 1181);
    			add_location(thead, file$o, 43, 4, 1164);
    			add_location(tbody, file$o, 52, 4, 1391);
    			attr(table, "class", "fields-table uk-table uk-table-small");
    			add_location(table, file$o, 42, 0, 1106);
    		},

    		m: function mount(target, anchor) {
    			insert(target, table, anchor);
    			append(table, thead);
    			append(thead, tr);
    			append(tr, th0);
    			append(tr, t1);
    			append(tr, th1);
    			append(tr, t3);
    			append(tr, th2);
    			append(tr, t5);
    			append(tr, th3);
    			append(tr, t7);
    			append(tr, th4);
    			append(table, t8);
    			append(table, tbody);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (changed.getIcon || changed.getDefaultOptionsHtml || changed.$database) {
    				each_value = ctx.$database.actions;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$9(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(table);
    			}

    			destroy_each(each_blocks, detaching);
    		}
    	};
    }

    // (54:8) {#each $database.actions as action}
    function create_each_block$9(ctx) {
    	var tr, td0, t0_value = ctx.action.name, t0, t1, td1, t2_value = ctx.action.behaviourSource, t2, t3, td2, t4_value = ctx.action.behaviourName, t4, t5, td3, raw0_value = ctx.getDefaultOptionsHtml(ctx.action.initialOptions), t6, td4, span0, raw1_value = getIcon("edit"), t7, span1, raw2_value = getIcon("trash"), t8, dispose;

    	function click_handler() {
    		return ctx.click_handler(ctx);
    	}

    	function click_handler_1() {
    		return ctx.click_handler_1(ctx);
    	}

    	return {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text(t2_value);
    			t3 = space();
    			td2 = element("td");
    			t4 = text(t4_value);
    			t5 = space();
    			td3 = element("td");
    			t6 = space();
    			td4 = element("td");
    			span0 = element("span");
    			t7 = space();
    			span1 = element("span");
    			t8 = space();
    			add_location(td0, file$o, 55, 12, 1471);
    			add_location(td1, file$o, 56, 12, 1508);
    			add_location(td2, file$o, 57, 12, 1556);
    			add_location(td3, file$o, 58, 12, 1602);
    			add_location(span0, file$o, 60, 16, 1720);
    			add_location(span1, file$o, 61, 16, 1812);
    			attr(td4, "class", "edit-button svelte-12jzg4k");
    			add_location(td4, file$o, 59, 12, 1678);
    			attr(tr, "class", "svelte-12jzg4k");
    			add_location(tr, file$o, 54, 8, 1453);

    			dispose = [
    				listen(span0, "click", click_handler),
    				listen(span1, "click", click_handler_1)
    			];
    		},

    		m: function mount(target, anchor) {
    			insert(target, tr, anchor);
    			append(tr, td0);
    			append(td0, t0);
    			append(tr, t1);
    			append(tr, td1);
    			append(td1, t2);
    			append(tr, t3);
    			append(tr, td2);
    			append(td2, t4);
    			append(tr, t5);
    			append(tr, td3);
    			td3.innerHTML = raw0_value;
    			append(tr, t6);
    			append(tr, td4);
    			append(td4, span0);
    			span0.innerHTML = raw1_value;
    			append(td4, t7);
    			append(td4, span1);
    			span1.innerHTML = raw2_value;
    			append(tr, t8);
    		},

    		p: function update(changed, new_ctx) {
    			ctx = new_ctx;
    			if ((changed.$database) && t0_value !== (t0_value = ctx.action.name)) {
    				set_data(t0, t0_value);
    			}

    			if ((changed.$database) && t2_value !== (t2_value = ctx.action.behaviourSource)) {
    				set_data(t2, t2_value);
    			}

    			if ((changed.$database) && t4_value !== (t4_value = ctx.action.behaviourName)) {
    				set_data(t4, t4_value);
    			}

    			if ((changed.$database) && raw0_value !== (raw0_value = ctx.getDefaultOptionsHtml(ctx.action.initialOptions))) {
    				td3.innerHTML = raw0_value;
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(tr);
    			}

    			run_all(dispose);
    		}
    	};
    }

    // (74:4) {#if isEditing}
    function create_if_block$7(ctx) {
    	var current;

    	var actionview = new ActionView({
    		props: {
    		action: ctx.editingAction,
    		allActions: ctx.$database.actions,
    		onFinished: ctx.actionEditingFinished,
    		isNew: ctx.editingActionIsNew
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			actionview.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(actionview, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var actionview_changes = {};
    			if (changed.editingAction) actionview_changes.action = ctx.editingAction;
    			if (changed.$database) actionview_changes.allActions = ctx.$database.actions;
    			if (changed.actionEditingFinished) actionview_changes.onFinished = ctx.actionEditingFinished;
    			if (changed.editingActionIsNew) actionview_changes.isNew = ctx.editingActionIsNew;
    			actionview.$set(actionview_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(actionview.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(actionview.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(actionview, detaching);
    		}
    	};
    }

    // (73:0) <Modal bind:isOpen={isEditing}>
    function create_default_slot$4(ctx) {
    	var if_block_anchor, current;

    	var if_block = (ctx.isEditing) && create_if_block$7(ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.isEditing) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$7(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function create_fragment$n(ctx) {
    	var h3, t1, t2, updating_isOpen, current;

    	function select_block_type(ctx) {
    		if (ctx.$database.actions) return create_if_block_1$4;
    		return create_else_block$5;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(ctx);

    	function modal_isOpen_binding(value) {
    		ctx.modal_isOpen_binding.call(null, value);
    		updating_isOpen = true;
    		add_flush_callback(() => updating_isOpen = false);
    	}

    	let modal_props = {
    		$$slots: { default: [create_default_slot$4] },
    		$$scope: { ctx }
    	};
    	if (ctx.isEditing !== void 0) {
    		modal_props.isOpen = ctx.isEditing;
    	}
    	var modal = new Modal({ props: modal_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal, 'isOpen', modal_isOpen_binding));

    	return {
    		c: function create() {
    			h3 = element("h3");
    			h3.textContent = "Actions";
    			t1 = space();
    			if_block.c();
    			t2 = space();
    			modal.$$.fragment.c();
    			add_location(h3, file$o, 39, 0, 1061);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, h3, anchor);
    			insert(target, t1, anchor);
    			if_block.m(target, anchor);
    			insert(target, t2, anchor);
    			mount_component(modal, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);
    				if (if_block) {
    					if_block.c();
    					if_block.m(t2.parentNode, t2);
    				}
    			}

    			var modal_changes = {};
    			if (changed.$$scope || changed.isEditing || changed.editingAction || changed.$database || changed.editingActionIsNew) modal_changes.$$scope = { changed, ctx };
    			if (!updating_isOpen && changed.isEditing) {
    				modal_changes.isOpen = ctx.isEditing;
    			}
    			modal.$set(modal_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h3);
    				detach(t1);
    			}

    			if_block.d(detaching);

    			if (detaching) {
    				detach(t2);
    			}

    			destroy_component(modal, detaching);
    		}
    	};
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let $database;

    	validate_store(database, 'database');
    	subscribe($$self, database, $$value => { $database = $$value; $$invalidate('$database', $database); });

    	

    let { editingActionIsNew = false, editingAction = null, onActionEdit = (action) => {} } = $$props;
    let { onActionDelete = (action) => {} } = $$props;
    let { onActionSave = (action) => {} } = $$props;
    let { onActionCancel = () => {} } = $$props; 

    let getDefaultOptionsHtml = defaultOptions => 
        chain(defaultOptions, [
            fp.keys,
            fp.map(k => `<span style="color:var(--slate)">${k}: </span>${JSON.stringify(defaultOptions[k])}`),
            fp.join("<br>")
        ]);


    let actionEditingFinished = (action) => {
        
        if(action) {
            onActionSave(action);
        } else {
            onActionCancel();
        }
    };

    	const writable_props = ['editingActionIsNew', 'editingAction', 'onActionEdit', 'onActionDelete', 'onActionSave', 'onActionCancel'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Actions> was created with unknown prop '${key}'`);
    	});

    	function click_handler({ action }) {
    		return onActionEdit(action);
    	}

    	function click_handler_1({ action }) {
    		return onActionDelete(action);
    	}

    	function modal_isOpen_binding(value) {
    		isEditing = value;
    		$$invalidate('isEditing', isEditing), $$invalidate('editingAction', editingAction);
    	}

    	$$self.$set = $$props => {
    		if ('editingActionIsNew' in $$props) $$invalidate('editingActionIsNew', editingActionIsNew = $$props.editingActionIsNew);
    		if ('editingAction' in $$props) $$invalidate('editingAction', editingAction = $$props.editingAction);
    		if ('onActionEdit' in $$props) $$invalidate('onActionEdit', onActionEdit = $$props.onActionEdit);
    		if ('onActionDelete' in $$props) $$invalidate('onActionDelete', onActionDelete = $$props.onActionDelete);
    		if ('onActionSave' in $$props) $$invalidate('onActionSave', onActionSave = $$props.onActionSave);
    		if ('onActionCancel' in $$props) $$invalidate('onActionCancel', onActionCancel = $$props.onActionCancel);
    	};

    	let isEditing;

    	$$self.$$.update = ($$dirty = { editingAction: 1 }) => {
    		if ($$dirty.editingAction) { $$invalidate('isEditing', isEditing = (editingAction !== null)); }
    	};

    	return {
    		editingActionIsNew,
    		editingAction,
    		onActionEdit,
    		onActionDelete,
    		onActionSave,
    		onActionCancel,
    		getDefaultOptionsHtml,
    		actionEditingFinished,
    		isEditing,
    		$database,
    		click_handler,
    		click_handler_1,
    		modal_isOpen_binding
    	};
    }

    class Actions extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$n, safe_not_equal, ["editingActionIsNew", "editingAction", "onActionEdit", "onActionDelete", "onActionSave", "onActionCancel"]);
    	}

    	get editingActionIsNew() {
    		throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set editingActionIsNew(value) {
    		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get editingAction() {
    		throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set editingAction(value) {
    		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onActionEdit() {
    		throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onActionEdit(value) {
    		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onActionDelete() {
    		throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onActionDelete(value) {
    		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onActionSave() {
    		throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onActionSave(value) {
    		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onActionCancel() {
    		throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onActionCancel(value) {
    		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\actionsAndTriggers\TriggerView.svelte generated by Svelte v3.6.9 */

    const file$p = "src\\actionsAndTriggers\\TriggerView.svelte";

    // (56:8) <Button grouped on:click={save}>
    function create_default_slot_2$3(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Save");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (57:8) <Button grouped on:click={cancel}>
    function create_default_slot_1$3(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Cancel");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (55:4) <ButtonGroup>
    function create_default_slot$5(ctx) {
    	var t, current;

    	var button0 = new Button({
    		props: {
    		grouped: true,
    		$$slots: { default: [create_default_slot_2$3] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});
    	button0.$on("click", ctx.save);

    	var button1 = new Button({
    		props: {
    		grouped: true,
    		$$slots: { default: [create_default_slot_1$3] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});
    	button1.$on("click", ctx.cancel);

    	return {
    		c: function create() {
    			button0.$$.fragment.c();
    			t = space();
    			button1.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert(target, t, anchor);
    			mount_component(button1, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var button0_changes = {};
    			if (changed.$$scope) button0_changes.$$scope = { changed, ctx };
    			button0.$set(button0_changes);

    			var button1_changes = {};
    			if (changed.$$scope) button1_changes.$$scope = { changed, ctx };
    			button1.$set(button1_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);

    			transition_in(button1.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);

    			if (detaching) {
    				detach(t);
    			}

    			destroy_component(button1, detaching);
    		}
    	};
    }

    function create_fragment$o(ctx) {
    	var div, t0, updating_selected, t1, updating_selected_1, t2, updating_text, t3, updating_text_1, t4, current;

    	var errorsbox = new ErrorsBox({
    		props: {
    		errors: ctx.errors,
    		style: "margin-bottom:20px"
    	},
    		$$inline: true
    	});

    	function dropdown0_selected_binding(value) {
    		ctx.dropdown0_selected_binding.call(null, value);
    		updating_selected = true;
    		add_flush_callback(() => updating_selected = false);
    	}

    	let dropdown0_props = { label: "Event", options: ["",...events$1] };
    	if (ctx.clonedTrigger.eventName !== void 0) {
    		dropdown0_props.selected = ctx.clonedTrigger.eventName;
    	}
    	var dropdown0 = new Dropdown({ props: dropdown0_props, $$inline: true });

    	binding_callbacks.push(() => bind(dropdown0, 'selected', dropdown0_selected_binding));

    	function dropdown1_selected_binding(value_1) {
    		ctx.dropdown1_selected_binding.call(null, value_1);
    		updating_selected_1 = true;
    		add_flush_callback(() => updating_selected_1 = false);
    	}

    	let dropdown1_props = { label: "Action", options: ["",...ctx.actionNames] };
    	if (ctx.clonedTrigger.actionName !== void 0) {
    		dropdown1_props.selected = ctx.clonedTrigger.actionName;
    	}
    	var dropdown1 = new Dropdown({ props: dropdown1_props, $$inline: true });

    	binding_callbacks.push(() => bind(dropdown1, 'selected', dropdown1_selected_binding));

    	function codearea0_text_binding(value_2) {
    		ctx.codearea0_text_binding.call(null, value_2);
    		updating_text = true;
    		add_flush_callback(() => updating_text = false);
    	}

    	let codearea0_props = { label: "Condition (javascript)" };
    	if (ctx.clonedTrigger.condition !== void 0) {
    		codearea0_props.text = ctx.clonedTrigger.condition;
    	}
    	var codearea0 = new CodeArea({ props: codearea0_props, $$inline: true });

    	binding_callbacks.push(() => bind(codearea0, 'text', codearea0_text_binding));

    	function codearea1_text_binding(value_3) {
    		ctx.codearea1_text_binding.call(null, value_3);
    		updating_text_1 = true;
    		add_flush_callback(() => updating_text_1 = false);
    	}

    	let codearea1_props = {
    		label: "Action Options Creator (javascript)"
    	};
    	if (ctx.clonedTrigger.optionsCreator !== void 0) {
    		codearea1_props.text = ctx.clonedTrigger.optionsCreator;
    	}
    	var codearea1 = new CodeArea({ props: codearea1_props, $$inline: true });

    	binding_callbacks.push(() => bind(codearea1, 'text', codearea1_text_binding));

    	var buttongroup = new ButtonGroup({
    		props: {
    		$$slots: { default: [create_default_slot$5] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			div = element("div");
    			errorsbox.$$.fragment.c();
    			t0 = space();
    			dropdown0.$$.fragment.c();
    			t1 = space();
    			dropdown1.$$.fragment.c();
    			t2 = space();
    			codearea0.$$.fragment.c();
    			t3 = space();
    			codearea1.$$.fragment.c();
    			t4 = space();
    			buttongroup.$$.fragment.c();
    			add_location(div, file$p, 39, 0, 1184);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			mount_component(errorsbox, div, null);
    			append(div, t0);
    			mount_component(dropdown0, div, null);
    			append(div, t1);
    			mount_component(dropdown1, div, null);
    			append(div, t2);
    			mount_component(codearea0, div, null);
    			append(div, t3);
    			mount_component(codearea1, div, null);
    			append(div, t4);
    			mount_component(buttongroup, div, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var errorsbox_changes = {};
    			if (changed.errors) errorsbox_changes.errors = ctx.errors;
    			errorsbox.$set(errorsbox_changes);

    			var dropdown0_changes = {};
    			if (changed.events) dropdown0_changes.options = ["",...events$1];
    			if (!updating_selected && changed.clonedTrigger) {
    				dropdown0_changes.selected = ctx.clonedTrigger.eventName;
    			}
    			dropdown0.$set(dropdown0_changes);

    			var dropdown1_changes = {};
    			if (changed.actionNames) dropdown1_changes.options = ["",...ctx.actionNames];
    			if (!updating_selected_1 && changed.clonedTrigger) {
    				dropdown1_changes.selected = ctx.clonedTrigger.actionName;
    			}
    			dropdown1.$set(dropdown1_changes);

    			var codearea0_changes = {};
    			if (!updating_text && changed.clonedTrigger) {
    				codearea0_changes.text = ctx.clonedTrigger.condition;
    			}
    			codearea0.$set(codearea0_changes);

    			var codearea1_changes = {};
    			if (!updating_text_1 && changed.clonedTrigger) {
    				codearea1_changes.text = ctx.clonedTrigger.optionsCreator;
    			}
    			codearea1.$set(codearea1_changes);

    			var buttongroup_changes = {};
    			if (changed.$$scope) buttongroup_changes.$$scope = { changed, ctx };
    			buttongroup.$set(buttongroup_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(errorsbox.$$.fragment, local);

    			transition_in(dropdown0.$$.fragment, local);

    			transition_in(dropdown1.$$.fragment, local);

    			transition_in(codearea0.$$.fragment, local);

    			transition_in(codearea1.$$.fragment, local);

    			transition_in(buttongroup.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(errorsbox.$$.fragment, local);
    			transition_out(dropdown0.$$.fragment, local);
    			transition_out(dropdown1.$$.fragment, local);
    			transition_out(codearea0.$$.fragment, local);
    			transition_out(codearea1.$$.fragment, local);
    			transition_out(buttongroup.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			destroy_component(errorsbox);

    			destroy_component(dropdown0);

    			destroy_component(dropdown1);

    			destroy_component(codearea0);

    			destroy_component(codearea1);

    			destroy_component(buttongroup);
    		}
    	};
    }

    function instance$n($$self, $$props, $$invalidate) {
    	

    let { trigger, onFinished = (action) => {} } = $$props;
    let { allTriggers, allActions, isNew = true } = $$props;

    let clonedTrigger = fp.cloneDeep(trigger); 
    let errors = [];

    let cancel = () => onFinished();
    let save = () => {
        const newTriggersList = [
            ...chain(allTriggers ,[fp.filter(t => t !== trigger)]),
            clonedTrigger];

        $$invalidate('errors', errors = validateTriggers$1(newTriggersList,  allActions));

        const test = fp.map(t =>(!t.actionName || fp.some(a => a.name === t.actionName)(allActions)))(newTriggersList);

        if(errors.length === 0)
            onFinished(clonedTrigger);
    };

    	const writable_props = ['trigger', 'onFinished', 'allTriggers', 'allActions', 'isNew'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<TriggerView> was created with unknown prop '${key}'`);
    	});

    	function dropdown0_selected_binding(value) {
    		clonedTrigger.eventName = value;
    		$$invalidate('clonedTrigger', clonedTrigger);
    	}

    	function dropdown1_selected_binding(value_1) {
    		clonedTrigger.actionName = value_1;
    		$$invalidate('clonedTrigger', clonedTrigger);
    	}

    	function codearea0_text_binding(value_2) {
    		clonedTrigger.condition = value_2;
    		$$invalidate('clonedTrigger', clonedTrigger);
    	}

    	function codearea1_text_binding(value_3) {
    		clonedTrigger.optionsCreator = value_3;
    		$$invalidate('clonedTrigger', clonedTrigger);
    	}

    	$$self.$set = $$props => {
    		if ('trigger' in $$props) $$invalidate('trigger', trigger = $$props.trigger);
    		if ('onFinished' in $$props) $$invalidate('onFinished', onFinished = $$props.onFinished);
    		if ('allTriggers' in $$props) $$invalidate('allTriggers', allTriggers = $$props.allTriggers);
    		if ('allActions' in $$props) $$invalidate('allActions', allActions = $$props.allActions);
    		if ('isNew' in $$props) $$invalidate('isNew', isNew = $$props.isNew);
    	};

    	let actionNames;

    	$$self.$$.update = ($$dirty = { allActions: 1 }) => {
    		if ($$dirty.allActions) { $$invalidate('actionNames', actionNames = fp.map(a => a.name)(allActions)); }
    	};

    	return {
    		trigger,
    		onFinished,
    		allTriggers,
    		allActions,
    		isNew,
    		clonedTrigger,
    		errors,
    		cancel,
    		save,
    		actionNames,
    		dropdown0_selected_binding,
    		dropdown1_selected_binding,
    		codearea0_text_binding,
    		codearea1_text_binding
    	};
    }

    class TriggerView extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$o, safe_not_equal, ["trigger", "onFinished", "allTriggers", "allActions", "isNew"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.trigger === undefined && !('trigger' in props)) {
    			console.warn("<TriggerView> was created without expected prop 'trigger'");
    		}
    		if (ctx.allTriggers === undefined && !('allTriggers' in props)) {
    			console.warn("<TriggerView> was created without expected prop 'allTriggers'");
    		}
    		if (ctx.allActions === undefined && !('allActions' in props)) {
    			console.warn("<TriggerView> was created without expected prop 'allActions'");
    		}
    	}

    	get trigger() {
    		throw new Error("<TriggerView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set trigger(value) {
    		throw new Error("<TriggerView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onFinished() {
    		throw new Error("<TriggerView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onFinished(value) {
    		throw new Error("<TriggerView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get allTriggers() {
    		throw new Error("<TriggerView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set allTriggers(value) {
    		throw new Error("<TriggerView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get allActions() {
    		throw new Error("<TriggerView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set allActions(value) {
    		throw new Error("<TriggerView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isNew() {
    		throw new Error("<TriggerView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isNew(value) {
    		throw new Error("<TriggerView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\actionsAndTriggers\Triggers.svelte generated by Svelte v3.6.9 */

    const file$q = "src\\actionsAndTriggers\\Triggers.svelte";

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.trigger = list[i];
    	return child_ctx;
    }

    // (58:0) {:else}
    function create_else_block$6(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("(no triggers added)");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		p: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (32:0) {#if $database.triggers}
    function create_if_block_1$5(ctx) {
    	var table, thead, tr, th0, t1, th1, t3, th2, t5, th3, t7, th4, t8, tbody;

    	var each_value = ctx.$database.triggers;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Event";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Action";
    			t3 = space();
    			th2 = element("th");
    			th2.textContent = "Condition";
    			t5 = space();
    			th3 = element("th");
    			th3.textContent = "Create Options";
    			t7 = space();
    			th4 = element("th");
    			t8 = space();
    			tbody = element("tbody");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			add_location(th0, file$q, 35, 12, 848);
    			add_location(th1, file$q, 36, 12, 876);
    			add_location(th2, file$q, 37, 12, 905);
    			add_location(th3, file$q, 38, 12, 937);
    			add_location(th4, file$q, 39, 12, 974);
    			add_location(tr, file$q, 34, 8, 830);
    			add_location(thead, file$q, 33, 4, 813);
    			add_location(tbody, file$q, 42, 4, 1018);
    			attr(table, "class", "fields-table uk-table uk-table-small");
    			add_location(table, file$q, 32, 0, 755);
    		},

    		m: function mount(target, anchor) {
    			insert(target, table, anchor);
    			append(table, thead);
    			append(thead, tr);
    			append(tr, th0);
    			append(tr, t1);
    			append(tr, th1);
    			append(tr, t3);
    			append(tr, th2);
    			append(tr, t5);
    			append(tr, th3);
    			append(tr, t7);
    			append(tr, th4);
    			append(table, t8);
    			append(table, tbody);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (changed.getIcon || changed.$database) {
    				each_value = ctx.$database.triggers;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$a(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(table);
    			}

    			destroy_each(each_blocks, detaching);
    		}
    	};
    }

    // (44:8) {#each $database.triggers as trigger}
    function create_each_block$a(ctx) {
    	var tr, td0, t0_value = ctx.trigger.eventName, t0, t1, td1, t2_value = ctx.trigger.actionName, t2, t3, td2, t4_value = ctx.trigger.condition, t4, t5, td3, t6_value = ctx.trigger.optionsCreator, t6, t7, td4, span0, raw0_value = getIcon("edit"), t8, span1, raw1_value = getIcon("trash"), t9, dispose;

    	function click_handler() {
    		return ctx.click_handler(ctx);
    	}

    	function click_handler_1() {
    		return ctx.click_handler_1(ctx);
    	}

    	return {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text(t2_value);
    			t3 = space();
    			td2 = element("td");
    			t4 = text(t4_value);
    			t5 = space();
    			td3 = element("td");
    			t6 = text(t6_value);
    			t7 = space();
    			td4 = element("td");
    			span0 = element("span");
    			t8 = space();
    			span1 = element("span");
    			t9 = space();
    			add_location(td0, file$q, 45, 12, 1100);
    			add_location(td1, file$q, 46, 12, 1143);
    			add_location(td2, file$q, 47, 12, 1187);
    			add_location(td3, file$q, 48, 12, 1230);
    			add_location(span0, file$q, 50, 16, 1320);
    			add_location(span1, file$q, 51, 16, 1414);
    			attr(td4, "class", "edit-button svelte-1le5bpl");
    			add_location(td4, file$q, 49, 12, 1278);
    			attr(tr, "class", "svelte-1le5bpl");
    			add_location(tr, file$q, 44, 8, 1082);

    			dispose = [
    				listen(span0, "click", click_handler),
    				listen(span1, "click", click_handler_1)
    			];
    		},

    		m: function mount(target, anchor) {
    			insert(target, tr, anchor);
    			append(tr, td0);
    			append(td0, t0);
    			append(tr, t1);
    			append(tr, td1);
    			append(td1, t2);
    			append(tr, t3);
    			append(tr, td2);
    			append(td2, t4);
    			append(tr, t5);
    			append(tr, td3);
    			append(td3, t6);
    			append(tr, t7);
    			append(tr, td4);
    			append(td4, span0);
    			span0.innerHTML = raw0_value;
    			append(td4, t8);
    			append(td4, span1);
    			span1.innerHTML = raw1_value;
    			append(tr, t9);
    		},

    		p: function update(changed, new_ctx) {
    			ctx = new_ctx;
    			if ((changed.$database) && t0_value !== (t0_value = ctx.trigger.eventName)) {
    				set_data(t0, t0_value);
    			}

    			if ((changed.$database) && t2_value !== (t2_value = ctx.trigger.actionName)) {
    				set_data(t2, t2_value);
    			}

    			if ((changed.$database) && t4_value !== (t4_value = ctx.trigger.condition)) {
    				set_data(t4, t4_value);
    			}

    			if ((changed.$database) && t6_value !== (t6_value = ctx.trigger.optionsCreator)) {
    				set_data(t6, t6_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(tr);
    			}

    			run_all(dispose);
    		}
    	};
    }

    // (64:4) {#if isEditing}
    function create_if_block$8(ctx) {
    	var current;

    	var triggerview = new TriggerView({
    		props: {
    		trigger: ctx.editingTrigger,
    		allActions: ctx.$database.actions,
    		allTriggers: ctx.$database.triggers,
    		onFinished: ctx.triggerEditingFinished,
    		isNew: ctx.editingTriggerIsNew
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			triggerview.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(triggerview, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var triggerview_changes = {};
    			if (changed.editingTrigger) triggerview_changes.trigger = ctx.editingTrigger;
    			if (changed.$database) triggerview_changes.allActions = ctx.$database.actions;
    			if (changed.$database) triggerview_changes.allTriggers = ctx.$database.triggers;
    			if (changed.triggerEditingFinished) triggerview_changes.onFinished = ctx.triggerEditingFinished;
    			if (changed.editingTriggerIsNew) triggerview_changes.isNew = ctx.editingTriggerIsNew;
    			triggerview.$set(triggerview_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(triggerview.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(triggerview.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(triggerview, detaching);
    		}
    	};
    }

    // (63:0) <Modal bind:isOpen={isEditing}>
    function create_default_slot$6(ctx) {
    	var if_block_anchor, current;

    	var if_block = (ctx.isEditing) && create_if_block$8(ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.isEditing) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$8(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function create_fragment$p(ctx) {
    	var h3, t1, t2, updating_isOpen, current;

    	function select_block_type(ctx) {
    		if (ctx.$database.triggers) return create_if_block_1$5;
    		return create_else_block$6;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(ctx);

    	function modal_isOpen_binding(value) {
    		ctx.modal_isOpen_binding.call(null, value);
    		updating_isOpen = true;
    		add_flush_callback(() => updating_isOpen = false);
    	}

    	let modal_props = {
    		$$slots: { default: [create_default_slot$6] },
    		$$scope: { ctx }
    	};
    	if (ctx.isEditing !== void 0) {
    		modal_props.isOpen = ctx.isEditing;
    	}
    	var modal = new Modal({ props: modal_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal, 'isOpen', modal_isOpen_binding));

    	return {
    		c: function create() {
    			h3 = element("h3");
    			h3.textContent = "Triggers";
    			t1 = space();
    			if_block.c();
    			t2 = space();
    			modal.$$.fragment.c();
    			add_location(h3, file$q, 29, 0, 708);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, h3, anchor);
    			insert(target, t1, anchor);
    			if_block.m(target, anchor);
    			insert(target, t2, anchor);
    			mount_component(modal, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);
    				if (if_block) {
    					if_block.c();
    					if_block.m(t2.parentNode, t2);
    				}
    			}

    			var modal_changes = {};
    			if (changed.$$scope || changed.isEditing || changed.editingTrigger || changed.$database || changed.editingTriggerIsNew) modal_changes.$$scope = { changed, ctx };
    			if (!updating_isOpen && changed.isEditing) {
    				modal_changes.isOpen = ctx.isEditing;
    			}
    			modal.$set(modal_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h3);
    				detach(t1);
    			}

    			if_block.d(detaching);

    			if (detaching) {
    				detach(t2);
    			}

    			destroy_component(modal, detaching);
    		}
    	};
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let $database;

    	validate_store(database, 'database');
    	subscribe($$self, database, $$value => { $database = $$value; $$invalidate('$database', $database); });

    	


    let { editingTrigger = null, editingTriggerIsNew = true, onTriggerEdit = (trigger) => {} } = $$props;
    let { onTriggerDelete = (trigger) => {} } = $$props;
    let { onTriggerSave = (trigger) => {} } = $$props;
    let { onTriggerCancel = () => {} } = $$props; 

    let triggerEditingFinished = (trigger) => {
        
        if(trigger) {
            onTriggerSave(trigger);
        } else {
            onTriggerCancel();
        }
    };

    	const writable_props = ['editingTrigger', 'editingTriggerIsNew', 'onTriggerEdit', 'onTriggerDelete', 'onTriggerSave', 'onTriggerCancel'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Triggers> was created with unknown prop '${key}'`);
    	});

    	function click_handler({ trigger }) {
    		return onTriggerEdit(trigger);
    	}

    	function click_handler_1({ trigger }) {
    		return onTriggerDelete(trigger);
    	}

    	function modal_isOpen_binding(value) {
    		isEditing = value;
    		$$invalidate('isEditing', isEditing), $$invalidate('editingTrigger', editingTrigger);
    	}

    	$$self.$set = $$props => {
    		if ('editingTrigger' in $$props) $$invalidate('editingTrigger', editingTrigger = $$props.editingTrigger);
    		if ('editingTriggerIsNew' in $$props) $$invalidate('editingTriggerIsNew', editingTriggerIsNew = $$props.editingTriggerIsNew);
    		if ('onTriggerEdit' in $$props) $$invalidate('onTriggerEdit', onTriggerEdit = $$props.onTriggerEdit);
    		if ('onTriggerDelete' in $$props) $$invalidate('onTriggerDelete', onTriggerDelete = $$props.onTriggerDelete);
    		if ('onTriggerSave' in $$props) $$invalidate('onTriggerSave', onTriggerSave = $$props.onTriggerSave);
    		if ('onTriggerCancel' in $$props) $$invalidate('onTriggerCancel', onTriggerCancel = $$props.onTriggerCancel);
    	};

    	let isEditing;

    	$$self.$$.update = ($$dirty = { editingTrigger: 1 }) => {
    		if ($$dirty.editingTrigger) { $$invalidate('isEditing', isEditing = (editingTrigger !== null)); }
    	};

    	return {
    		editingTrigger,
    		editingTriggerIsNew,
    		onTriggerEdit,
    		onTriggerDelete,
    		onTriggerSave,
    		onTriggerCancel,
    		triggerEditingFinished,
    		isEditing,
    		$database,
    		click_handler,
    		click_handler_1,
    		modal_isOpen_binding
    	};
    }

    class Triggers extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$p, safe_not_equal, ["editingTrigger", "editingTriggerIsNew", "onTriggerEdit", "onTriggerDelete", "onTriggerSave", "onTriggerCancel"]);
    	}

    	get editingTrigger() {
    		throw new Error("<Triggers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set editingTrigger(value) {
    		throw new Error("<Triggers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get editingTriggerIsNew() {
    		throw new Error("<Triggers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set editingTriggerIsNew(value) {
    		throw new Error("<Triggers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onTriggerEdit() {
    		throw new Error("<Triggers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onTriggerEdit(value) {
    		throw new Error("<Triggers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onTriggerDelete() {
    		throw new Error("<Triggers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onTriggerDelete(value) {
    		throw new Error("<Triggers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onTriggerSave() {
    		throw new Error("<Triggers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onTriggerSave(value) {
    		throw new Error("<Triggers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onTriggerCancel() {
    		throw new Error("<Triggers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onTriggerCancel(value) {
    		throw new Error("<Triggers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\actionsAndTriggers\ActionsAndTriggersRoot.svelte generated by Svelte v3.6.9 */

    const file$r = "src\\actionsAndTriggers\\ActionsAndTriggersRoot.svelte";

    // (90:4) <Button color="secondary"               grouped              on:click={newAction}>
    function create_default_slot_2$4(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Create New Action");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (93:4) <Button color="secondary"               grouped              on:click={newTrigger}>
    function create_default_slot_1$4(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Create New Trigger");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (89:0) <ButtonGroup>
    function create_default_slot$7(ctx) {
    	var t, current;

    	var button0 = new Button({
    		props: {
    		color: "secondary",
    		grouped: true,
    		$$slots: { default: [create_default_slot_2$4] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});
    	button0.$on("click", ctx.newAction);

    	var button1 = new Button({
    		props: {
    		color: "secondary",
    		grouped: true,
    		$$slots: { default: [create_default_slot_1$4] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});
    	button1.$on("click", ctx.newTrigger);

    	return {
    		c: function create() {
    			button0.$$.fragment.c();
    			t = space();
    			button1.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert(target, t, anchor);
    			mount_component(button1, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var button0_changes = {};
    			if (changed.$$scope) button0_changes.$$scope = { changed, ctx };
    			button0.$set(button0_changes);

    			var button1_changes = {};
    			if (changed.$$scope) button1_changes.$$scope = { changed, ctx };
    			button1.$set(button1_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);

    			transition_in(button1.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);

    			if (detaching) {
    				detach(t);
    			}

    			destroy_component(button1, detaching);
    		}
    	};
    }

    function create_fragment$q(ctx) {
    	var div, t0, t1, current;

    	var buttongroup = new ButtonGroup({
    		props: {
    		$$slots: { default: [create_default_slot$7] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});

    	var actions = new Actions({
    		props: {
    		editingActionIsNew: ctx.editingActionIsNew,
    		editingAction: ctx.editingAction,
    		onActionEdit: ctx.onActionEdit,
    		onActionDelete: ctx.onActionDelete,
    		onActionSave: ctx.onActionSave,
    		onActionCancel: ctx.onActionCancel
    	},
    		$$inline: true
    	});

    	var triggers = new Triggers({
    		props: {
    		editingTriggerIsNew: ctx.editingTriggerIsNew,
    		editingTrigger: ctx.editingTrigger,
    		onTriggerEdit: ctx.onTriggerEdit,
    		onTriggerDelete: ctx.onTriggerDelete,
    		onTriggerSave: ctx.onTriggerSave,
    		onTriggerCancel: ctx.onTriggerCancel
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			div = element("div");
    			buttongroup.$$.fragment.c();
    			t0 = space();
    			actions.$$.fragment.c();
    			t1 = space();
    			triggers.$$.fragment.c();
    			attr(div, "class", "root svelte-1y6dy5x");
    			add_location(div, file$r, 86, 0, 1895);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			mount_component(buttongroup, div, null);
    			append(div, t0);
    			mount_component(actions, div, null);
    			append(div, t1);
    			mount_component(triggers, div, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var buttongroup_changes = {};
    			if (changed.$$scope) buttongroup_changes.$$scope = { changed, ctx };
    			buttongroup.$set(buttongroup_changes);

    			var actions_changes = {};
    			if (changed.editingActionIsNew) actions_changes.editingActionIsNew = ctx.editingActionIsNew;
    			if (changed.editingAction) actions_changes.editingAction = ctx.editingAction;
    			if (changed.onActionEdit) actions_changes.onActionEdit = ctx.onActionEdit;
    			if (changed.onActionDelete) actions_changes.onActionDelete = ctx.onActionDelete;
    			if (changed.onActionSave) actions_changes.onActionSave = ctx.onActionSave;
    			if (changed.onActionCancel) actions_changes.onActionCancel = ctx.onActionCancel;
    			actions.$set(actions_changes);

    			var triggers_changes = {};
    			if (changed.editingTriggerIsNew) triggers_changes.editingTriggerIsNew = ctx.editingTriggerIsNew;
    			if (changed.editingTrigger) triggers_changes.editingTrigger = ctx.editingTrigger;
    			if (changed.onTriggerEdit) triggers_changes.onTriggerEdit = ctx.onTriggerEdit;
    			if (changed.onTriggerDelete) triggers_changes.onTriggerDelete = ctx.onTriggerDelete;
    			if (changed.onTriggerSave) triggers_changes.onTriggerSave = ctx.onTriggerSave;
    			if (changed.onTriggerCancel) triggers_changes.onTriggerCancel = ctx.onTriggerCancel;
    			triggers.$set(triggers_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(buttongroup.$$.fragment, local);

    			transition_in(actions.$$.fragment, local);

    			transition_in(triggers.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(buttongroup.$$.fragment, local);
    			transition_out(actions.$$.fragment, local);
    			transition_out(triggers.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			destroy_component(buttongroup);

    			destroy_component(actions);

    			destroy_component(triggers);
    		}
    	};
    }

    function instance$p($$self, $$props, $$invalidate) {
    	

    let editingAction = null;
    let editingActionIsNew = true;
    let editingTrigger = null;
    let editingTriggerIsNew = true;

    let onActionEdit = (action) => {
        $$invalidate('editingAction', editingAction = action);
        $$invalidate('editingActionIsNew', editingActionIsNew = false);
    };

    let newAction = () => {
        $$invalidate('editingAction', editingAction = getNewAction());
        $$invalidate('editingActionIsNew', editingActionIsNew = true);
    };

    let onActionDelete = (action) => {
        database.deleteAction(action);
    };

    let newTrigger = () => {
        $$invalidate('editingTrigger', editingTrigger = getNewTrigger());
        $$invalidate('editingTriggerIsNew', editingTriggerIsNew = true);
    };

    let onActionSave = action => {
        database.saveAction(
                action, 
                editingActionIsNew, 
                editingAction);

        $$invalidate('editingAction', editingAction = null);
    };

    let onActionCancel = () => {
        $$invalidate('editingAction', editingAction = null);
    };

    let onTriggerSave = trigger => {
        database.saveTrigger(
                trigger, 
                editingTriggerIsNew, 
                editingTrigger);

        $$invalidate('editingTrigger', editingTrigger = null);
    };

    let onTriggerCancel = () => {
        $$invalidate('editingTrigger', editingTrigger = null);
    };

    let onTriggerEdit = (trigger) => {
        $$invalidate('editingTrigger', editingTrigger = trigger);
        $$invalidate('editingTriggerIsNew', editingTriggerIsNew = false);
    };


    let onTriggerDelete = (trigger) => {
        database.deleteTrigger(trigger);
    };

    	return {
    		editingAction,
    		editingActionIsNew,
    		editingTrigger,
    		editingTriggerIsNew,
    		onActionEdit,
    		newAction,
    		onActionDelete,
    		newTrigger,
    		onActionSave,
    		onActionCancel,
    		onTriggerSave,
    		onTriggerCancel,
    		onTriggerEdit,
    		onTriggerDelete
    	};
    }

    class ActionsAndTriggersRoot extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$q, safe_not_equal, []);
    	}
    }

    /* src\accessLevels\AccessLevelView.svelte generated by Svelte v3.6.9 */

    const file$s = "src\\accessLevels\\AccessLevelView.svelte";

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.permission = list[i];
    	return child_ctx;
    }

    // (77:4) {#each permissionMatrix as permission}
    function create_each_block$b(ctx) {
    	var div, current;

    	var checkbox = new Checkbox({
    		props: {
    		label: ctx.getPermissionName(ctx.permission.permission),
    		checked: ctx.permission.hasPermission
    	},
    		$$inline: true
    	});
    	checkbox.$on("change", ctx.permissionChanged(ctx.permission.permission));

    	return {
    		c: function create() {
    			div = element("div");
    			checkbox.$$.fragment.c();
    			add_location(div, file$s, 77, 4, 1870);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			mount_component(checkbox, div, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var checkbox_changes = {};
    			if (changed.getPermissionName || changed.permissionMatrix) checkbox_changes.label = ctx.getPermissionName(ctx.permission.permission);
    			if (changed.permissionMatrix) checkbox_changes.checked = ctx.permission.hasPermission;
    			checkbox.$set(checkbox_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkbox.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(checkbox.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			destroy_component(checkbox);
    		}
    	};
    }

    // (87:8) <Button color="primary" grouped on:click={save}>
    function create_default_slot_2$5(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Save");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (88:8) <Button color="secondary" grouped on:click={() => onFinished()}>
    function create_default_slot_1$5(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Cancel");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (86:4) <ButtonGroup style="margin-top: 10px">
    function create_default_slot$8(ctx) {
    	var t, current;

    	var button0 = new Button({
    		props: {
    		color: "primary",
    		grouped: true,
    		$$slots: { default: [create_default_slot_2$5] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});
    	button0.$on("click", ctx.save);

    	var button1 = new Button({
    		props: {
    		color: "secondary",
    		grouped: true,
    		$$slots: { default: [create_default_slot_1$5] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});
    	button1.$on("click", ctx.click_handler);

    	return {
    		c: function create() {
    			button0.$$.fragment.c();
    			t = space();
    			button1.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert(target, t, anchor);
    			mount_component(button1, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var button0_changes = {};
    			if (changed.$$scope) button0_changes.$$scope = { changed, ctx };
    			button0.$set(button0_changes);

    			var button1_changes = {};
    			if (changed.$$scope) button1_changes.$$scope = { changed, ctx };
    			button1.$set(button1_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);

    			transition_in(button1.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);

    			if (detaching) {
    				detach(t);
    			}

    			destroy_component(button1, detaching);
    		}
    	};
    }

    function create_fragment$r(ctx) {
    	var div, t0, updating_text, t1, t2, current;

    	var errorsbox = new ErrorsBox({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	function textbox_text_binding(value) {
    		ctx.textbox_text_binding.call(null, value);
    		updating_text = true;
    		add_flush_callback(() => updating_text = false);
    	}

    	let textbox_props = { label: "Name" };
    	if (ctx.clonedLevel.name !== void 0) {
    		textbox_props.text = ctx.clonedLevel.name;
    	}
    	var textbox = new Textbox({ props: textbox_props, $$inline: true });

    	binding_callbacks.push(() => bind(textbox, 'text', textbox_text_binding));

    	var each_value = ctx.permissionMatrix;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	var buttongroup = new ButtonGroup({
    		props: {
    		style: "margin-top: 10px",
    		$$slots: { default: [create_default_slot$8] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			div = element("div");
    			errorsbox.$$.fragment.c();
    			t0 = space();
    			textbox.$$.fragment.c();
    			t1 = space();

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			buttongroup.$$.fragment.c();
    			add_location(div, file$s, 70, 0, 1722);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			mount_component(errorsbox, div, null);
    			append(div, t0);
    			mount_component(textbox, div, null);
    			append(div, t1);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			append(div, t2);
    			mount_component(buttongroup, div, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var errorsbox_changes = {};
    			if (changed.errors) errorsbox_changes.errors = ctx.errors;
    			errorsbox.$set(errorsbox_changes);

    			var textbox_changes = {};
    			if (!updating_text && changed.clonedLevel) {
    				textbox_changes.text = ctx.clonedLevel.name;
    			}
    			textbox.$set(textbox_changes);

    			if (changed.getPermissionName || changed.permissionMatrix) {
    				each_value = ctx.permissionMatrix;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$b(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$b(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, t2);
    					}
    				}

    				group_outros();
    				for (i = each_value.length; i < each_blocks.length; i += 1) out(i);
    				check_outros();
    			}

    			var buttongroup_changes = {};
    			if (changed.$$scope) buttongroup_changes.$$scope = { changed, ctx };
    			buttongroup.$set(buttongroup_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(errorsbox.$$.fragment, local);

    			transition_in(textbox.$$.fragment, local);

    			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

    			transition_in(buttongroup.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(errorsbox.$$.fragment, local);
    			transition_out(textbox.$$.fragment, local);

    			each_blocks = each_blocks.filter(Boolean);
    			for (let i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			transition_out(buttongroup.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			destroy_component(errorsbox);

    			destroy_component(textbox);

    			destroy_each(each_blocks, detaching);

    			destroy_component(buttongroup);
    		}
    	};
    }

    function instance$q($$self, $$props, $$invalidate) {
    	

    let { level, allPermissions, onFinished, isNew, allLevels, hierarchy, actions } = $$props;

    let errors = [];
    let clonedLevel = fp.cloneDeep(level);

    const matchPermissions = (p1, p2) => 
        p1.type === p2.type
        && 
        ((!p2.nodeKey && !p1.nodeKey)
          || p2.nodeKey === p1.nodeKey);

    const hasPermission = hasPerm => 
        fp.some(p => matchPermissions(p, hasPerm))
        (clonedLevel.permissions);

    const getPermissionName = perm => 
        perm.nodeKey
        ? `${perm.type} - ${perm.nodeKey}`
        : perm.type;

    const save = () => {

        const newLevels = 
            isNew 
            ? [...allLevels, clonedLevel]
            : [...fp.filter(l => l.name !== level.name)(allLevels), clonedLevel];

        $$invalidate('errors', errors = validateAccessLevels$1(
            hierarchy,
            actions,
            newLevels
        ));

        if(errors.length > 0) return;

        onFinished(clonedLevel);
    };

    const permissionChanged = perm => ev => {
        const hasPermission = ev.target.checked;

        if(hasPermission) {
            clonedLevel.permissions.push(perm);
        } else {
            clonedLevel.permissions = fp.filter(p => !matchPermissions(p, perm)); $$invalidate('clonedLevel', clonedLevel);
        }
    };

    	const writable_props = ['level', 'allPermissions', 'onFinished', 'isNew', 'allLevels', 'hierarchy', 'actions'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<AccessLevelView> was created with unknown prop '${key}'`);
    	});

    	function textbox_text_binding(value) {
    		clonedLevel.name = value;
    		$$invalidate('clonedLevel', clonedLevel);
    	}

    	function click_handler() {
    		return onFinished();
    	}

    	$$self.$set = $$props => {
    		if ('level' in $$props) $$invalidate('level', level = $$props.level);
    		if ('allPermissions' in $$props) $$invalidate('allPermissions', allPermissions = $$props.allPermissions);
    		if ('onFinished' in $$props) $$invalidate('onFinished', onFinished = $$props.onFinished);
    		if ('isNew' in $$props) $$invalidate('isNew', isNew = $$props.isNew);
    		if ('allLevels' in $$props) $$invalidate('allLevels', allLevels = $$props.allLevels);
    		if ('hierarchy' in $$props) $$invalidate('hierarchy', hierarchy = $$props.hierarchy);
    		if ('actions' in $$props) $$invalidate('actions', actions = $$props.actions);
    	};

    	let permissionMatrix;

    	$$self.$$.update = ($$dirty = { allPermissions: 1 }) => {
    		if ($$dirty.allPermissions) { $$invalidate('permissionMatrix', permissionMatrix = 
                fp.map(p => ({permission:p, hasPermission: hasPermission(p)}))
                   (allPermissions)); }
    	};

    	return {
    		level,
    		allPermissions,
    		onFinished,
    		isNew,
    		allLevels,
    		hierarchy,
    		actions,
    		errors,
    		clonedLevel,
    		getPermissionName,
    		save,
    		permissionChanged,
    		permissionMatrix,
    		textbox_text_binding,
    		click_handler
    	};
    }

    class AccessLevelView extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$r, safe_not_equal, ["level", "allPermissions", "onFinished", "isNew", "allLevels", "hierarchy", "actions"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.level === undefined && !('level' in props)) {
    			console.warn("<AccessLevelView> was created without expected prop 'level'");
    		}
    		if (ctx.allPermissions === undefined && !('allPermissions' in props)) {
    			console.warn("<AccessLevelView> was created without expected prop 'allPermissions'");
    		}
    		if (ctx.onFinished === undefined && !('onFinished' in props)) {
    			console.warn("<AccessLevelView> was created without expected prop 'onFinished'");
    		}
    		if (ctx.isNew === undefined && !('isNew' in props)) {
    			console.warn("<AccessLevelView> was created without expected prop 'isNew'");
    		}
    		if (ctx.allLevels === undefined && !('allLevels' in props)) {
    			console.warn("<AccessLevelView> was created without expected prop 'allLevels'");
    		}
    		if (ctx.hierarchy === undefined && !('hierarchy' in props)) {
    			console.warn("<AccessLevelView> was created without expected prop 'hierarchy'");
    		}
    		if (ctx.actions === undefined && !('actions' in props)) {
    			console.warn("<AccessLevelView> was created without expected prop 'actions'");
    		}
    	}

    	get level() {
    		throw new Error("<AccessLevelView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set level(value) {
    		throw new Error("<AccessLevelView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get allPermissions() {
    		throw new Error("<AccessLevelView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set allPermissions(value) {
    		throw new Error("<AccessLevelView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onFinished() {
    		throw new Error("<AccessLevelView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onFinished(value) {
    		throw new Error("<AccessLevelView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isNew() {
    		throw new Error("<AccessLevelView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isNew(value) {
    		throw new Error("<AccessLevelView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get allLevels() {
    		throw new Error("<AccessLevelView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set allLevels(value) {
    		throw new Error("<AccessLevelView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hierarchy() {
    		throw new Error("<AccessLevelView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hierarchy(value) {
    		throw new Error("<AccessLevelView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get actions() {
    		throw new Error("<AccessLevelView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set actions(value) {
    		throw new Error("<AccessLevelView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\accessLevels\AccessLevelsRoot.svelte generated by Svelte v3.6.9 */

    const file$t = "src\\accessLevels\\AccessLevelsRoot.svelte";

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.level = list[i];
    	return child_ctx;
    }

    // (55:4) <Button grouped color="secondary" on:click={createNewLevel}>
    function create_default_slot_2$6(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Create New Access Level");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (54:0) <ButtonGroup>
    function create_default_slot_1$6(ctx) {
    	var current;

    	var button = new Button({
    		props: {
    		grouped: true,
    		color: "secondary",
    		$$slots: { default: [create_default_slot_2$6] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});
    	button.$on("click", ctx.createNewLevel);

    	return {
    		c: function create() {
    			button.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var button_changes = {};
    			if (changed.$$scope) button_changes.$$scope = { changed, ctx };
    			button.$set(button_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};
    }

    // (80:0) {:else}
    function create_else_block$7(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("(no actions added)");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		p: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (58:0) {#if $database.accessLevels}
    function create_if_block_1$6(ctx) {
    	var table, thead, tr, th0, t1, th1, t3, th2, t4, tbody;

    	var each_value = ctx.$database.accessLevels;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Name";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Permissions";
    			t3 = space();
    			th2 = element("th");
    			t4 = space();
    			tbody = element("tbody");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			add_location(th0, file$t, 61, 12, 1510);
    			add_location(th1, file$t, 62, 12, 1537);
    			add_location(th2, file$t, 63, 12, 1571);
    			add_location(tr, file$t, 60, 8, 1492);
    			add_location(thead, file$t, 59, 4, 1475);
    			add_location(tbody, file$t, 66, 4, 1615);
    			attr(table, "class", "fields-table uk-table uk-table-small");
    			add_location(table, file$t, 58, 0, 1417);
    		},

    		m: function mount(target, anchor) {
    			insert(target, table, anchor);
    			append(table, thead);
    			append(thead, tr);
    			append(tr, th0);
    			append(tr, t1);
    			append(tr, th1);
    			append(tr, t3);
    			append(tr, th2);
    			append(table, t4);
    			append(table, tbody);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (changed.getIcon || changed.getPermissionsString || changed.$database) {
    				each_value = ctx.$database.accessLevels;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$c(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$c(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(table);
    			}

    			destroy_each(each_blocks, detaching);
    		}
    	};
    }

    // (68:8) {#each $database.accessLevels as level}
    function create_each_block$c(ctx) {
    	var tr, td0, t0_value = ctx.level.name, t0, t1, td1, t2_value = ctx.getPermissionsString(ctx.level.permissions), t2, t3, td2, span0, raw0_value = getIcon("edit"), t4, span1, raw1_value = getIcon("trash"), t5, dispose;

    	function click_handler() {
    		return ctx.click_handler(ctx);
    	}

    	function click_handler_1() {
    		return ctx.click_handler_1(ctx);
    	}

    	return {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text(t2_value);
    			t3 = space();
    			td2 = element("td");
    			span0 = element("span");
    			t4 = space();
    			span1 = element("span");
    			t5 = space();
    			add_location(td0, file$t, 69, 12, 1699);
    			add_location(td1, file$t, 70, 12, 1735);
    			add_location(span0, file$t, 72, 16, 1842);
    			add_location(span1, file$t, 73, 16, 1932);
    			attr(td2, "class", "edit-button svelte-1be865r");
    			add_location(td2, file$t, 71, 12, 1800);
    			attr(tr, "class", "svelte-1be865r");
    			add_location(tr, file$t, 68, 8, 1681);

    			dispose = [
    				listen(span0, "click", click_handler),
    				listen(span1, "click", click_handler_1)
    			];
    		},

    		m: function mount(target, anchor) {
    			insert(target, tr, anchor);
    			append(tr, td0);
    			append(td0, t0);
    			append(tr, t1);
    			append(tr, td1);
    			append(td1, t2);
    			append(tr, t3);
    			append(tr, td2);
    			append(td2, span0);
    			span0.innerHTML = raw0_value;
    			append(td2, t4);
    			append(td2, span1);
    			span1.innerHTML = raw1_value;
    			append(tr, t5);
    		},

    		p: function update(changed, new_ctx) {
    			ctx = new_ctx;
    			if ((changed.$database) && t0_value !== (t0_value = ctx.level.name)) {
    				set_data(t0, t0_value);
    			}

    			if ((changed.$database) && t2_value !== (t2_value = ctx.getPermissionsString(ctx.level.permissions))) {
    				set_data(t2, t2_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(tr);
    			}

    			run_all(dispose);
    		}
    	};
    }

    // (86:4) {#if isEditing}
    function create_if_block$9(ctx) {
    	var current;

    	var accesslevelview = new AccessLevelView({
    		props: {
    		level: ctx.editingLevel,
    		allPermissions: ctx.allPermissions,
    		onFinished: ctx.onEditingFinished,
    		isNew: ctx.editingLevelIsNew,
    		allLevels: ctx.$database.accessLevels,
    		hierarchy: ctx.$database.hierarchy,
    		actions: ctx.$database.actions
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			accesslevelview.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(accesslevelview, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var accesslevelview_changes = {};
    			if (changed.editingLevel) accesslevelview_changes.level = ctx.editingLevel;
    			if (changed.allPermissions) accesslevelview_changes.allPermissions = ctx.allPermissions;
    			if (changed.onEditingFinished) accesslevelview_changes.onFinished = ctx.onEditingFinished;
    			if (changed.editingLevelIsNew) accesslevelview_changes.isNew = ctx.editingLevelIsNew;
    			if (changed.$database) accesslevelview_changes.allLevels = ctx.$database.accessLevels;
    			if (changed.$database) accesslevelview_changes.hierarchy = ctx.$database.hierarchy;
    			if (changed.$database) accesslevelview_changes.actions = ctx.$database.actions;
    			accesslevelview.$set(accesslevelview_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(accesslevelview.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(accesslevelview.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(accesslevelview, detaching);
    		}
    	};
    }

    // (85:0) <Modal bind:isOpen={isEditing}>
    function create_default_slot$9(ctx) {
    	var if_block_anchor, current;

    	var if_block = (ctx.isEditing) && create_if_block$9(ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.isEditing) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$9(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function create_fragment$s(ctx) {
    	var div, t0, t1, updating_isOpen, current;

    	var buttongroup = new ButtonGroup({
    		props: {
    		$$slots: { default: [create_default_slot_1$6] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});

    	function select_block_type(ctx) {
    		if (ctx.$database.accessLevels) return create_if_block_1$6;
    		return create_else_block$7;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(ctx);

    	function modal_isOpen_binding(value) {
    		ctx.modal_isOpen_binding.call(null, value);
    		updating_isOpen = true;
    		add_flush_callback(() => updating_isOpen = false);
    	}

    	let modal_props = {
    		$$slots: { default: [create_default_slot$9] },
    		$$scope: { ctx }
    	};
    	if (ctx.isEditing !== void 0) {
    		modal_props.isOpen = ctx.isEditing;
    	}
    	var modal = new Modal({ props: modal_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal, 'isOpen', modal_isOpen_binding));

    	return {
    		c: function create() {
    			div = element("div");
    			buttongroup.$$.fragment.c();
    			t0 = space();
    			if_block.c();
    			t1 = space();
    			modal.$$.fragment.c();
    			attr(div, "class", "root svelte-1be865r");
    			add_location(div, file$t, 51, 0, 1234);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			mount_component(buttongroup, div, null);
    			append(div, t0);
    			if_block.m(div, null);
    			append(div, t1);
    			mount_component(modal, div, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var buttongroup_changes = {};
    			if (changed.$$scope) buttongroup_changes.$$scope = { changed, ctx };
    			buttongroup.$set(buttongroup_changes);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);
    				if (if_block) {
    					if_block.c();
    					if_block.m(div, t1);
    				}
    			}

    			var modal_changes = {};
    			if (changed.$$scope || changed.isEditing || changed.editingLevel || changed.allPermissions || changed.editingLevelIsNew || changed.$database) modal_changes.$$scope = { changed, ctx };
    			if (!updating_isOpen && changed.isEditing) {
    				modal_changes.isOpen = ctx.isEditing;
    			}
    			modal.$set(modal_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(buttongroup.$$.fragment, local);

    			transition_in(modal.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(buttongroup.$$.fragment, local);
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			destroy_component(buttongroup);

    			if_block.d();

    			destroy_component(modal);
    		}
    	};
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let $database;

    	validate_store(database, 'database');
    	subscribe($$self, database, $$value => { $database = $$value; $$invalidate('$database', $database); });

    	

    let editingLevel = null;
    let editingLevelIsNew = false; 

    let allPermissions = [];
    database.subscribe(db => {
        $$invalidate('allPermissions', allPermissions = generateFullPermissions$1(db.hierarchy, db.actions));
    });

    let onLevelEdit = (level) => {
        $$invalidate('editingLevel', editingLevel = level);
        $$invalidate('editingLevelIsNew', editingLevelIsNew = false);
    };

    let onLevelDelete = (level) => {
        database.deleteLevel(level);
    };


    let createNewLevel = () => {
        $$invalidate('editingLevelIsNew', editingLevelIsNew = true);
        $$invalidate('editingLevel', editingLevel = getNewAccessLevel$1());
    };

    let onEditingFinished = (level) => {
        if(level) {
            database.saveLevel(level, editingLevelIsNew, editingLevel);
        }
        $$invalidate('editingLevel', editingLevel = null);
    };

    const getPermissionsString = perms => {
        return `${perms.length} / ${allPermissions.length}`;
    };

    	function click_handler({ level }) {
    		return onLevelEdit(level);
    	}

    	function click_handler_1({ level }) {
    		return onLevelDelete(level);
    	}

    	function modal_isOpen_binding(value) {
    		isEditing = value;
    		$$invalidate('isEditing', isEditing), $$invalidate('editingLevel', editingLevel);
    	}

    	let isEditing;

    	$$self.$$.update = ($$dirty = { editingLevel: 1 }) => {
    		if ($$dirty.editingLevel) { $$invalidate('isEditing', isEditing = (editingLevel !== null)); }
    	};

    	return {
    		editingLevel,
    		editingLevelIsNew,
    		allPermissions,
    		onLevelEdit,
    		onLevelDelete,
    		createNewLevel,
    		onEditingFinished,
    		getPermissionsString,
    		isEditing,
    		$database,
    		click_handler,
    		click_handler_1,
    		modal_isOpen_binding
    	};
    }

    class AccessLevelsRoot extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$s, safe_not_equal, []);
    	}
    }

    /* src\PackageRoot.svelte generated by Svelte v3.6.9 */

    const file$u = "src\\PackageRoot.svelte";

    // (27:55) 
    function create_if_block_3$2(ctx) {
    	var current;

    	var userinterface = new UserInterfaceRoot({ $$inline: true });

    	return {
    		c: function create() {
    			userinterface.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(userinterface, target, anchor);
    			current = true;
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(userinterface.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(userinterface.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(userinterface, detaching);
    		}
    	};
    }

    // (25:54) 
    function create_if_block_2$4(ctx) {
    	var current;

    	var accesslevels = new AccessLevelsRoot({ $$inline: true });

    	return {
    		c: function create() {
    			accesslevels.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(accesslevels, target, anchor);
    			current = true;
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(accesslevels.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(accesslevels.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(accesslevels, detaching);
    		}
    	};
    }

    // (23:48) 
    function create_if_block_1$7(ctx) {
    	var current;

    	var actionsandtriggers = new ActionsAndTriggersRoot({ $$inline: true });

    	return {
    		c: function create() {
    			actionsandtriggers.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(actionsandtriggers, target, anchor);
    			current = true;
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(actionsandtriggers.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(actionsandtriggers.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(actionsandtriggers, detaching);
    		}
    	};
    }

    // (21:4) {#if $database.activeNav === "database"}
    function create_if_block$a(ctx) {
    	var current;

    	var database_1 = new DatabaseRoot({ $$inline: true });

    	return {
    		c: function create() {
    			database_1.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(database_1, target, anchor);
    			current = true;
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(database_1.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(database_1.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(database_1, detaching);
    		}
    	};
    }

    function create_fragment$t(ctx) {
    	var div1, t, div0, current_block_type_index, if_block, current;

    	var nav = new Nav({
    		props: { width: ctx.navWidth },
    		$$inline: true
    	});

    	var if_block_creators = [
    		create_if_block$a,
    		create_if_block_1$7,
    		create_if_block_2$4,
    		create_if_block_3$2
    	];

    	var if_blocks = [];

    	function select_block_type(ctx) {
    		if (ctx.$database.activeNav === "database") return 0;
    		if (ctx.$database.activeNav === "actions") return 1;
    		if (ctx.$database.activeNav === "access levels") return 2;
    		if (ctx.$database.activeNav === "user interface") return 3;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	return {
    		c: function create() {
    			div1 = element("div");
    			nav.$$.fragment.c();
    			t = space();
    			div0 = element("div");
    			if (if_block) if_block.c();
    			attr(div0, "class", "content svelte-1rxbdcd");
    			set_style(div0, "width", "calc(100% - " + ctx.navWidth + ")");
    			set_style(div0, "left", ctx.navWidth);
    			add_location(div0, file$u, 18, 2, 532);
    			attr(div1, "class", "root svelte-1rxbdcd");
    			add_location(div1, file$u, 16, 0, 482);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div1, anchor);
    			mount_component(nav, div1, null);
    			append(div1, t);
    			append(div1, div0);
    			if (~current_block_type_index) if_blocks[current_block_type_index].m(div0, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var nav_changes = {};
    			if (changed.navWidth) nav_changes.width = ctx.navWidth;
    			nav.$set(nav_changes);

    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);
    			if (current_block_type_index !== previous_block_index) {
    				if (if_block) {
    					group_outros();
    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});
    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];
    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					}
    					transition_in(if_block, 1);
    					if_block.m(div0, null);
    				} else {
    					if_block = null;
    				}
    			}

    			if (!current || changed.navWidth) {
    				set_style(div0, "width", "calc(100% - " + ctx.navWidth + ")");
    				set_style(div0, "left", ctx.navWidth);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(nav.$$.fragment, local);

    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(nav.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div1);
    			}

    			destroy_component(nav);

    			if (~current_block_type_index) if_blocks[current_block_type_index].d();
    		}
    	};
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let $database;

    	validate_store(database, 'database');
    	subscribe($$self, database, $$value => { $database = $$value; $$invalidate('$database', $database); });

    	

    let { navWidth = "50px" } = $$props;

    	const writable_props = ['navWidth'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<PackageRoot> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('navWidth' in $$props) $$invalidate('navWidth', navWidth = $$props.navWidth);
    	};

    	return { navWidth, $database };
    }

    class PackageRoot extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$t, safe_not_equal, ["navWidth"]);
    	}

    	get navWidth() {
    		throw new Error("<PackageRoot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set navWidth(value) {
    		throw new Error("<PackageRoot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\App.svelte generated by Svelte v3.6.9 */

    const file$v = "src\\App.svelte";

    // (27:1) {:catch err}
    function create_catch_block(ctx) {
    	var h1, t_value = ctx.err, t;

    	return {
    		c: function create() {
    			h1 = element("h1");
    			t = text(t_value);
    			set_style(h1, "color", "red");
    			add_location(h1, file$v, 27, 2, 428);
    		},

    		m: function mount(target, anchor) {
    			insert(target, h1, anchor);
    			append(h1, t);
    		},

    		p: noop,
    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h1);
    			}
    		}
    	};
    }

    // (18:1) {:then result}
    function create_then_block(ctx) {
    	var t, if_block1_anchor, current;

    	var if_block0 = (ctx.$database.hasAppPackage) && create_if_block_1$8();

    	var if_block1 = (!ctx.$database.hasAppPackage) && create_if_block$b();

    	return {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert(target, if_block1_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.$database.hasAppPackage) {
    				if (!if_block0) {
    					if_block0 = create_if_block_1$8();
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				} else {
    									transition_in(if_block0, 1);
    				}
    			} else if (if_block0) {
    				group_outros();
    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});
    				check_outros();
    			}

    			if (!ctx.$database.hasAppPackage) {
    				if (!if_block1) {
    					if_block1 = create_if_block$b();
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				} else {
    									transition_in(if_block1, 1);
    				}
    			} else if (if_block1) {
    				group_outros();
    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);

    			if (detaching) {
    				detach(t);
    			}

    			if (if_block1) if_block1.d(detaching);

    			if (detaching) {
    				detach(if_block1_anchor);
    			}
    		}
    	};
    }

    // (19:2) {#if $database.hasAppPackage}
    function create_if_block_1$8(ctx) {
    	var current;

    	var packageroot = new PackageRoot({ $$inline: true });

    	return {
    		c: function create() {
    			packageroot.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(packageroot, target, anchor);
    			current = true;
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(packageroot.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(packageroot.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(packageroot, detaching);
    		}
    	};
    }

    // (23:2) {#if !$database.hasAppPackage}
    function create_if_block$b(ctx) {
    	var current;

    	var nopackage = new NoPackage({ $$inline: true });

    	return {
    		c: function create() {
    			nopackage.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(nopackage, target, anchor);
    			current = true;
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(nopackage.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(nopackage.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(nopackage, detaching);
    		}
    	};
    }

    // (14:14)      <h1>loading</h1>   {:then result}
    function create_pending_block(ctx) {
    	var h1;

    	return {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "loading";
    			add_location(h1, file$v, 15, 2, 261);
    		},

    		m: function mount(target, anchor) {
    			insert(target, h1, anchor);
    		},

    		p: noop,
    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h1);
    			}
    		}
    	};
    }

    function create_fragment$u(ctx) {
    	var main, promise, current;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		pending: create_pending_block,
    		then: create_then_block,
    		catch: create_catch_block,
    		value: 'result',
    		error: 'err',
    		blocks: [,,,]
    	};

    	handle_promise(promise = ctx.init, info);

    	return {
    		c: function create() {
    			main = element("main");

    			info.block.c();
    			attr(main, "class", "svelte-j8mzr7");
    			add_location(main, file$v, 11, 0, 234);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, main, anchor);

    			info.block.m(main, info.anchor = null);
    			info.mount = () => main;
    			info.anchor = null;

    			current = true;
    		},

    		p: function update(changed, new_ctx) {
    			ctx = new_ctx;
    			info.ctx = ctx;

    			if (promise !== (promise = ctx.init) && handle_promise(promise, info)) ; else {
    				info.block.p(changed, assign(assign({}, ctx), info.resolved));
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(info.block);
    			current = true;
    		},

    		o: function outro(local) {
    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(main);
    			}

    			info.block.d();
    			info.token = null;
    			info = null;
    		}
    	};
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let $database;

    	validate_store(database, 'database');
    	subscribe($$self, database, $$value => { $database = $$value; $$invalidate('$database', $database); });

    	
    	
    	let init = initialise$1();

    	return { init, $database };
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$u, safe_not_equal, []);
    	}
    }

    var uikit_min = createCommonjsModule(function (module, exports) {
    /*! UIkit 3.1.6 | http://www.getuikit.com | (c) 2014 - 2018 YOOtheme | MIT License */

    !function(t,e){module.exports=e();}(commonjsGlobal,function(){function l(n,i){return function(t){var e=arguments.length;return e?1<e?n.apply(i,arguments):n.call(i,t):n.call(i)}}var e=Object.prototype,n=e.hasOwnProperty;function c(t,e){return n.call(t,e)}var i={},r=/([a-z\d])([A-Z])/g;function d(t){return t in i||(i[t]=t.replace(r,"$1-$2").toLowerCase()),i[t]}var o=/-(\w)/g;function f(t){return t.replace(o,s)}function s(t,e){return e?e.toUpperCase():""}function p(t){return t.length?s(0,t.charAt(0))+t.slice(1):""}var t=String.prototype,a=t.startsWith||function(t){return 0===this.lastIndexOf(t,0)};function w(t,e){return a.call(t,e)}var h=t.endsWith||function(t){return this.substr(-t.length)===t};function u(t,e){return h.call(t,e)}function m(t,e){return ~this.indexOf(t,e)}var g=Array.prototype,v=t.includes||m,b=g.includes||m;function y(t,e){return t&&(D(t)?v:b).call(t,e)}var x=g.findIndex||function(t){for(var e=arguments,n=0;n<this.length;n++)if(t.call(e[1],this[n],n,this))return n;return -1};function k(t,e){return x.call(t,e)}var $=Array.isArray;function I(t){return "function"==typeof t}function S(t){return null!==t&&"object"==typeof t}function T(t){return S(t)&&Object.getPrototypeOf(t)===e}function E(t){return S(t)&&t===t.window}function A(t){return S(t)&&9===t.nodeType}function C(t){return S(t)&&!!t.jquery}function N(t){return t instanceof Node||S(t)&&1<=t.nodeType}var _=e.toString;function M(t){return _.call(t).match(/^\[object (NodeList|HTMLCollection)\]$/)}function O(t){return "boolean"==typeof t}function D(t){return "string"==typeof t}function B(t){return "number"==typeof t}function z(t){return B(t)||D(t)&&!isNaN(t-parseFloat(t))}function P(t){return !($(t)?t.length:S(t)&&Object.keys(t).length)}function H(t){return void 0===t}function L(t){return O(t)?t:"true"===t||"1"===t||""===t||"false"!==t&&"0"!==t&&t}function F(t){var e=Number(t);return !isNaN(e)&&e}function j(t){return parseFloat(t)||0}function W(t){return N(t)||E(t)||A(t)?t:M(t)||C(t)?t[0]:$(t)?W(t[0]):null}function V(t){return N(t)?[t]:M(t)?g.slice.call(t):$(t)?t.map(W).filter(Boolean):C(t)?t.toArray():[]}function Y(t){return $(t)?t:D(t)?t.split(/,(?![^(]*\))/).map(function(t){return z(t)?F(t):L(t.trim())}):[t]}function R(t){return t?u(t,"ms")?j(t):1e3*j(t):0}function q(t,n){return t===n||S(t)&&S(n)&&Object.keys(t).length===Object.keys(n).length&&K(t,function(t,e){return t===n[e]})}function U(t,e,n){return t.replace(new RegExp(e+"|"+n,"mg"),function(t){return t===e?n:e})}var X=Object.assign||function(t){for(var e=[],n=arguments.length-1;0<n--;)e[n]=arguments[n+1];t=Object(t);for(var i=0;i<e.length;i++){var r=e[i];if(null!==r)for(var o in r)c(r,o)&&(t[o]=r[o]);}return t};function K(t,e){for(var n in t)if(!1===e(t[n],n))return !1;return !0}function G(t,r){return t.sort(function(t,e){var n=t[r];void 0===n&&(n=0);var i=e[r];return void 0===i&&(i=0),i<n?1:n<i?-1:0})}function J(t,n){var i=new Set;return t.filter(function(t){var e=t[n];return !i.has(e)&&(i.add(e)||!0)})}function Z(t,e,n){return void 0===e&&(e=0),void 0===n&&(n=1),Math.min(Math.max(F(t)||0,e),n)}function Q(){}function tt(t,e){return t.left<e.right&&t.right>e.left&&t.top<e.bottom&&t.bottom>e.top}function et(t,e){return t.x<=e.right&&t.x>=e.left&&t.y<=e.bottom&&t.y>=e.top}var nt={ratio:function(t,e,n){var i,r="width"===e?"height":"width";return (i={})[r]=t[e]?Math.round(n*t[r]/t[e]):t[r],i[e]=n,i},contain:function(n,i){var r=this;return K(n=X({},n),function(t,e){return n=n[e]>i[e]?r.ratio(n,e,i[e]):n}),n},cover:function(n,i){var r=this;return K(n=this.contain(n,i),function(t,e){return n=n[e]<i[e]?r.ratio(n,e,i[e]):n}),n}};function it(t,e,n){if(S(e))for(var i in e)it(t,i,e[i]);else{if(H(n))return (t=W(t))&&t.getAttribute(e);V(t).forEach(function(t){I(n)&&(n=n.call(t,it(t,e))),null===n?ot(t,e):t.setAttribute(e,n);});}}function rt(t,e){return V(t).some(function(t){return t.hasAttribute(e)})}function ot(t,e){t=V(t),e.split(" ").forEach(function(e){return t.forEach(function(t){return t.hasAttribute(e)&&t.removeAttribute(e)})});}function st(t,e){for(var n=0,i=[e,"data-"+e];n<i.length;n++)if(rt(t,i[n]))return it(t,i[n])}function at(t,e){return W(t)||ut(t,ct(t,e))}function ht(t,e){var n=V(t);return n.length&&n||lt(t,ct(t,e))}function ct(t,e){return void 0===e&&(e=document),mt(t)||A(e)?e:e.ownerDocument}function ut(t,e){return W(dt(t,e,"querySelector"))}function lt(t,e){return V(dt(t,e,"querySelectorAll"))}function dt(t,s,e){if(void 0===s&&(s=document),!t||!D(t))return null;var a;mt(t=t.replace(pt,"$1 *"))&&(a=[],t=function(t){return t.match(gt).map(function(t){return t.replace(/,$/,"").trim()})}(t).map(function(t,e){var n=s;if("!"===t[0]){var i=t.substr(1).trim().split(" ");n=xt(s.parentNode,i[0]),t=i.slice(1).join(" ").trim();}if("-"===t[0]){var r=t.substr(1).trim().split(" "),o=(n||s).previousElementSibling;n=bt(o,t.substr(1))?o:null,t=r.slice(1).join(" ");}return n?(n.id||(n.id="uk-"+Date.now()+e,a.push(function(){return ot(n,"id")})),"#"+It(n.id)+" "+t):null}).filter(Boolean).join(","),s=document);try{return s[e](t)}catch(t){return null}finally{a&&a.forEach(function(t){return t()});}}var ft=/(^|[^\\],)\s*[!>+~-]/,pt=/([!>+~-])(?=\s+[!>+~-]|\s*$)/g;function mt(t){return D(t)&&t.match(ft)}var gt=/.*?[^\\](?:,|$)/g;var vt=Element.prototype,wt=vt.matches||vt.webkitMatchesSelector||vt.msMatchesSelector;function bt(t,e){return V(t).some(function(t){return wt.call(t,e)})}var yt=vt.closest||function(t){var e=this;do{if(bt(e,t))return e;e=e.parentNode;}while(e&&1===e.nodeType)};function xt(t,e){return w(e,">")&&(e=e.slice(1)),N(t)?t.parentNode&&yt.call(t,e):V(t).map(function(t){return xt(t,e)}).filter(Boolean)}function kt(t,e){for(var n=[],i=W(t).parentNode;i&&1===i.nodeType;)bt(i,e)&&n.push(i),i=i.parentNode;return n}var $t=window.CSS&&CSS.escape||function(t){return t.replace(/([^\x7f-\uFFFF\w-])/g,function(t){return "\\"+t})};function It(t){return D(t)?$t.call(null,t):""}var St={area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,menuitem:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0};function Tt(t){return V(t).some(function(t){return St[t.tagName.toLowerCase()]})}function Et(t){return V(t).some(function(t){return t.offsetWidth||t.offsetHeight||t.getClientRects().length})}var At="input,select,textarea,button";function Ct(t){return V(t).some(function(t){return bt(t,At)})}function Nt(t,e){return V(t).filter(function(t){return bt(t,e)})}function _t(t,e){return D(e)?bt(t,e)||xt(t,e):t===e||(A(e)?e.documentElement:W(e)).contains(W(t))}function Mt(){for(var t=[],e=arguments.length;e--;)t[e]=arguments[e];var n=Pt(t),i=n[0],r=n[1],o=n[2],s=n[3],a=n[4];return i=Ft(i),o&&(s=function(t,i,r){var o=this;return function(n){t.forEach(function(t){var e=">"===i[0]?lt(i,t).reverse().filter(function(t){return _t(n.target,t)})[0]:xt(n.target,i);e&&(n.delegate=t,n.current=e,r.call(o,n));});}}(i,o,s)),1<s.length&&(s=function(e){return function(t){return $(t.detail)?e.apply(void 0,[t].concat(t.detail)):e(t)}}(s)),r.split(" ").forEach(function(e){return i.forEach(function(t){return t.addEventListener(e,s,a)})}),function(){return Ot(i,r,s,a)}}function Ot(t,e,n,i){void 0===i&&(i=!1),t=Ft(t),e.split(" ").forEach(function(e){return t.forEach(function(t){return t.removeEventListener(e,n,i)})});}function Dt(){for(var t=[],e=arguments.length;e--;)t[e]=arguments[e];var n=Pt(t),i=n[0],r=n[1],o=n[2],s=n[3],a=n[4],h=n[5],c=Mt(i,r,o,function(t){var e=!h||h(t);e&&(c(),s(t,e));},a);return c}function Bt(t,n,i){return Ft(t).reduce(function(t,e){return t&&e.dispatchEvent(zt(n,!0,!0,i))},!0)}function zt(t,e,n,i){if(void 0===e&&(e=!0),void 0===n&&(n=!1),D(t)){var r=document.createEvent("CustomEvent");r.initCustomEvent(t,e,n,i),t=r;}return t}function Pt(t){return I(t[2])&&t.splice(2,0,!1),t}function Ht(t){return t&&"addEventListener"in t}function Lt(t){return Ht(t)?t:W(t)}function Ft(t){return $(t)?t.map(Lt).filter(Boolean):D(t)?lt(t):Ht(t)?[t]:V(t)}function jt(t){return "touch"===t.pointerType||t.touches}function Wt(t,e){void 0===e&&(e="client");var n=t.touches,i=t.changedTouches,r=n&&n[0]||i&&i[0]||t;return {x:r[e+"X"],y:r[e+"Y"]}}function Vt(){var n=this;this.promise=new Yt(function(t,e){n.reject=e,n.resolve=t;});}var Yt="Promise"in window?window.Promise:Ut,Rt=2,qt="setImmediate"in window?setImmediate:setTimeout;function Ut(t){this.state=Rt,this.value=void 0,this.deferred=[];var e=this;try{t(function(t){e.resolve(t);},function(t){e.reject(t);});}catch(t){e.reject(t);}}Ut.reject=function(n){return new Ut(function(t,e){e(n);})},Ut.resolve=function(n){return new Ut(function(t,e){t(n);})},Ut.all=function(s){return new Ut(function(n,t){var i=[],r=0;function e(e){return function(t){i[e]=t,(r+=1)===s.length&&n(i);}}0===s.length&&n(i);for(var o=0;o<s.length;o+=1)Ut.resolve(s[o]).then(e(o),t);})},Ut.race=function(i){return new Ut(function(t,e){for(var n=0;n<i.length;n+=1)Ut.resolve(i[n]).then(t,e);})};var Xt=Ut.prototype;function Kt(s,a){return new Yt(function(t,e){var n=X({data:null,method:"GET",headers:{},xhr:new XMLHttpRequest,beforeSend:Q,responseType:""},a);n.beforeSend(n);var i=n.xhr;for(var r in n)if(r in i)try{i[r]=n[r];}catch(t){}for(var o in i.open(n.method.toUpperCase(),s),n.headers)i.setRequestHeader(o,n.headers[o]);Mt(i,"load",function(){0===i.status||200<=i.status&&i.status<300||304===i.status?t(i):e(X(Error(i.statusText),{xhr:i,status:i.status}));}),Mt(i,"error",function(){return e(X(Error("Network Error"),{xhr:i}))}),Mt(i,"timeout",function(){return e(X(Error("Network Timeout"),{xhr:i}))}),i.send(n.data);})}function Gt(i,r,o){return new Yt(function(t,e){var n=new Image;n.onerror=e,n.onload=function(){return t(n)},o&&(n.sizes=o),r&&(n.srcset=r),n.src=i;})}Xt.resolve=function(t){var e=this;if(e.state===Rt){if(t===e)throw new TypeError("Promise settled with itself.");var n=!1;try{var i=t&&t.then;if(null!==t&&S(t)&&I(i))return void i.call(t,function(t){n||e.resolve(t),n=!0;},function(t){n||e.reject(t),n=!0;})}catch(t){return void(n||e.reject(t))}e.state=0,e.value=t,e.notify();}},Xt.reject=function(t){var e=this;if(e.state===Rt){if(t===e)throw new TypeError("Promise settled with itself.");e.state=1,e.value=t,e.notify();}},Xt.notify=function(){var o=this;qt(function(){if(o.state!==Rt)for(;o.deferred.length;){var t=o.deferred.shift(),e=t[0],n=t[1],i=t[2],r=t[3];try{0===o.state?I(e)?i(e.call(void 0,o.value)):i(o.value):1===o.state&&(I(n)?i(n.call(void 0,o.value)):r(o.value));}catch(t){r(t);}}});},Xt.then=function(n,i){var r=this;return new Ut(function(t,e){r.deferred.push([n,i,t,e]),r.notify();})},Xt.catch=function(t){return this.then(void 0,t)};var Jt=/msie|trident/i.test(window.navigator.userAgent),Zt="rtl"===it(document.documentElement,"dir"),Qt="ontouchstart"in window,te=window.PointerEvent,ee=Qt||window.DocumentTouch&&document instanceof DocumentTouch||navigator.maxTouchPoints,ne=te?"pointerdown":Qt?"touchstart":"mousedown",ie=te?"pointermove":Qt?"touchmove":"mousemove",re=te?"pointerup":Qt?"touchend":"mouseup",oe=te?"pointerenter":Qt?"":"mouseenter",se=te?"pointerleave":Qt?"":"mouseleave",ae=te?"pointercancel":"touchcancel";function he(t){if("loading"===document.readyState)var e=Mt(document,"DOMContentLoaded",function(){e(),t();});else t();}function ce(t,e){return e?V(t).indexOf(W(e)):V((t=W(t))&&t.parentNode.children).indexOf(t)}function ue(t,e,n,i){void 0===n&&(n=0),void 0===i&&(i=!1);var r=(e=V(e)).length;return t=z(t)?F(t):"next"===t?n+1:"previous"===t?n-1:ce(e,t),i?Z(t,0,r-1):(t%=r)<0?t+r:t}function le(t){return (t=Se(t)).innerHTML="",t}function de(t,e){return t=Se(t),H(e)?t.innerHTML:fe(t.hasChildNodes()?le(t):t,e)}function fe(e,t){return e=Se(e),ge(t,function(t){return e.appendChild(t)})}function pe(e,t){return e=Se(e),ge(t,function(t){return e.parentNode.insertBefore(t,e)})}function me(e,t){return e=Se(e),ge(t,function(t){return e.nextSibling?pe(e.nextSibling,t):fe(e.parentNode,t)})}function ge(t,e){return (t=D(t)?$e(t):t)?"length"in t?V(t).map(e):e(t):null}function ve(t){V(t).map(function(t){return t.parentNode&&t.parentNode.removeChild(t)});}function we(t,e){for(e=W(pe(t,e));e.firstChild;)e=e.firstChild;return fe(e,t),e}function be(t,e){return V(V(t).map(function(t){return t.hasChildNodes?we(V(t.childNodes),e):fe(t,e)}))}function ye(t){V(t).map(function(t){return t.parentNode}).filter(function(t,e,n){return n.indexOf(t)===e}).forEach(function(t){pe(t,t.childNodes),ve(t);});}var xe=/^\s*<(\w+|!)[^>]*>/,ke=/^<(\w+)\s*\/?>(?:<\/\1>)?$/;function $e(t){var e=ke.exec(t);if(e)return document.createElement(e[1]);var n=document.createElement("div");return xe.test(t)?n.insertAdjacentHTML("beforeend",t.trim()):n.textContent=t,1<n.childNodes.length?V(n.childNodes):n.firstChild}function Ie(t,e){if(t&&1===t.nodeType)for(e(t),t=t.firstElementChild;t;)Ie(t,e),t=t.nextElementSibling;}function Se(t,e){return D(t)?Ee(t)?W($e(t)):ut(t,e):W(t)}function Te(t,e){return D(t)?Ee(t)?V($e(t)):lt(t,e):V(t)}function Ee(t){return "<"===t[0]||t.match(/^\s*</)}function Ae(t){for(var e=[],n=arguments.length-1;0<n--;)e[n]=arguments[n+1];De(t,e,"add");}function Ce(t){for(var e=[],n=arguments.length-1;0<n--;)e[n]=arguments[n+1];De(t,e,"remove");}function Ne(t,e){it(t,"class",function(t){return (t||"").replace(new RegExp("\\b"+e+"\\b","g"),"")});}function _e(t){for(var e=[],n=arguments.length-1;0<n--;)e[n]=arguments[n+1];e[0]&&Ce(t,e[0]),e[1]&&Ae(t,e[1]);}function Me(t,e){return e&&V(t).some(function(t){return t.classList.contains(e.split(" ")[0])})}function Oe(t){for(var i=[],e=arguments.length-1;0<e--;)i[e]=arguments[e+1];if(i.length){var r=D((i=Be(i))[i.length-1])?[]:i.pop();i=i.filter(Boolean),V(t).forEach(function(t){for(var e=t.classList,n=0;n<i.length;n++)ze.Force?e.toggle.apply(e,[i[n]].concat(r)):e[(H(r)?!e.contains(i[n]):r)?"add":"remove"](i[n]);});}}function De(t,n,i){(n=Be(n).filter(Boolean)).length&&V(t).forEach(function(t){var e=t.classList;ze.Multiple?e[i].apply(e,n):n.forEach(function(t){return e[i](t)});});}function Be(t){return t.reduce(function(t,e){return t.concat.call(t,D(e)&&y(e," ")?e.trim().split(" "):e)},[])}var ze={get Multiple(){return this.get("_multiple")},get Force(){return this.get("_force")},get:function(t){if(!c(this,t)){var e=document.createElement("_").classList;e.add("a","b"),e.toggle("c",!1),this._multiple=e.contains("b"),this._force=!e.contains("c");}return this[t]}},Pe={"animation-iteration-count":!0,"column-count":!0,"fill-opacity":!0,"flex-grow":!0,"flex-shrink":!0,"font-weight":!0,"line-height":!0,opacity:!0,order:!0,orphans:!0,"stroke-dasharray":!0,"stroke-dashoffset":!0,widows:!0,"z-index":!0,zoom:!0};function He(t,e,r){return V(t).map(function(n){if(D(e)){if(e=Ye(e),H(r))return Fe(n,e);r||B(r)?n.style[e]=z(r)&&!Pe[e]?r+"px":r:n.style.removeProperty(e);}else{if($(e)){var i=Le(n);return e.reduce(function(t,e){return t[e]=i[Ye(e)],t},{})}S(e)&&K(e,function(t,e){return He(n,e,t)});}return n})[0]}function Le(t,e){return (t=W(t)).ownerDocument.defaultView.getComputedStyle(t,e)}function Fe(t,e,n){return Le(t,n)[e]}var je={};function We(t){var e=document.documentElement;if(!Jt)return Le(e).getPropertyValue("--uk-"+t);if(!(t in je)){var n=fe(e,document.createElement("div"));Ae(n,"uk-"+t),je[t]=Fe(n,"content",":before").replace(/^["'](.*)["']$/,"$1"),ve(n);}return je[t]}var Ve={};function Ye(t){var e=Ve[t];return e=e||(Ve[t]=function(t){t=d(t);var e=document.documentElement.style;if(t in e)return t;var n,i=Re.length;for(;i--;)if((n="-"+Re[i]+"-"+t)in e)return n}(t)||t)}var Re=["webkit","moz","ms"];function qe(t,s,a,h){return void 0===a&&(a=400),void 0===h&&(h="linear"),Yt.all(V(t).map(function(o){return new Yt(function(n,i){for(var t in s){var e=He(o,t);""===e&&He(o,t,e);}var r=setTimeout(function(){return Bt(o,"transitionend")},a);Dt(o,"transitionend transitioncanceled",function(t){var e=t.type;clearTimeout(r),Ce(o,"uk-transition"),He(o,{"transition-property":"","transition-duration":"","transition-timing-function":""}),"transitioncanceled"===e?i():n();},!1,function(t){var e=t.target;return o===e}),Ae(o,"uk-transition"),He(o,X({"transition-property":Object.keys(s).map(Ye).join(","),"transition-duration":a+"ms","transition-timing-function":h},s));})}))}var Ue={start:qe,stop:function(t){return Bt(t,"transitionend"),Yt.resolve()},cancel:function(t){Bt(t,"transitioncanceled");},inProgress:function(t){return Me(t,"uk-transition")}},Xe="uk-animation-",Ke="uk-cancel-animation";function Ge(t,e,n,a,h){var c=arguments;return void 0===n&&(n=200),Yt.all(V(t).map(function(s){return new Yt(function(i,r){if(Me(s,Ke))requestAnimationFrame(function(){return Yt.resolve().then(function(){return Ge.apply(void 0,c).then(i,r)})});else{var t=e+" "+Xe+(h?"leave":"enter");w(e,Xe)&&(a&&(t+=" uk-transform-origin-"+a),h&&(t+=" "+Xe+"reverse")),o(),Dt(s,"animationend animationcancel",function(t){var e=t.type,n=!1;"animationcancel"===e?(r(),o()):(i(),Yt.resolve().then(function(){n=!0,o();})),requestAnimationFrame(function(){n||(Ae(s,Ke),requestAnimationFrame(function(){return Ce(s,Ke)}));});},!1,function(t){var e=t.target;return s===e}),He(s,"animationDuration",n+"ms"),Ae(s,t);}function o(){He(s,"animationDuration",""),Ne(s,Xe+"\\S*");}})}))}var Je=new RegExp(Xe+"(enter|leave)"),Ze={in:function(t,e,n,i){return Ge(t,e,n,i,!1)},out:function(t,e,n,i){return Ge(t,e,n,i,!0)},inProgress:function(t){return Je.test(it(t,"class"))},cancel:function(t){Bt(t,"animationcancel");}},Qe={width:["x","left","right"],height:["y","top","bottom"]};function tn(t,e,u,l,d,n,i,r){u=un(u),l=un(l);var f={element:u,target:l};if(!t||!e)return f;var p=nn(t),m=nn(e),g=m;if(cn(g,u,p,-1),cn(g,l,m,1),d=ln(d,p.width,p.height),n=ln(n,m.width,m.height),d.x+=n.x,d.y+=n.y,g.left+=d.x,g.top+=d.y,i){var o=[nn(bn(t))];r&&o.unshift(nn(r)),K(Qe,function(t,s){var a=t[0],h=t[1],c=t[2];!0!==i&&!y(i,a)||o.some(function(i){var t=u[a]===h?-p[s]:u[a]===c?p[s]:0,e=l[a]===h?m[s]:l[a]===c?-m[s]:0;if(g[h]<i[h]||g[h]+p[s]>i[c]){var n=p[s]/2,r="center"===l[a]?-m[s]/2:0;return "center"===u[a]&&(o(n,r)||o(-n,-r))||o(t,e)}function o(e,t){var n=g[h]+e+t-2*d[a];if(n>=i[h]&&n+p[s]<=i[c])return g[h]=n,["element","target"].forEach(function(t){f[t][a]=e?f[t][a]===Qe[s][1]?Qe[s][2]:Qe[s][1]:f[t][a];}),!0}});});}return en(t,g),f}function en(n,i){if(n=W(n),!i)return nn(n);var r=en(n),o=He(n,"position");["left","top"].forEach(function(t){if(t in i){var e=He(n,t);He(n,t,i[t]-r[t]+j("absolute"===o&&"auto"===e?rn(n)[t]:e));}});}function nn(t){var e,n,i=bn(t=W(t)),r=i.pageYOffset,o=i.pageXOffset;if(E(t)){var s=t.innerHeight,a=t.innerWidth;return {top:r,left:o,height:s,width:a,bottom:r+s,right:o+a}}Et(t)||"none"!==He(t,"display")||(e=it(t,"style"),n=it(t,"hidden"),it(t,{style:(e||"")+";display:block !important;",hidden:null}));var h=t.getBoundingClientRect();return H(e)||it(t,{style:e,hidden:n}),{height:h.height,width:h.width,top:h.top+r,left:h.left+o,bottom:h.bottom+r,right:h.right+o}}function rn(i){var r=(i=W(i)).offsetParent||function(t){return yn(t).documentElement}(i),o=en(r),t=["top","left"].reduce(function(t,e){var n=p(e);return t[e]-=o[e]+j(He(i,"margin"+n))+j(He(r,"border"+n+"Width")),t},en(i));return {top:t.top,left:t.left}}var on=an("height"),sn=an("width");function an(i){var r=p(i);return function(t,e){if(t=W(t),H(e)){if(E(t))return t["inner"+r];if(A(t)){var n=t.documentElement;return Math.max(n["offset"+r],n["scroll"+r])}return (e="auto"===(e=He(t,i))?t["offset"+r]:j(e)||0)-hn(i,t)}He(t,i,e||0===e?+e+hn(i,t)+"px":"");}}function hn(t,n,e){return void 0===e&&(e="border-box"),He(n,"boxSizing")===e?Qe[t].slice(1).map(p).reduce(function(t,e){return t+j(He(n,"padding"+e))+j(He(n,"border"+e+"Width"))},0):0}function cn(o,s,a,h){K(Qe,function(t,e){var n=t[0],i=t[1],r=t[2];s[n]===r?o[i]+=a[e]*h:"center"===s[n]&&(o[i]+=a[e]*h/2);});}function un(t){var e=/left|center|right/,n=/top|center|bottom/;return 1===(t=(t||"").split(" ")).length&&(t=e.test(t[0])?t.concat(["center"]):n.test(t[0])?["center"].concat(t):["center","center"]),{x:e.test(t[0])?t[0]:"center",y:n.test(t[1])?t[1]:"center"}}function ln(t,e,n){var i=(t||"").split(" "),r=i[0],o=i[1];return {x:r?j(r)*(u(r,"%")?e/100:1):0,y:o?j(o)*(u(o,"%")?n/100:1):0}}function dn(t){switch(t){case"left":return "right";case"right":return "left";case"top":return "bottom";case"bottom":return "top";default:return t}}function fn(t,e,n){if(void 0===e&&(e=0),void 0===n&&(n=0),!Et(t))return !1;var i=bn(t=W(t)),r=t.getBoundingClientRect(),o={top:-e,left:-n,bottom:e+on(i),right:n+sn(i)};return tt(r,o)||et({x:r.left,y:r.top},o)}function pn(t,e){if(void 0===e&&(e=0),!Et(t))return 0;var n=bn(t=W(t)),i=yn(t),r=t.offsetHeight+e,o=gn(t)[0],s=on(n),a=s+Math.min(0,o-s),h=Math.max(0,s-(on(i)+e-(o+r)));return Z((a+n.pageYOffset-o)/((a+(r-(h<s?h:0)))/100)/100)}function mn(t,e){if(E(t=W(t))||A(t)){var n=bn(t);(0, n.scrollTo)(n.pageXOffset,e);}else t.scrollTop=e;}function gn(t){var e=[0,0];do{if(e[0]+=t.offsetTop,e[1]+=t.offsetLeft,"fixed"===He(t,"position")){var n=bn(t);return e[0]+=n.pageYOffset,e[1]+=n.pageXOffset,e}}while(t=t.offsetParent);return e}function vn(t,e,n){return void 0===e&&(e="width"),void 0===n&&(n=window),z(t)?+t:u(t,"vh")?wn(on(bn(n)),t):u(t,"vw")?wn(sn(bn(n)),t):u(t,"%")?wn(nn(n)[e],t):j(t)}function wn(t,e){return t*j(e)/100}function bn(t){return E(t)?t:yn(t).defaultView}function yn(t){return W(t).ownerDocument}var xn={reads:[],writes:[],read:function(t){return this.reads.push(t),$n(),t},write:function(t){return this.writes.push(t),$n(),t},clear:function(t){return Sn(this.reads,t)||Sn(this.writes,t)},flush:kn};function kn(){In(xn.reads),In(xn.writes.splice(0,xn.writes.length)),xn.scheduled=!1,(xn.reads.length||xn.writes.length)&&$n(!0);}function $n(t){void 0===t&&(t=!1),xn.scheduled||(xn.scheduled=!0,t?Yt.resolve().then(kn):requestAnimationFrame(kn));}function In(t){for(var e;e=t.shift();)e();}function Sn(t,e){var n=t.indexOf(e);return !!~n&&!!t.splice(n,1)}function Tn(){}function En(t,e){return (e.y-t.y)/(e.x-t.x)}Tn.prototype={positions:[],position:null,init:function(){var i=this;this.positions=[],this.position=null;var r=!1;this.unbind=Mt(document,"mousemove",function(n){r||(setTimeout(function(){var t=Date.now(),e=i.positions.length;e&&100<t-i.positions[e-1].time&&i.positions.splice(0,e),i.positions.push({time:t,x:n.pageX,y:n.pageY}),5<i.positions.length&&i.positions.shift(),r=!1;},5),r=!0);});},cancel:function(){this.unbind&&this.unbind();},movesTo:function(t){if(this.positions.length<2)return !1;var e=en(t),n=this.positions[this.positions.length-1],i=this.positions[0];if(e.left<=n.x&&n.x<=e.right&&e.top<=n.y&&n.y<=e.bottom)return !1;var r=[[{x:e.left,y:e.top},{x:e.right,y:e.bottom}],[{x:e.right,y:e.top},{x:e.left,y:e.bottom}]];return e.right<=n.x||(e.left>=n.x?(r[0].reverse(),r[1].reverse()):e.bottom<=n.y?r[0].reverse():e.top>=n.y&&r[1].reverse()),!!r.reduce(function(t,e){return t+(En(i,e[0])<En(n,e[0])&&En(i,e[1])>En(n,e[1]))},0)}};var An={};function Cn(t,e,n){return An.computed(I(t)?t.call(n,n):t,I(e)?e.call(n,n):e)}function Nn(t,e){return t=t&&!$(t)?[t]:t,e?t?t.concat(e):$(e)?e:[e]:t}function _n(e,n,i){var r={};if(I(n)&&(n=n.options),n.extends&&(e=_n(e,n.extends,i)),n.mixins)for(var t=0,o=n.mixins.length;t<o;t++)e=_n(e,n.mixins[t],i);for(var s in e)h(s);for(var a in n)c(e,a)||h(a);function h(t){r[t]=(An[t]||function(t,e){return H(e)?t:e})(e[t],n[t],i);}return r}function Mn(t,e){var n;void 0===e&&(e=[]);try{return t?w(t,"{")?JSON.parse(t):e.length&&!y(t,":")?((n={})[e[0]]=t,n):t.split(";").reduce(function(t,e){var n=e.split(/:(.*)/),i=n[0],r=n[1];return i&&!H(r)&&(t[i.trim()]=r.trim()),t},{}):{}}catch(t){return {}}}An.events=An.created=An.beforeConnect=An.connected=An.beforeDisconnect=An.disconnected=An.destroy=Nn,An.args=function(t,e){return !1!==e&&Nn(e||t)},An.update=function(t,e){return G(Nn(t,I(e)?{read:e}:e),"order")},An.props=function(t,e){return $(e)&&(e=e.reduce(function(t,e){return t[e]=String,t},{})),An.methods(t,e)},An.computed=An.methods=function(t,e){return e?t?X({},t,e):e:t},An.data=function(e,n,t){return t?Cn(e,n,t):n?e?function(t){return Cn(e,n,t)}:n:e};function On(t){this.id=++Dn,this.el=W(t);}var Dn=0;function Bn(t,e){try{t.contentWindow.postMessage(JSON.stringify(X({event:"command"},e)),"*");}catch(t){}}On.prototype.isVideo=function(){return this.isYoutube()||this.isVimeo()||this.isHTML5()},On.prototype.isHTML5=function(){return "VIDEO"===this.el.tagName},On.prototype.isIFrame=function(){return "IFRAME"===this.el.tagName},On.prototype.isYoutube=function(){return this.isIFrame()&&!!this.el.src.match(/\/\/.*?youtube(-nocookie)?\.[a-z]+\/(watch\?v=[^&\s]+|embed)|youtu\.be\/.*/)},On.prototype.isVimeo=function(){return this.isIFrame()&&!!this.el.src.match(/vimeo\.com\/video\/.*/)},On.prototype.enableApi=function(){var e=this;if(this.ready)return this.ready;var n,i=this.isYoutube(),r=this.isVimeo();return i||r?this.ready=new Yt(function(t){Dt(e.el,"load",function(){if(i){var t=function(){return Bn(e.el,{event:"listening",id:e.id})};n=setInterval(t,100),t();}}),function(i){return new Yt(function(n){Dt(window,"message",function(t,e){return n(e)},!1,function(t){var e=t.data;if(e&&D(e)){try{e=JSON.parse(e);}catch(t){return}return e&&i(e)}});})}(function(t){return i&&t.id===e.id&&"onReady"===t.event||r&&Number(t.player_id)===e.id}).then(function(){t(),n&&clearInterval(n);}),it(e.el,"src",e.el.src+(y(e.el.src,"?")?"&":"?")+(i?"enablejsapi=1":"api=1&player_id="+e.id));}):Yt.resolve()},On.prototype.play=function(){var t=this;if(this.isVideo())if(this.isIFrame())this.enableApi().then(function(){return Bn(t.el,{func:"playVideo",method:"play"})});else if(this.isHTML5())try{var e=this.el.play();e&&e.catch(Q);}catch(t){}},On.prototype.pause=function(){var t=this;this.isVideo()&&(this.isIFrame()?this.enableApi().then(function(){return Bn(t.el,{func:"pauseVideo",method:"pause"})}):this.isHTML5()&&this.el.pause());},On.prototype.mute=function(){var t=this;this.isVideo()&&(this.isIFrame()?this.enableApi().then(function(){return Bn(t.el,{func:"mute",method:"setVolume",value:0})}):this.isHTML5()&&(this.el.muted=!0,it(this.el,"muted","")));};var zn="IntersectionObserver"in window?window.IntersectionObserver:function(){function t(e,t){var n=this;void 0===t&&(t={});var i=t.rootMargin;void 0===i&&(i="0 0"),this.targets=[];var r,o=(i||"0 0").split(" ").map(j),s=o[0],a=o[1];this.offsetTop=s,this.offsetLeft=a,this.apply=function(){r=r||requestAnimationFrame(function(){return setTimeout(function(){var t=n.takeRecords();t.length&&e(t,n),r=!1;})});},this.off=Mt(window,"scroll resize load",this.apply,{passive:!0,capture:!0});}return t.prototype.takeRecords=function(){var n=this;return this.targets.filter(function(t){var e=fn(t.target,n.offsetTop,n.offsetLeft);if(null===t.isIntersecting||e^t.isIntersecting)return t.isIntersecting=e,!0})},t.prototype.observe=function(t){this.targets.push({target:t,isIntersecting:null}),this.apply();},t.prototype.disconnect=function(){this.targets=[],this.off();},t}();function Pn(t){return !(!w(t,"uk-")&&!w(t,"data-uk-"))&&f(t.replace("data-uk-","").replace("uk-",""))}function Hn(t){this._init(t);}var Ln,Fn,jn,Wn,Vn,Yn,Rn,qn,Un;function Xn(t,e){if(t)for(var n in t)t[n]._connected&&t[n]._callUpdate(e);}function Kn(t,e){var n={},i=t.args;void 0===i&&(i=[]);var r=t.props;void 0===r&&(r={});var o=t.el;if(!r)return n;for(var s in r){var a=d(s),h=st(o,a);if(!H(h)){if(h=r[s]===Boolean&&""===h||Qn(r[s],h),"target"===a&&(!h||w(h,"_")))continue;n[s]=h;}}var c=Mn(st(o,e),i);for(var u in c){var l=f(u);void 0!==r[l]&&(n[l]=Qn(r[l],c[u]));}return n}function Gn(i,r,o){Object.defineProperty(i,r,{enumerable:!0,get:function(){var t=i._computeds,e=i.$props,n=i.$el;return c(t,r)||(t[r]=(o.get||o).call(i,e,n)),t[r]},set:function(t){var e=i._computeds;e[r]=o.set?o.set.call(i,t):t,H(e[r])&&delete e[r];}});}function Jn(e,n,i){T(n)||(n={name:i,handler:n});var t=n.name,r=n.el,o=n.handler,s=n.capture,a=n.passive,h=n.delegate,c=n.filter,u=n.self;r=I(r)?r.call(e):r||e.$el,$(r)?r.forEach(function(t){return Jn(e,X({},n,{el:t}),i)}):!r||c&&!c.call(e)||(o=function(e){return function(t){return $(t.detail)?e.apply(void 0,[t].concat(t.detail)):e(t)}}(D(o)?e[o]:l(o,e)),u&&(o=function(e){return function(t){if(t.target===t.currentTarget||t.target===t.current)return e.call(null,t)}}(o)),e._events.push(Mt(r,t,h?D(h)?h:h.call(e):null,o,O(a)?{passive:a,capture:s}:s)));}function Zn(t,e){return t.every(function(t){return !t||!c(t,e)})}function Qn(t,e){return t===Boolean?L(e):t===Number?F(e):"list"===t?Y(e):t?t(e):e}Hn.util=Object.freeze({ajax:Kt,getImage:Gt,transition:qe,Transition:Ue,animate:Ge,Animation:Ze,attr:it,hasAttr:rt,removeAttr:ot,data:st,addClass:Ae,removeClass:Ce,removeClasses:Ne,replaceClass:_e,hasClass:Me,toggleClass:Oe,positionAt:tn,offset:en,position:rn,height:on,width:sn,boxModelAdjust:hn,flipPosition:dn,isInView:fn,scrolledOver:pn,scrollTop:mn,offsetPosition:gn,toPx:vn,ready:he,index:ce,getIndex:ue,empty:le,html:de,prepend:function(e,t){return (e=Se(e)).hasChildNodes()?ge(t,function(t){return e.insertBefore(t,e.firstChild)}):fe(e,t)},append:fe,before:pe,after:me,remove:ve,wrapAll:we,wrapInner:be,unwrap:ye,fragment:$e,apply:Ie,$:Se,$$:Te,isIE:Jt,isRtl:Zt,hasTouch:ee,pointerDown:ne,pointerMove:ie,pointerUp:re,pointerEnter:oe,pointerLeave:se,pointerCancel:ae,on:Mt,off:Ot,once:Dt,trigger:Bt,createEvent:zt,toEventTargets:Ft,isTouch:jt,getEventPos:Wt,fastdom:xn,isVoidElement:Tt,isVisible:Et,selInput:At,isInput:Ct,filter:Nt,within:_t,bind:l,hasOwn:c,hyphenate:d,camelize:f,ucfirst:p,startsWith:w,endsWith:u,includes:y,findIndex:k,isArray:$,isFunction:I,isObject:S,isPlainObject:T,isWindow:E,isDocument:A,isJQuery:C,isNode:N,isNodeCollection:M,isBoolean:O,isString:D,isNumber:B,isNumeric:z,isEmpty:P,isUndefined:H,toBoolean:L,toNumber:F,toFloat:j,toNode:W,toNodes:V,toList:Y,toMs:R,isEqual:q,swap:U,assign:X,each:K,sortBy:G,uniqueBy:J,clamp:Z,noop:Q,intersectRect:tt,pointInRect:et,Dimensions:nt,MouseTracker:Tn,mergeOptions:_n,parseOptions:Mn,Player:On,Promise:Yt,Deferred:Vt,IntersectionObserver:zn,query:at,queryAll:ht,find:ut,findAll:lt,matches:bt,closest:xt,parents:kt,escape:It,css:He,getStyles:Le,getStyle:Fe,getCssVar:We,propName:Ye}),Hn.data="__uikit__",Hn.prefix="uk-",Hn.options={},jn=(Ln=Hn).data,Ln.use=function(t){if(!t.installed)return t.call(null,this),t.installed=!0,this},Ln.mixin=function(t,e){(e=(D(e)?Ln.component(e):e)||this).options=_n(e.options,t);},Ln.extend=function(t){function e(t){this._init(t);}return t=t||{},((e.prototype=Object.create(this.prototype)).constructor=e).options=_n(this.options,t),e.super=this,e.extend=this.extend,e},Ln.update=function(t,e){(function t(e,n){e&&e!==document.body&&e.parentNode&&(t(e.parentNode,n),n(e.parentNode));})(t=t?W(t):document.body,function(t){return Xn(t[jn],e)}),Ie(t,function(t){return Xn(t[jn],e)});},Object.defineProperty(Ln,"container",{get:function(){return Fn||document.body},set:function(t){Fn=Se(t);}}),(Wn=Hn).prototype._callHook=function(t){var e=this,n=this.$options[t];n&&n.forEach(function(t){return t.call(e)});},Wn.prototype._callConnected=function(){this._connected||(this._data={},this._computeds={},this._initProps(),this._callHook("beforeConnect"),this._connected=!0,this._initEvents(),this._initObserver(),this._callHook("connected"),this._callUpdate());},Wn.prototype._callDisconnected=function(){this._connected&&(this._callHook("beforeDisconnect"),this._observer&&(this._observer.disconnect(),this._observer=null),this._unbindEvents(),this._callHook("disconnected"),this._connected=!1);},Wn.prototype._callUpdate=function(t){var o=this;void 0===t&&(t="update");var s=t.type||t;y(["update","resize"],s)&&this._callWatches();var e=this.$options.update,n=this._frames,a=n.reads,h=n.writes;e&&e.forEach(function(t,e){var n=t.read,i=t.write,r=t.events;"update"!==s&&!y(r,s)||(n&&!y(xn.reads,a[e])&&(a[e]=xn.read(function(){var t=o._connected&&n.call(o,o._data,s);!1===t&&i?xn.clear(h[e]):T(t)&&X(o._data,t);})),i&&!y(xn.writes,h[e])&&(h[e]=xn.write(function(){return o._connected&&i.call(o,o._data,s)})));});},Yn=0,(Vn=Hn).prototype._init=function(t){(t=t||{}).data=function(t,e){var n=t.data,i=(t.el,e.args),r=e.props;if(void 0===r&&(r={}),n=$(n)?P(i)?void 0:n.slice(0,i.length).reduce(function(t,e,n){return T(e)?X(t,e):t[i[n]]=e,t},{}):n)for(var o in n)H(n[o])?delete n[o]:n[o]=r[o]?Qn(r[o],n[o]):n[o];return n}(t,this.constructor.options),this.$options=_n(this.constructor.options,t,this),this.$el=null,this.$props={},this._frames={reads:{},writes:{}},this._events=[],this._uid=Yn++,this._initData(),this._initMethods(),this._initComputeds(),this._callHook("created"),t.el&&this.$mount(t.el);},Vn.prototype._initData=function(){var t=this.$options.data;for(var e in void 0===t&&(t={}),t)this.$props[e]=this[e]=t[e];},Vn.prototype._initMethods=function(){var t=this.$options.methods;if(t)for(var e in t)this[e]=l(t[e],this);},Vn.prototype._initComputeds=function(){var t=this.$options.computed;if(this._computeds={},t)for(var e in t)Gn(this,e,t[e]);},Vn.prototype._callWatches=function(){var t=this.$options.computed,e=this._computeds;for(var n in e){var i=e[n];delete e[n],t[n].watch&&!q(i,this[n])&&t[n].watch.call(this,this[n],i);}},Vn.prototype._initProps=function(t){var e;for(e in t=t||Kn(this.$options,this.$name))H(t[e])||(this.$props[e]=t[e]);var n=[this.$options.computed,this.$options.methods];for(e in this.$props)e in t&&Zn(n,e)&&(this[e]=this.$props[e]);},Vn.prototype._initEvents=function(){var n=this,t=this.$options.events;t&&t.forEach(function(t){if(c(t,"handler"))Jn(n,t);else for(var e in t)Jn(n,t[e],e);});},Vn.prototype._unbindEvents=function(){this._events.forEach(function(t){return t()}),this._events=[];},Vn.prototype._initObserver=function(){var n=this,t=this.$options,i=t.attrs,e=t.props,r=t.el;if(!this._observer&&e&&!1!==i){i=$(i)?i:Object.keys(e),this._observer=new MutationObserver(function(){var e=Kn(n.$options,n.$name);i.some(function(t){return !H(e[t])&&e[t]!==n.$props[t]})&&n.$reset();});var o=i.map(function(t){return d(t)}).concat(this.$name);this._observer.observe(r,{attributes:!0,attributeFilter:o.concat(o.map(function(t){return "data-"+t}))});}},qn=(Rn=Hn).data,Un={},Rn.component=function(s,t){if(!t)return T(Un[s])&&(Un[s]=Rn.extend(Un[s])),Un[s];Rn[s]=function(t,n){for(var e=arguments.length,i=Array(e);e--;)i[e]=arguments[e];var r=Rn.component(s);return T(t)?new r({data:t}):r.options.functional?new r({data:[].concat(i)}):t&&t.nodeType?o(t):Te(t).map(o)[0];function o(t){var e=Rn.getComponent(t,s);if(e){if(!n)return e;e.$destroy();}return new r({el:t,data:n})}};var e=T(t)?X({},t):t.options;if(e.name=s,e.install&&e.install(Rn,e,s),Rn._initialized&&!e.functional){var n=d(s);xn.read(function(){return Rn[s]("[uk-"+n+"],[data-uk-"+n+"]")});}return Un[s]=T(t)?e:t},Rn.getComponents=function(t){return t&&t[qn]||{}},Rn.getComponent=function(t,e){return Rn.getComponents(t)[e]},Rn.connect=function(t){if(t[qn])for(var e in t[qn])t[qn][e]._callConnected();for(var n=0;n<t.attributes.length;n++){var i=Pn(t.attributes[n].name);i&&i in Un&&Rn[i](t);}},Rn.disconnect=function(t){for(var e in t[qn])t[qn][e]._callDisconnected();},function(i){var r=i.data;i.prototype.$mount=function(t){var e=this.$options.name;t[r]||(t[r]={}),t[r][e]||((t[r][e]=this).$el=this.$options.el=this.$options.el||t,_t(t,document)&&this._callConnected());},i.prototype.$emit=function(t){this._callUpdate(t);},i.prototype.$reset=function(){this._callDisconnected(),this._callConnected();},i.prototype.$destroy=function(t){void 0===t&&(t=!1);var e=this.$options,n=e.el,i=e.name;n&&this._callDisconnected(),this._callHook("destroy"),n&&n[r]&&(delete n[r][i],P(n[r])||delete n[r],t&&ve(this.$el));},i.prototype.$create=function(t,e,n){return i[t](e,n)},i.prototype.$update=i.update,i.prototype.$getComponent=i.getComponent;var e={};Object.defineProperties(i.prototype,{$container:Object.getOwnPropertyDescriptor(i,"container"),$name:{get:function(){var t=this.$options.name;return e[t]||(e[t]=i.prefix+d(t)),e[t]}}});}(Hn);var ti={connected:function(){Me(this.$el,this.$name)||Ae(this.$el,this.$name);}},ei={props:{cls:Boolean,animation:"list",duration:Number,origin:String,transition:String,queued:Boolean},data:{cls:!1,animation:[!1],duration:200,origin:!1,transition:"linear",queued:!1,initProps:{overflow:"",height:"",paddingTop:"",paddingBottom:"",marginTop:"",marginBottom:""},hideProps:{overflow:"hidden",height:0,paddingTop:0,paddingBottom:0,marginTop:0,marginBottom:0}},computed:{hasAnimation:function(t){return !!t.animation[0]},hasTransition:function(t){var e=t.animation;return this.hasAnimation&&!0===e[0]}},methods:{toggleElement:function(c,u,l){var d=this;return new Yt(function(t){c=V(c);function e(t){return Yt.all(t.map(function(t){return d._toggleElement(t,u,l)}))}var n,i=c.filter(function(t){return d.isToggled(t)}),r=c.filter(function(t){return !y(i,t)});if(d.queued&&H(l)&&H(u)&&d.hasAnimation&&!(c.length<2)){var o=document.body,s=o.scrollTop,a=i[0],h=Ze.inProgress(a)&&Me(a,"uk-animation-leave")||Ue.inProgress(a)&&"0px"===a.style.height;n=e(i),h||(n=n.then(function(){var t=e(r);return o.scrollTop=s,t}));}else n=e(r.concat(i));n.then(t,Q);})},toggleNow:function(e,n){var i=this;return new Yt(function(t){return Yt.all(V(e).map(function(t){return i._toggleElement(t,n,!1)})).then(t,Q)})},isToggled:function(t){var e=V(t||this.$el);return this.cls?Me(e,this.cls.split(" ")[0]):!rt(e,"hidden")},updateAria:function(t){!1===this.cls&&it(t,"aria-hidden",!this.isToggled(t));},_toggleElement:function(t,e,n){var i=this;if(e=O(e)?e:Ze.inProgress(t)?Me(t,"uk-animation-leave"):Ue.inProgress(t)?"0px"===t.style.height:!this.isToggled(t),!Bt(t,"before"+(e?"show":"hide"),[this]))return Yt.reject();var r=(I(n)?n:!1!==n&&this.hasAnimation?this.hasTransition?function(t){var s=t.isToggled,a=t.duration,h=t.initProps,c=t.hideProps,u=t.transition,l=t._toggle;return function(t,e){var n=Ue.inProgress(t),i=t.hasChildNodes?j(He(t.firstElementChild,"marginTop"))+j(He(t.lastElementChild,"marginBottom")):0,r=Et(t)?on(t)+(n?0:i):0;Ue.cancel(t),s(t)||l(t,!0),on(t,""),xn.flush();var o=on(t)+(n?0:i);return on(t,r),(e?Ue.start(t,X({},h,{overflow:"hidden",height:o}),Math.round(a*(1-r/o)),u):Ue.start(t,c,Math.round(a*(r/o)),u).then(function(){return l(t,!1)})).then(function(){return He(t,h)})}}(this):function(t){var n=t.animation,i=t.duration,r=t.origin,o=t._toggle;return function(t,e){return Ze.cancel(t),e?(o(t,!0),Ze.in(t,n[0],i,r)):Ze.out(t,n[1]||n[0],i,r).then(function(){return o(t,!1)})}}(this):this._toggle)(t,e);Bt(t,e?"show":"hide",[this]);function o(){Bt(t,e?"shown":"hidden",[i]),i.$update(t);}return r?r.then(o):Yt.resolve(o())},_toggle:function(t,e){var n;t&&(e=Boolean(e),this.cls?(n=y(this.cls," ")||e!==Me(t,this.cls))&&Oe(t,this.cls,y(this.cls," ")?void 0:e):(n=e===rt(t,"hidden"))&&it(t,"hidden",e?null:""),Te("[autofocus]",t).some(function(t){return Et(t)?t.focus()||!0:t.blur()}),this.updateAria(t),n&&this.$update(t));}}};var ni={mixins:[ti,ei],props:{targets:String,active:null,collapsible:Boolean,multiple:Boolean,toggle:String,content:String,transition:String},data:{targets:"> *",active:!1,animation:[!0],collapsible:!0,multiple:!1,clsOpen:"uk-open",toggle:"> .uk-accordion-title",content:"> .uk-accordion-content",transition:"ease"},computed:{items:function(t,e){return Te(t.targets,e)}},events:[{name:"click",delegate:function(){return this.targets+" "+this.$props.toggle},handler:function(t){t.preventDefault(),this.toggle(ce(Te(this.targets+" "+this.$props.toggle,this.$el),t.current));}}],connected:function(){if(!1!==this.active){var t=this.items[Number(this.active)];t&&!Me(t,this.clsOpen)&&this.toggle(t,!1);}},update:function(){var e=this;this.items.forEach(function(t){return e._toggle(Se(e.content,t),Me(t,e.clsOpen))});var t=!this.collapsible&&!Me(this.items,this.clsOpen)&&this.items[0];t&&this.toggle(t,!1);},methods:{toggle:function(r,o){var s=this,t=ue(r,this.items),a=Nt(this.items,"."+this.clsOpen);(r=this.items[t])&&[r].concat(!this.multiple&&!y(a,r)&&a||[]).forEach(function(t){var e=t===r,n=e&&!Me(t,s.clsOpen);if(n||!e||s.collapsible||!(a.length<2)){Oe(t,s.clsOpen,n);var i=t._wrapper?t._wrapper.firstElementChild:Se(s.content,t);t._wrapper||(t._wrapper=we(i,"<div>"),it(t._wrapper,"hidden",n?"":null)),s._toggle(i,!0),s.toggleElement(t._wrapper,n,o).then(function(){Me(t,s.clsOpen)===n&&(n||s._toggle(i,!1),t._wrapper=null,ye(i));});}});}}},ii={mixins:[ti,ei],args:"animation",props:{close:String},data:{animation:[!0],selClose:".uk-alert-close",duration:150,hideProps:X({opacity:0},ei.data.hideProps)},events:[{name:"click",delegate:function(){return this.selClose},handler:function(t){t.preventDefault(),this.close();}}],methods:{close:function(){var t=this;this.toggleElement(this.$el).then(function(){return t.$destroy(!0)});}}};function ri(r){he(function(){var n;r.update(),Mt(window,"load resize",function(){return r.update(null,"resize")}),Mt(document,"loadedmetadata load",function(t){var e=t.target;return r.update(e,"resize")},!0),Mt(window,"scroll",function(t){if(!n){n=!0,xn.write(function(){return n=!1});var e=t.target;r.update(1!==e.nodeType?document.body:e,t.type);}},{passive:!0,capture:!0});var e,i=0;Mt(document,"animationstart",function(t){var e=t.target;(He(e,"animationName")||"").match(/^uk-.*(left|right)/)&&(i++,He(document.body,"overflowX","hidden"),setTimeout(function(){--i||He(document.body,"overflowX","");},R(He(e,"animationDuration"))+100));},!0),Mt(document,ne,function(t){if(e&&e(),jt(t)){var r=Wt(t),o="tagName"in t.target?t.target:t.target.parentNode;e=Dt(document,re,function(t){var e=Wt(t),n=e.x,i=e.y;(o&&n&&100<Math.abs(r.x-n)||i&&100<Math.abs(r.y-i))&&setTimeout(function(){Bt(o,"swipe"),Bt(o,"swipe"+function(t,e,n,i){return Math.abs(t-n)>=Math.abs(e-i)?0<t-n?"Left":"Right":0<e-i?"Up":"Down"}(r.x,r.y,n,i));});});}},{passive:!0});});}var oi,si,ai={args:"autoplay",props:{automute:Boolean,autoplay:Boolean},data:{automute:!1,autoplay:!0},computed:{inView:function(t){return "inview"===t.autoplay}},connected:function(){this.inView&&!rt(this.$el,"preload")&&(this.$el.preload="none"),this.player=new On(this.$el),this.automute&&this.player.mute();},update:{read:function(){return !!this.player&&{visible:Et(this.$el)&&"hidden"!==He(this.$el,"visibility"),inView:this.inView&&fn(this.$el)}},write:function(t){var e=t.visible,n=t.inView;!e||this.inView&&!n?this.player.pause():(!0===this.autoplay||this.inView&&n)&&this.player.play();},events:["resize","scroll"]}},hi={mixins:[ti,ai],props:{width:Number,height:Number},data:{automute:!0},update:{read:function(){var t=this.$el;if(!Et(t))return !1;var e=t.parentNode;return {height:e.offsetHeight,width:e.offsetWidth}},write:function(t){var e=t.height,n=t.width,i=this.$el,r=this.width||i.naturalWidth||i.videoWidth||i.clientWidth,o=this.height||i.naturalHeight||i.videoHeight||i.clientHeight;r&&o&&He(i,nt.cover({width:r,height:o},{width:n+(n%2?1:0),height:e+(e%2?1:0)}));},events:["resize"]}},ci={props:{pos:String,offset:null,flip:Boolean,clsPos:String},data:{pos:"bottom-"+(Zt?"right":"left"),flip:!0,offset:!1,clsPos:""},computed:{pos:function(t){var e=t.pos;return (e+(y(e,"-")?"":"-center")).split("-")},dir:function(){return this.pos[0]},align:function(){return this.pos[1]}},methods:{positionAt:function(t,e,n){var i;Ne(t,this.clsPos+"-(top|bottom|left|right)(-[a-z]+)?"),He(t,{top:"",left:""});var r=this.offset,o=this.getAxis();z(r)||(r=(i=Se(r))?en(i)["x"===o?"left":"top"]-en(e)["x"===o?"right":"bottom"]:0);var s=tn(t,e,"x"===o?dn(this.dir)+" "+this.align:this.align+" "+dn(this.dir),"x"===o?this.dir+" "+this.align:this.align+" "+this.dir,"x"===o?""+("left"===this.dir?-r:r):" "+("top"===this.dir?-r:r),null,this.flip,n).target,a=s.x,h=s.y;this.dir="x"===o?a:h,this.align="x"===o?h:a,Oe(t,this.clsPos+"-"+this.dir+"-"+this.align,!1===this.offset);},getAxis:function(){return "top"===this.dir||"bottom"===this.dir?"y":"x"}}},ui={mixins:[ci,ei],args:"pos",props:{mode:"list",toggle:Boolean,boundary:Boolean,boundaryAlign:Boolean,delayShow:Number,delayHide:Number,clsDrop:String},data:{mode:["click","hover"],toggle:"- *",boundary:window,boundaryAlign:!1,delayShow:0,delayHide:800,clsDrop:!1,hoverIdle:200,animation:["uk-animation-fade"],cls:"uk-open"},computed:{boundary:function(t,e){return at(t.boundary,e)},clsDrop:function(t){return t.clsDrop||"uk-"+this.$options.name},clsPos:function(){return this.clsDrop}},created:function(){this.tracker=new Tn;},connected:function(){Ae(this.$el,this.clsDrop);var t=this.$props.toggle;this.toggle=t&&this.$create("toggle",at(t,this.$el),{target:this.$el,mode:this.mode}),this.toggle||Bt(this.$el,"updatearia");},events:[{name:"click",delegate:function(){return "."+this.clsDrop+"-close"},handler:function(t){t.preventDefault(),this.hide(!1);}},{name:"click",delegate:function(){return 'a[href^="#"]'},handler:function(t){var e=t.target.hash;e||t.preventDefault(),e&&_t(e,this.$el)||this.hide(!1);}},{name:"beforescroll",handler:function(){this.hide(!1);}},{name:"toggle",self:!0,handler:function(t,e){t.preventDefault(),this.isToggled()?this.hide(!1):this.show(e,!1);}},{name:oe,filter:function(){return y(this.mode,"hover")},handler:function(t){jt(t)||(oi&&oi!==this&&oi.toggle&&y(oi.toggle.mode,"hover")&&!_t(t.target,oi.toggle.$el)&&!et({x:t.pageX,y:t.pageY},en(oi.$el))&&oi.hide(!1),t.preventDefault(),this.show(this.toggle));}},{name:"toggleshow",handler:function(t,e){e&&!y(e.target,this.$el)||(t.preventDefault(),this.show(e||this.toggle));}},{name:"togglehide "+se,handler:function(t,e){jt(t)||e&&!y(e.target,this.$el)||(t.preventDefault(),this.toggle&&y(this.toggle.mode,"hover")&&this.hide());}},{name:"beforeshow",self:!0,handler:function(){this.clearTimers(),Ze.cancel(this.$el),this.position();}},{name:"show",self:!0,handler:function(){this.tracker.init(),Bt(this.$el,"updatearia"),function(){if(si)return;si=!0,Mt(document,re,function(t){var e,n=t.target;if(!t.defaultPrevented)for(;oi&&oi!==e&&!_t(n,oi.$el)&&(!oi.toggle||!_t(n,oi.toggle.$el));)(e=oi).hide(!1);});}();}},{name:"beforehide",self:!0,handler:function(){this.clearTimers();}},{name:"hide",handler:function(t){var e=t.target;this.$el===e?(oi=this.isActive()?null:oi,Bt(this.$el,"updatearia"),this.tracker.cancel()):oi=null===oi&&_t(e,this.$el)&&this.isToggled()?this:oi;}},{name:"updatearia",self:!0,handler:function(t,e){t.preventDefault(),this.updateAria(this.$el),(e||this.toggle)&&(it((e||this.toggle).$el,"aria-expanded",this.isToggled()?"true":"false"),Oe(this.toggle.$el,this.cls,this.isToggled()));}}],update:{write:function(){this.isToggled()&&!Ze.inProgress(this.$el)&&this.position();},events:["resize"]},methods:{show:function(e,n){var i=this;void 0===n&&(n=!0);function r(){return !i.isToggled()&&i.toggleElement(i.$el,!0)}function t(){if(i.toggle=e||i.toggle,i.clearTimers(),!i.isActive())if(n&&oi&&oi!==i&&oi.isDelaying)i.showTimer=setTimeout(i.show,10);else{if(i.isParentOf(oi)){if(!oi.hideTimer)return;oi.hide(!1);}else if(oi&&i.isChildOf(oi))oi.clearTimers();else if(oi&&!i.isChildOf(oi)&&!i.isParentOf(oi))for(var t;oi&&oi!==t&&!i.isChildOf(oi);)(t=oi).hide(!1);n&&i.delayShow?i.showTimer=setTimeout(r,i.delayShow):r(),oi=i;}}e&&this.toggle&&e.$el!==this.toggle.$el?(Dt(this.$el,"hide",t),this.hide(!1)):t();},hide:function(t){var e=this;void 0===t&&(t=!0);function n(){return e.toggleNow(e.$el,!1)}this.clearTimers(),this.isDelaying=this.tracker.movesTo(this.$el),t&&this.isDelaying?this.hideTimer=setTimeout(this.hide,this.hoverIdle):t&&this.delayHide?this.hideTimer=setTimeout(n,this.delayHide):n();},clearTimers:function(){clearTimeout(this.showTimer),clearTimeout(this.hideTimer),this.showTimer=null,this.hideTimer=null,this.isDelaying=!1;},isActive:function(){return oi===this},isChildOf:function(t){return t&&t!==this&&_t(this.$el,t.$el)},isParentOf:function(t){return t&&t!==this&&_t(t.$el,this.$el)},position:function(){Ne(this.$el,this.clsDrop+"-(stack|boundary)"),He(this.$el,{top:"",left:"",display:"block"}),Oe(this.$el,this.clsDrop+"-boundary",this.boundaryAlign);var t=en(this.boundary),e=this.boundaryAlign?t:en(this.toggle.$el);if("justify"===this.align){var n="y"===this.getAxis()?"width":"height";He(this.$el,n,e[n]);}else this.$el.offsetWidth>Math.max(t.right-e.left,e.right-t.left)&&Ae(this.$el,this.clsDrop+"-stack");this.positionAt(this.$el,this.boundaryAlign?this.boundary:this.toggle.$el,this.boundary),He(this.$el,"display","");}}};var li={extends:ui},di={mixins:[ti],args:"target",props:{target:Boolean},data:{target:!1},computed:{input:function(t,e){return Se(At,e)},state:function(){return this.input.nextElementSibling},target:function(t,e){var n=t.target;return n&&(!0===n&&this.input.parentNode===e&&this.input.nextElementSibling||at(n,e))}},update:function(){var t=this.target,e=this.input;if(t){var n,i=Ct(t)?"value":"textContent",r=t[i],o=e.files&&e.files[0]?e.files[0].name:bt(e,"select")&&(n=Te("option",e).filter(function(t){return t.selected})[0])?n.textContent:e.value;r!==o&&(t[i]=o);}},events:[{name:"change",handler:function(){this.$emit();}},{name:"reset",el:function(){return xt(this.$el,"form")},handler:function(){this.$emit();}}]},fi={update:{read:function(t){var e=fn(this.$el);if(!e||t.isInView===e)return !1;t.isInView=e;},write:function(){this.$el.src=this.$el.src;},events:["scroll","resize"]}},pi={props:{margin:String,firstColumn:Boolean},data:{margin:"uk-margin-small-top",firstColumn:"uk-first-column"},update:{read:function(t){var e=this.$el.children;if(!e.length||!Et(this.$el))return t.rows=[[]];t.rows=mi(e),t.stacks=!t.rows.some(function(t){return 1<t.length});},write:function(t){var i=this;t.rows.forEach(function(t,n){return t.forEach(function(t,e){Oe(t,i.margin,0!==n),Oe(t,i.firstColumn,0===e);})});},events:["resize"]}};function mi(t){for(var e=[[]],n=0;n<t.length;n++){var i=t[n],r=gi(i);if(r.height)for(var o=e.length-1;0<=o;o--){var s=e[o];if(!s[0]){s.push(i);break}var a=void 0;if(a=s[0].offsetParent===i.offsetParent?gi(s[0]):(r=gi(i,!0),gi(s[0],!0)),r.top>=a.bottom-1){e.push([i]);break}if(r.bottom>a.top){if(r.left<a.left&&!Zt){s.unshift(i);break}s.push(i);break}if(0===o){e.unshift([i]);break}}}return e}function gi(t,e){var n;void 0===e&&(e=!1);var i=t.offsetTop,r=t.offsetLeft,o=t.offsetHeight;return e&&(i=(n=gn(t))[0],r=n[1]),{top:i,left:r,height:o,bottom:i+o}}var vi={extends:pi,mixins:[ti],name:"grid",props:{masonry:Boolean,parallax:Number},data:{margin:"uk-grid-margin",clsStack:"uk-grid-stack",masonry:!1,parallax:0},computed:{length:function(t,e){return e.children.length},parallax:function(t){var e=t.parallax;return e&&this.length?Math.abs(e):""}},connected:function(){this.masonry&&Ae(this.$el,"uk-flex-top uk-flex-wrap-top");},update:[{read:function(t){var r=t.rows;(this.masonry||this.parallax)&&(r=r.map(function(t){return G(t,"offsetLeft")}),Zt&&r.map(function(t){return t.reverse()}));var e=r.some(function(t){return t.some(Ue.inProgress)}),n=!1,i="";if(this.masonry&&this.length){var o=0;n=r.reduce(function(n,t,i){return n[i]=t.map(function(t,e){return 0===i?0:j(n[i-1][e])+(o-j(r[i-1][e]&&r[i-1][e].offsetHeight))}),o=t.reduce(function(t,e){return Math.max(t,e.offsetHeight)},0),n},[]),i=function(t){return Math.max.apply(Math,t.reduce(function(n,t){return t.forEach(function(t,e){return n[e]=(n[e]||0)+t.offsetHeight}),n},[]))}(r)+function(t,e){var n=V(t.children),i=n.filter(function(t){return Me(t,e)})[0];return j(i?He(i,"marginTop"):He(n[0],"paddingLeft"))}(this.$el,this.margin)*(r.length-1);}return {rows:r,translates:n,height:!e&&i}},write:function(t){var e=t.stacks,n=t.height;Oe(this.$el,this.clsStack,e),He(this.$el,"paddingBottom",this.parallax),!1!==n&&He(this.$el,"height",n);},events:["resize"]},{read:function(t){var e=t.height;return {scrolled:!!this.parallax&&pn(this.$el,e?e-on(this.$el):0)*this.parallax}},write:function(t){var e=t.rows,i=t.scrolled,r=t.translates;!1===i&&!r||e.forEach(function(t,n){return t.forEach(function(t,e){return He(t,"transform",i||r?"translateY("+((r&&-r[n][e])+(i?e%2?i:i/8:0))+"px)":"")})});},events:["scroll","resize"]}]};var wi=Jt?{data:{selMinHeight:!1,forceHeight:!1},computed:{elements:function(t,e){var n=t.selMinHeight;return n?Te(n,e):[e]}},update:[{read:function(){He(this.elements,"height","");},order:-5,events:["resize"]},{write:function(){var n=this;this.elements.forEach(function(t){var e=j(He(t,"minHeight"));e&&(n.forceHeight||Math.round(e+hn("height",t,"content-box"))>=t.offsetHeight)&&He(t,"height",e);});},order:5,events:["resize"]}]}:{},bi={mixins:[wi],args:"target",props:{target:String,row:Boolean},data:{target:"> *",row:!0,forceHeight:!0},computed:{elements:function(t,e){return Te(t.target,e)}},update:{read:function(){return {rows:(this.row?mi(this.elements):[this.elements]).map(yi)}},write:function(t){t.rows.forEach(function(t){var n=t.heights;return t.elements.forEach(function(t,e){return He(t,"minHeight",n[e])})});},events:["resize"]}};function yi(t){var e;if(t.length<2)return {heights:[""],elements:t};var n=xi(t),i=n.heights,r=n.max,o=t.some(function(t){return t.style.minHeight}),s=t.some(function(t,e){return !t.style.minHeight&&i[e]<r});return o&&s&&(He(t,"minHeight",""),e=xi(t),i=e.heights,r=e.max),{heights:i=t.map(function(t,e){return i[e]===r&&j(t.style.minHeight).toFixed(2)!==r.toFixed(2)?"":r}),elements:t}}function xi(t){var e=t.map(function(t){return en(t).height-hn("height",t,"content-box")});return {heights:e,max:Math.max.apply(null,e)}}var ki={mixins:[wi],props:{expand:Boolean,offsetTop:Boolean,offsetBottom:Boolean,minHeight:Number},data:{expand:!1,offsetTop:!1,offsetBottom:!1,minHeight:0},update:{read:function(t){var e=t.minHeight,n="",i=hn("height",this.$el,"content-box");if(this.expand)n=on(window)-($i(document.documentElement)-$i(this.$el))-i||"";else{if(n="calc(100vh",this.offsetTop){var r=en(this.$el).top;n+=r<on(window)/2?" - "+r+"px":"";}!0===this.offsetBottom?n+=" - "+$i(this.$el.nextElementSibling)+"px":z(this.offsetBottom)?n+=" - "+this.offsetBottom+"vh":this.offsetBottom&&u(this.offsetBottom,"px")?n+=" - "+j(this.offsetBottom)+"px":D(this.offsetBottom)&&(n+=" - "+$i(at(this.offsetBottom,this.$el))+"px"),n+=(i?" - "+i+"px":"")+")";}return {minHeight:n,prev:e}},write:function(t){var e=t.minHeight,n=t.prev;He(this.$el,{minHeight:e}),e!==n&&this.$update(this.$el,"resize"),this.minHeight&&j(He(this.$el,"minHeight"))<this.minHeight&&He(this.$el,"minHeight",this.minHeight);},events:["resize"]}};function $i(t){return t&&t.offsetHeight||0}var Ii={args:"src",props:{id:Boolean,icon:String,src:String,style:String,width:Number,height:Number,ratio:Number,class:String,strokeAnimation:Boolean,attributes:"list"},data:{ratio:1,include:["style","class"],class:"",strokeAnimation:!1},beforeConnect:function(){var t,e=this;if(this.class+=" uk-svg",!this.icon&&y(this.src,"#")){var n=this.src.split("#");1<n.length&&(t=n,this.src=t[0],this.icon=t[1]);}this.svg=this.getSvg().then(function(t){return e.applyAttributes(t),e.svgEl=function(t,e){{if(Tt(e)||"CANVAS"===e.tagName){it(e,"hidden",!0);var n=e.nextElementSibling;return Ci(t,n)?n:me(e,t)}var i=e.lastElementChild;return Ci(t,i)?i:fe(e,t)}}(t,e.$el)},Q);},disconnected:function(){var e=this;Tt(this.$el)&&it(this.$el,"hidden",null),this.svg&&this.svg.then(function(t){return (!e._connected||t!==e.svgEl)&&ve(t)},Q),this.svg=this.svgEl=null;},update:{read:function(){return !!(this.strokeAnimation&&this.svgEl&&Et(this.svgEl))},write:function(){!function(t){var e=Ai(t);e&&t.style.setProperty("--uk-animation-stroke",e);}(this.svgEl);},type:["resize"]},methods:{getSvg:function(){var e=this;return function(n){if(Si[n])return Si[n];return Si[n]=new Yt(function(e,t){n?w(n,"data:")?e(decodeURIComponent(n.split(",")[1])):Kt(n).then(function(t){return e(t.response)},function(){return t("SVG not found.")}):t();})}(this.src).then(function(t){return function(t,e){e&&y(t,"<symbol")&&(t=function(t,e){if(!Ei[t]){var n;for(Ei[t]={};n=Ti.exec(t);)Ei[t][n[3]]='<svg xmlns="http://www.w3.org/2000/svg"'+n[1]+"svg>";Ti.lastIndex=0;}return Ei[t][e]}(t,e)||t);return (t=Se(t.substr(t.indexOf("<svg"))))&&t.hasChildNodes()&&t}(t,e.icon)||Yt.reject("SVG not found.")})},applyAttributes:function(n){var i=this;for(var t in this.$options.props)this[t]&&y(this.include,t)&&it(n,t,this[t]);for(var e in this.attributes){var r=this.attributes[e].split(":",2),o=r[0],s=r[1];it(n,o,s);}this.id||ot(n,"id");var a=["width","height"],h=[this.width,this.height];h.some(function(t){return t})||(h=a.map(function(t){return it(n,t)}));var c=it(n,"viewBox");c&&!h.some(function(t){return t})&&(h=c.split(" ").slice(2)),h.forEach(function(t,e){(t=(0|t)*i.ratio)&&it(n,a[e],t),t&&!h[1^e]&&ot(n,a[1^e]);}),it(n,"data-svg",this.icon||this.src);}}},Si={};var Ti=/<symbol(.*?id=(['"])(.*?)\2[^]*?<\/)symbol>/g,Ei={};function Ai(t){return Math.ceil(Math.max.apply(Math,Te("[stroke]",t).map(function(t){return t.getTotalLength&&t.getTotalLength()||0}).concat([0])))}function Ci(t,e){return it(t,"data-svg")===it(e,"data-svg")}var Ni={},_i={spinner:'<svg width="30" height="30" viewBox="0 0 30 30" xmlns="http://www.w3.org/2000/svg"><circle fill="none" stroke="#000" cx="15" cy="15" r="14"/></svg>',totop:'<svg width="18" height="10" viewBox="0 0 18 10" xmlns="http://www.w3.org/2000/svg"><polyline fill="none" stroke="#000" stroke-width="1.2" points="1 9 9 1 17 9 "/></svg>',marker:'<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><rect x="9" y="4" width="1" height="11"/><rect x="4" y="9" width="11" height="1"/></svg>',"close-icon":'<svg width="14" height="14" viewBox="0 0 14 14" xmlns="http://www.w3.org/2000/svg"><line fill="none" stroke="#000" stroke-width="1.1" x1="1" y1="1" x2="13" y2="13"/><line fill="none" stroke="#000" stroke-width="1.1" x1="13" y1="1" x2="1" y2="13"/></svg>',"close-large":'<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><line fill="none" stroke="#000" stroke-width="1.4" x1="1" y1="1" x2="19" y2="19"/><line fill="none" stroke="#000" stroke-width="1.4" x1="19" y1="1" x2="1" y2="19"/></svg>',"navbar-toggle-icon":'<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><rect y="9" width="20" height="2"/><rect y="3" width="20" height="2"/><rect y="15" width="20" height="2"/></svg>',"overlay-icon":'<svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><rect x="19" y="0" width="1" height="40"/><rect x="0" y="19" width="40" height="1"/></svg>',"pagination-next":'<svg width="7" height="12" viewBox="0 0 7 12" xmlns="http://www.w3.org/2000/svg"><polyline fill="none" stroke="#000" stroke-width="1.2" points="1 1 6 6 1 11"/></svg>',"pagination-previous":'<svg width="7" height="12" viewBox="0 0 7 12" xmlns="http://www.w3.org/2000/svg"><polyline fill="none" stroke="#000" stroke-width="1.2" points="6 1 1 6 6 11"/></svg>',"search-icon":'<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle fill="none" stroke="#000" stroke-width="1.1" cx="9" cy="9" r="7"/><path fill="none" stroke="#000" stroke-width="1.1" d="M14,14 L18,18 L14,14 Z"/></svg>',"search-large":'<svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><circle fill="none" stroke="#000" stroke-width="1.8" cx="17.5" cy="17.5" r="16.5"/><line fill="none" stroke="#000" stroke-width="1.8" x1="38" y1="39" x2="29" y2="30"/></svg>',"search-navbar":'<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><circle fill="none" stroke="#000" stroke-width="1.1" cx="10.5" cy="10.5" r="9.5"/><line fill="none" stroke="#000" stroke-width="1.1" x1="23" y1="23" x2="17" y2="17"/></svg>',"slidenav-next":'<svg width="14px" height="24px" viewBox="0 0 14 24" xmlns="http://www.w3.org/2000/svg"><polyline fill="none" stroke="#000" stroke-width="1.4" points="1.225,23 12.775,12 1.225,1 "/></svg>',"slidenav-next-large":'<svg width="25px" height="40px" viewBox="0 0 25 40" xmlns="http://www.w3.org/2000/svg"><polyline fill="none" stroke="#000" stroke-width="2" points="4.002,38.547 22.527,20.024 4,1.5 "/></svg>',"slidenav-previous":'<svg width="14px" height="24px" viewBox="0 0 14 24" xmlns="http://www.w3.org/2000/svg"><polyline fill="none" stroke="#000" stroke-width="1.4" points="12.775,1 1.225,12 12.775,23 "/></svg>',"slidenav-previous-large":'<svg width="25px" height="40px" viewBox="0 0 25 40" xmlns="http://www.w3.org/2000/svg"><polyline fill="none" stroke="#000" stroke-width="2" points="20.527,1.5 2,20.024 20.525,38.547 "/></svg>'},Mi={install:function(r){r.icon.add=function(t,e){var n,i=D(t)?((n={})[t]=e,n):t;K(i,function(t,e){_i[e]=t,delete Ni[e];}),r._initialized&&Ie(document.body,function(t){return K(r.getComponents(t),function(t){t.$options.isIcon&&t.icon in i&&t.$reset();})});};},extends:Ii,args:"icon",props:["icon"],data:{include:[]},isIcon:!0,beforeConnect:function(){Ae(this.$el,"uk-icon");},methods:{getSvg:function(){var t=function(t){if(!_i[t])return null;Ni[t]||(Ni[t]=Se(_i[t].trim()));return Ni[t].cloneNode(!0)}(function(t){return Zt?U(U(t,"left","right"),"previous","next"):t}(this.icon));return t?Yt.resolve(t):Yt.reject("Icon not found.")}}},Oi={args:!1,extends:Mi,data:function(t){return {icon:d(t.constructor.options.name)}},beforeConnect:function(){Ae(this.$el,this.$name);}},Di={extends:Oi,beforeConnect:function(){Ae(this.$el,"uk-slidenav");},computed:{icon:function(t,e){var n=t.icon;return Me(e,"uk-slidenav-large")?n+"-large":n}}},Bi={extends:Oi,computed:{icon:function(t,e){var n=t.icon;return Me(e,"uk-search-icon")&&kt(e,".uk-search-large").length?"search-large":kt(e,".uk-search-navbar").length?"search-navbar":n}}},zi={extends:Oi,computed:{icon:function(){return "close-"+(Me(this.$el,"uk-close-large")?"large":"icon")}}},Pi={extends:Oi,connected:function(){var e=this;this.svg.then(function(t){return 1!==e.ratio&&He(Se("circle",t),"strokeWidth",1/e.ratio)},Q);}};var Hi={args:"dataSrc",props:{dataSrc:String,dataSrcset:Boolean,sizes:String,width:Number,height:Number,offsetTop:String,offsetLeft:String,target:String},data:{dataSrc:"",dataSrcset:!1,sizes:!1,width:!1,height:!1,offsetTop:"50vh",offsetLeft:0,target:!1},computed:{cacheKey:function(t){var e=t.dataSrc;return this.$name+"."+e},width:function(t){var e=t.width,n=t.dataWidth;return e||n},height:function(t){var e=t.height,n=t.dataHeight;return e||n},sizes:function(t){var e=t.sizes,n=t.dataSizes;return e||n},isImg:function(t,e){return Ri(e)},target:{get:function(t){var e=t.target;return [this.$el].concat(ht(e,this.$el))},watch:function(){this.observe();}},offsetTop:function(t){return vn(t.offsetTop,"height")},offsetLeft:function(t){return vn(t.offsetLeft,"width")}},connected:function(){Ui[this.cacheKey]?Li(this.$el,Ui[this.cacheKey]||this.dataSrc,this.dataSrcset,this.sizes):this.isImg&&this.width&&this.height&&Li(this.$el,function(t,e,n){var i;n&&(i=nt.ratio({width:t,height:e},"width",vn(ji(n))),t=i.width,e=i.height);return 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="'+t+'" height="'+e+'"></svg>'}(this.width,this.height,this.sizes)),this.observer=new zn(this.load,{rootMargin:this.offsetTop+"px "+this.offsetLeft+"px"}),requestAnimationFrame(this.observe);},disconnected:function(){this.observer.disconnect();},update:{read:function(t){var e=this,n=t.image;if(n||"complete"!==document.readyState||this.load(this.observer.takeRecords()),this.isImg)return !1;n&&n.then(function(t){return t&&""!==t.currentSrc&&Li(e.$el,qi(t))});},write:function(t){if(this.dataSrcset&&1!==window.devicePixelRatio){var e=He(this.$el,"backgroundSize");!e.match(/^(auto\s?)+$/)&&j(e)!==t.bgSize||(t.bgSize=function(t,e){var n=vn(ji(e)),i=(t.match(Yi)||[]).map(j).sort(function(t,e){return t-e});return i.filter(function(t){return n<=t})[0]||i.pop()||""}(this.dataSrcset,this.sizes),He(this.$el,"backgroundSize",t.bgSize+"px"));}},events:["resize"]},methods:{load:function(t){var e=this;t.some(function(t){return t.isIntersecting})&&(this._data.image=Gt(this.dataSrc,this.dataSrcset,this.sizes).then(function(t){return Li(e.$el,qi(t),t.srcset,t.sizes),Ui[e.cacheKey]=qi(t),t},Q),this.observer.disconnect());},observe:function(){var e=this;!this._data.image&&this._connected&&this.target.forEach(function(t){return e.observer.observe(t)});}}};function Li(t,e,n,i){if(Ri(t))i&&(t.sizes=i),n&&(t.srcset=n),e&&(t.src=e);else if(e){!y(t.style.backgroundImage,e)&&(He(t,"backgroundImage","url("+It(e)+")"),Bt(t,zt("load",!1)));}}var Fi=/\s*(.*?)\s*(\w+|calc\(.*?\))\s*(?:,|$)/g;function ji(t){var e,n;for(Fi.lastIndex=0;e=Fi.exec(t);)if(!e[1]||window.matchMedia(e[1]).matches){e=w(n=e[2],"calc")?n.substring(5,n.length-1).replace(Wi,function(t){return vn(t)}).replace(/ /g,"").match(Vi).reduce(function(t,e){return t+ +e},0):n;break}return e||"100vw"}var Wi=/\d+(?:\w+|%)/g,Vi=/[+-]?(\d+)/g;var Yi=/\s+\d+w\s*(?:,|$)/g;function Ri(t){return "IMG"===t.tagName}function qi(t){return t.currentSrc||t.src}var Ui,Xi="__test__";try{(Ui=window.sessionStorage||{})[Xi]=1,delete Ui[Xi];}catch(t){Ui={};}var Ki={props:{media:Boolean},data:{media:!1},computed:{matchMedia:function(){var t=function(t){if(D(t)){if("@"===t[0])t=j(We("breakpoint-"+t.substr(1)));else if(isNaN(t))return t}return !(!t||isNaN(t))&&"(min-width: "+t+"px)"}(this.media);return !t||window.matchMedia(t).matches}}};var Gi,Ji,Zi={mixins:[ti,Ki],props:{fill:String},data:{fill:"",clsWrapper:"uk-leader-fill",clsHide:"uk-leader-hide",attrFill:"data-fill"},computed:{fill:function(t){return t.fill||We("leader-fill-content")}},connected:function(){var t;t=be(this.$el,'<span class="'+this.clsWrapper+'">'),this.wrapper=t[0];},disconnected:function(){ye(this.wrapper.childNodes);},update:{read:function(t){var e=t.changed,n=t.width,i=n;return {width:n=Math.floor(this.$el.offsetWidth/2),fill:this.fill,changed:e||i!==n,hide:!this.matchMedia}},write:function(t){Oe(this.wrapper,this.clsHide,t.hide),t.changed&&(t.changed=!1,it(this.wrapper,this.attrFill,new Array(t.width).join(t.fill)));},events:["resize"]}},Qi={props:{container:Boolean},data:{container:!0},computed:{container:function(t){var e=t.container;return !0===e&&this.$container||e&&Se(e)}}},tr={mixins:[ti,Qi,ei],props:{selPanel:String,selClose:String,escClose:Boolean,bgClose:Boolean,stack:Boolean},data:{cls:"uk-open",escClose:!0,bgClose:!0,overlay:!0,stack:!1},computed:{panel:function(t,e){return Se(t.selPanel,e)},transitionElement:function(){return this.panel},bgClose:function(t){return t.bgClose&&this.panel}},beforeDisconnect:function(){this.isToggled()&&this.toggleNow(this.$el,!1);},events:[{name:"click",delegate:function(){return this.selClose},handler:function(t){t.preventDefault(),this.hide();}},{name:"toggle",self:!0,handler:function(t){t.defaultPrevented||(t.preventDefault(),this.toggle());}},{name:"beforeshow",self:!0,handler:function(t){var n=Gi&&Gi!==this&&Gi;Gi=this,n?this.stack?this.prev=n:((Gi=n).isToggled()?n.hide().then(this.show):Dt(n.$el,"beforeshow hidden",this.show,!1,function(t){var e=t.target;return "hidden"===t.type&&e===n.$el}),t.preventDefault()):function(){if(Ji)return;Ji=[Mt(document,re,function(t){var e=t.target,n=t.defaultPrevented;!Gi||!Gi.bgClose||n||Gi.overlay&&!_t(e,Gi.$el)||_t(e,Gi.panel)||Gi.hide();}),Mt(document,"keydown",function(t){27===t.keyCode&&Gi&&Gi.escClose&&(t.preventDefault(),Gi.hide());})];}();}},{name:"show",self:!0,handler:function(){Me(document.documentElement,this.clsPage)||(this.scrollbarWidth=sn(window)-sn(document),He(document.body,"overflowY",this.scrollbarWidth&&this.overlay?"scroll":"")),Ae(document.documentElement,this.clsPage);}},{name:"hide",self:!0,handler:function(){Gi&&(Gi!==this||this.prev)||(Ji&&Ji.forEach(function(t){return t()}),Ji=null);}},{name:"hidden",self:!0,handler:function(){var t,e=this.prev;if(Gi=Gi&&Gi!==this&&Gi||e)for(;e;){if(e.clsPage===this.clsPage){t=!0;break}e=e.prev;}else He(document.body,"overflowY","");t||Ce(document.documentElement,this.clsPage);}}],methods:{toggle:function(){return this.isToggled()?this.hide():this.show()},show:function(){var e=this;return this.isToggled()?Yt.resolve():this.container&&this.$el.parentNode!==this.container?(fe(this.container,this.$el),new Yt(function(t){return requestAnimationFrame(function(){return e.show().then(t)})})):this.toggleElement(this.$el,!0,er(this))},hide:function(){return this.isToggled()?this.toggleElement(this.$el,!1,er(this)):Yt.resolve()},getActive:function(){return Gi}}};function er(t){var r=t.transitionElement,o=t._toggle;return function(n,i){return new Yt(function(t,e){return Dt(n,"show hide",function(){n._reject&&n._reject(),n._reject=e,o(n,i),R(He(r,"transitionDuration"))?Dt(r,"transitionend",t,!1,function(t){return t.target===r}):t();})})}}var nr={install:function(a){a.modal.dialog=function(t,e){var n=a.modal(' <div class="uk-modal"> <div class="uk-modal-dialog">'+t+"</div> </div> ",e);return n.show(),Mt(n.$el,"hidden",function(t){t.target===t.currentTarget&&Yt.resolve(function(){return n.$destroy(!0)});}),n},a.modal.alert=function(e,n){return n=X({bgClose:!1,escClose:!1,labels:a.modal.labels},n),new Yt(function(t){return Mt(a.modal.dialog(' <div class="uk-modal-body">'+(D(e)?e:de(e))+'</div> <div class="uk-modal-footer uk-text-right"> <button class="uk-button uk-button-primary uk-modal-close" autofocus>'+n.labels.ok+"</button> </div> ",n).$el,"hide",t)})},a.modal.confirm=function(r,o){return o=X({bgClose:!1,escClose:!0,labels:a.modal.labels},o),new Yt(function(e,t){var n=a.modal.dialog(' <form> <div class="uk-modal-body">'+(D(r)?r:de(r))+'</div> <div class="uk-modal-footer uk-text-right"> <button class="uk-button uk-button-default uk-modal-close" type="button">'+o.labels.cancel+'</button> <button class="uk-button uk-button-primary" autofocus>'+o.labels.ok+"</button> </div> </form> ",o),i=!1;Mt(n.$el,"submit","form",function(t){t.preventDefault(),e(),i=!0,n.hide();}),Mt(n.$el,"hide",function(){i||t();});})},a.modal.prompt=function(t,o,s){return s=X({bgClose:!1,escClose:!0,labels:a.modal.labels},s),new Yt(function(e){var n=a.modal.dialog(' <form class="uk-form-stacked"> <div class="uk-modal-body"> <label>'+(D(t)?t:de(t))+'</label> <input class="uk-input" autofocus> </div> <div class="uk-modal-footer uk-text-right"> <button class="uk-button uk-button-default uk-modal-close" type="button">'+s.labels.cancel+'</button> <button class="uk-button uk-button-primary">'+s.labels.ok+"</button> </div> </form> ",s),i=Se("input",n.$el);i.value=o;var r=!1;Mt(n.$el,"submit","form",function(t){t.preventDefault(),e(i.value),r=!0,n.hide();}),Mt(n.$el,"hide",function(){r||e(null);});})},a.modal.labels={ok:"Ok",cancel:"Cancel"};},mixins:[tr],data:{clsPage:"uk-modal-page",selPanel:".uk-modal-dialog",selClose:".uk-modal-close, .uk-modal-close-default, .uk-modal-close-outside, .uk-modal-close-full"},events:[{name:"show",self:!0,handler:function(){Me(this.panel,"uk-margin-auto-vertical")?Ae(this.$el,"uk-flex"):He(this.$el,"display","block"),on(this.$el);}},{name:"hidden",self:!0,handler:function(){He(this.$el,"display",""),Ce(this.$el,"uk-flex");}}]};var ir={extends:ni,data:{targets:"> .uk-parent",toggle:"> a",content:"> ul"}},rr={mixins:[ti,wi],props:{dropdown:String,mode:"list",align:String,offset:Number,boundary:Boolean,boundaryAlign:Boolean,clsDrop:String,delayShow:Number,delayHide:Number,dropbar:Boolean,dropbarMode:String,dropbarAnchor:Boolean,duration:Number},data:{dropdown:".uk-navbar-nav > li",align:Zt?"right":"left",clsDrop:"uk-navbar-dropdown",mode:void 0,offset:void 0,delayShow:void 0,delayHide:void 0,boundaryAlign:void 0,flip:"x",boundary:!0,dropbar:!1,dropbarMode:"slide",dropbarAnchor:!1,duration:200,forceHeight:!0,selMinHeight:".uk-navbar-nav > li > a, .uk-navbar-item, .uk-navbar-toggle"},computed:{boundary:function(t,e){var n=t.boundary,i=t.boundaryAlign;return !0===n||i?e:n},dropbarAnchor:function(t,e){return at(t.dropbarAnchor,e)},pos:function(t){return "bottom-"+t.align},dropdowns:function(t,e){return Te(t.dropdown+" ."+t.clsDrop,e)}},beforeConnect:function(){var t=this.$props.dropbar;this.dropbar=t&&(at(t,this.$el)||Se("+ .uk-navbar-dropbar",this.$el)||Se("<div></div>")),this.dropbar&&(Ae(this.dropbar,"uk-navbar-dropbar"),"slide"===this.dropbarMode&&Ae(this.dropbar,"uk-navbar-dropbar-slide"));},disconnected:function(){this.dropbar&&ve(this.dropbar);},update:function(){var e=this;this.$create("drop",this.dropdowns.filter(function(t){return !e.getDropdown(t)}),X({},this.$props,{boundary:this.boundary,pos:this.pos,offset:this.dropbar||this.offset}));},events:[{name:"mouseover",delegate:function(){return this.dropdown},handler:function(t){var e=t.current,n=this.getActive();n&&n.toggle&&!_t(n.toggle.$el,e)&&!n.tracker.movesTo(n.$el)&&n.hide(!1);}},{name:"mouseleave",el:function(){return this.dropbar},handler:function(){var t=this.getActive();t&&!this.dropdowns.some(function(t){return bt(t,":hover")})&&t.hide();}},{name:"beforeshow",capture:!0,filter:function(){return this.dropbar},handler:function(){this.dropbar.parentNode||me(this.dropbarAnchor||this.$el,this.dropbar);}},{name:"show",capture:!0,filter:function(){return this.dropbar},handler:function(t,e){var n=e.$el,i=e.dir;this.clsDrop&&Ae(n,this.clsDrop+"-dropbar"),"bottom"===i&&this.transitionTo(n.offsetHeight+j(He(n,"marginTop"))+j(He(n,"marginBottom")),n);}},{name:"beforehide",filter:function(){return this.dropbar},handler:function(t,e){var n=e.$el,i=this.getActive();bt(this.dropbar,":hover")&&i&&i.$el===n&&t.preventDefault();}},{name:"hide",filter:function(){return this.dropbar},handler:function(t,e){var n=e.$el,i=this.getActive();(!i||i&&i.$el===n)&&this.transitionTo(0);}}],methods:{getActive:function(){var t=this.dropdowns.map(this.getDropdown).filter(function(t){return t&&t.isActive()})[0];return t&&y(t.mode,"hover")&&_t(t.toggle.$el,this.$el)&&t},transitionTo:function(t,e){var n=this,i=this.dropbar,r=Et(i)?on(i):0;return He(e=r<t&&e,"clip","rect(0,"+e.offsetWidth+"px,"+r+"px,0)"),on(i,r),Ue.cancel([e,i]),Yt.all([Ue.start(i,{height:t},this.duration),Ue.start(e,{clip:"rect(0,"+e.offsetWidth+"px,"+t+"px,0)"},this.duration)]).catch(Q).then(function(){He(e,{clip:""}),n.$update(i);})},getDropdown:function(t){return this.$getComponent(t,"drop")||this.$getComponent(t,"dropdown")}}},or={mixins:[tr],args:"mode",props:{mode:String,flip:Boolean,overlay:Boolean},data:{mode:"slide",flip:!1,overlay:!1,clsPage:"uk-offcanvas-page",clsContainer:"uk-offcanvas-container",selPanel:".uk-offcanvas-bar",clsFlip:"uk-offcanvas-flip",clsContainerAnimation:"uk-offcanvas-container-animation",clsSidebarAnimation:"uk-offcanvas-bar-animation",clsMode:"uk-offcanvas",clsOverlay:"uk-offcanvas-overlay",selClose:".uk-offcanvas-close"},computed:{clsFlip:function(t){var e=t.flip,n=t.clsFlip;return e?n:""},clsOverlay:function(t){var e=t.overlay,n=t.clsOverlay;return e?n:""},clsMode:function(t){var e=t.mode;return t.clsMode+"-"+e},clsSidebarAnimation:function(t){var e=t.mode,n=t.clsSidebarAnimation;return "none"===e||"reveal"===e?"":n},clsContainerAnimation:function(t){var e=t.mode,n=t.clsContainerAnimation;return "push"!==e&&"reveal"!==e?"":n},transitionElement:function(t){return "reveal"===t.mode?this.panel.parentNode:this.panel}},events:[{name:"click",delegate:function(){return 'a[href^="#"]'},handler:function(t){var e=t.current;e.hash&&Se(e.hash,document.body)&&this.hide();}},{name:"touchstart",passive:!0,el:function(){return this.panel},handler:function(t){var e=t.targetTouches;1===e.length&&(this.clientY=e[0].clientY);}},{name:"touchmove",self:!0,passive:!1,filter:function(){return this.overlay},handler:function(t){t.cancelable&&t.preventDefault();}},{name:"touchmove",passive:!1,el:function(){return this.panel},handler:function(t){if(1===t.targetTouches.length){var e=event.targetTouches[0].clientY-this.clientY,n=this.panel,i=n.scrollTop,r=n.scrollHeight,o=n.clientHeight;(r<=o||0===i&&0<e||r-i<=o&&e<0)&&t.cancelable&&t.preventDefault();}}},{name:"show",self:!0,handler:function(){"reveal"!==this.mode||Me(this.panel.parentNode,this.clsMode)||(we(this.panel,"<div>"),Ae(this.panel.parentNode,this.clsMode)),He(document.documentElement,"overflowY",this.overlay?"hidden":""),Ae(document.body,this.clsContainer,this.clsFlip),He(this.$el,"display","block"),Ae(this.$el,this.clsOverlay),Ae(this.panel,this.clsSidebarAnimation,"reveal"!==this.mode?this.clsMode:""),on(document.body),Ae(document.body,this.clsContainerAnimation),this.clsContainerAnimation&&(sr().content+=",user-scalable=0");}},{name:"hide",self:!0,handler:function(){Ce(document.body,this.clsContainerAnimation);var t=this.getActive();("none"===this.mode||t&&t!==this&&t!==this.prev)&&Bt(this.panel,"transitionend");}},{name:"hidden",self:!0,handler:function(){this.clsContainerAnimation&&function(){var t=sr();t.content=t.content.replace(/,user-scalable=0$/,"");}(),"reveal"===this.mode&&ye(this.panel),Ce(this.panel,this.clsSidebarAnimation,this.clsMode),Ce(this.$el,this.clsOverlay),He(this.$el,"display",""),Ce(document.body,this.clsContainer,this.clsFlip),He(document.documentElement,"overflowY","");}},{name:"swipeLeft swipeRight",handler:function(t){this.isToggled()&&u(t.type,"Left")^this.flip&&this.hide();}}]};function sr(){return Se('meta[name="viewport"]',document.head)||fe(document.head,'<meta name="viewport">')}var ar={mixins:[ti],props:{selContainer:String,selContent:String},data:{selContainer:".uk-modal",selContent:".uk-modal-dialog"},computed:{container:function(t,e){return xt(e,t.selContainer)},content:function(t,e){return xt(e,t.selContent)}},connected:function(){He(this.$el,"minHeight",150);},update:{read:function(){return !(!this.content||!this.container)&&{current:j(He(this.$el,"maxHeight")),max:Math.max(150,on(this.container)-(en(this.content).height-on(this.$el)))}},write:function(t){var e=t.current,n=t.max;He(this.$el,"maxHeight",n),Math.round(e)!==Math.round(n)&&Bt(this.$el,"resize");},events:["resize"]}},hr={props:["width","height"],connected:function(){Ae(this.$el,"uk-responsive-width");},update:{read:function(){return !!(Et(this.$el)&&this.width&&this.height)&&{width:sn(this.$el.parentNode),height:this.height}},write:function(t){on(this.$el,nt.contain({height:this.height,width:this.width},t).height);},events:["resize"]}},cr={props:{duration:Number,offset:Number},data:{duration:1e3,offset:0},methods:{scrollTo:function(e){var n=this;e=e&&Se(e)||document.body;var t=on(document),i=on(window),r=en(e).top-this.offset;if(t<r+i&&(r=t-i),Bt(this.$el,"beforescroll",[this,e])){var o=Date.now(),s=window.pageYOffset,a=function(){var t=s+(r-s)*function(t){return .5*(1-Math.cos(Math.PI*t))}(Z((Date.now()-o)/n.duration));mn(window,t),t!==r?requestAnimationFrame(a):Bt(n.$el,"scrolled",[n,e]);};a();}}},events:{click:function(t){t.defaultPrevented||(t.preventDefault(),this.scrollTo(It(decodeURIComponent(this.$el.hash)).substr(1)));}}};var ur={args:"cls",props:{cls:String,target:String,hidden:Boolean,offsetTop:Number,offsetLeft:Number,repeat:Boolean,delay:Number},data:function(){return {cls:!1,target:!1,hidden:!0,offsetTop:0,offsetLeft:0,repeat:!1,delay:0,inViewClass:"uk-scrollspy-inview"}},computed:{elements:function(t,e){var n=t.target;return n?Te(n,e):[e]}},update:[{write:function(){this.hidden&&He(Nt(this.elements,":not(."+this.inViewClass+")"),"visibility","hidden");}},{read:function(t){var n=this;t.update&&this.elements.forEach(function(t){var e=t._ukScrollspyState;(e=e||{cls:st(t,"uk-scrollspy-class")||n.cls}).show=fn(t,n.offsetTop,n.offsetLeft),t._ukScrollspyState=e;});},write:function(r){var o=this;if(!r.update)return this.$emit(),r.update=!0;this.elements.forEach(function(t){var n=t._ukScrollspyState,e=n.cls;if(!n.show||n.inview||n.queued){if(!n.show&&(n.inview||n.queued)&&o.repeat){if(n.abort&&n.abort(),!n.inview)return;He(t,"visibility",o.hidden?"hidden":""),Ce(t,o.inViewClass),Oe(t,e),Bt(t,"outview"),o.$update(t),n.inview=!1;}}else{var i=function(){He(t,"visibility",""),Ae(t,o.inViewClass),Oe(t,e),Bt(t,"inview"),o.$update(t),n.inview=!0,n.abort&&n.abort();};o.delay?(n.queued=!0,r.promise=(r.promise||Yt.resolve()).then(function(){return !n.inview&&new Yt(function(t){var e=setTimeout(function(){i(),t();},r.promise||1===o.elements.length?o.delay:0);n.abort=function(){clearTimeout(e),t(),n.queued=!1;};})})):i();}});},events:["scroll","resize"]}]},lr={props:{cls:String,closest:String,scroll:Boolean,overflow:Boolean,offset:Number},data:{cls:"uk-active",closest:!1,scroll:!1,overflow:!0,offset:0},computed:{links:function(t,e){return Te('a[href^="#"]',e).filter(function(t){return t.hash})},elements:function(t){var e=t.closest;return xt(this.links,e||"*")},targets:function(){return Te(this.links.map(function(t){return It(t.hash).substr(1)}).join(","))}},update:[{read:function(){this.scroll&&this.$create("scroll",this.links,{offset:this.offset||0});}},{read:function(o){var s=this,a=window.pageYOffset+this.offset+1,h=on(document)-on(window)+this.offset;o.active=!1,this.targets.every(function(t,e){var n=en(t).top,i=e+1===s.targets.length;if(!s.overflow&&(0===e&&a<n||i&&n+t.offsetTop<a))return !1;if(!i&&en(s.targets[e+1]).top<=a)return !0;if(h<=a)for(var r=s.targets.length-1;e<r;r--)if(fn(s.targets[r])){t=s.targets[r];break}return !(o.active=Se(Nt(s.links,'[href="#'+t.id+'"]')))});},write:function(t){var e=t.active;this.links.forEach(function(t){return t.blur()}),Ce(this.elements,this.cls),e&&Bt(this.$el,"active",[e,Ae(this.closest?xt(e,this.closest):e,this.cls)]);},events:["scroll","resize"]}]},dr={mixins:[ti,Ki],props:{top:null,bottom:Boolean,offset:Number,animation:String,clsActive:String,clsInactive:String,clsFixed:String,clsBelow:String,selTarget:String,widthElement:Boolean,showOnUp:Boolean,targetOffset:Number},data:{top:0,bottom:!1,offset:0,animation:"",clsActive:"uk-active",clsInactive:"",clsFixed:"uk-sticky-fixed",clsBelow:"uk-sticky-below",selTarget:"",widthElement:!1,showOnUp:!1,targetOffset:!1},computed:{selTarget:function(t,e){var n=t.selTarget;return n&&Se(n,e)||e},widthElement:function(t,e){return at(t.widthElement,e)||this.placeholder},isActive:{get:function(){return Me(this.selTarget,this.clsActive)},set:function(t){t&&!this.isActive?(_e(this.selTarget,this.clsInactive,this.clsActive),Bt(this.$el,"active")):t||Me(this.selTarget,this.clsInactive)||(_e(this.selTarget,this.clsActive,this.clsInactive),Bt(this.$el,"inactive"));}}},connected:function(){this.placeholder=Se("+ .uk-sticky-placeholder",this.$el)||Se('<div class="uk-sticky-placeholder"></div>'),this.isFixed=!1,this.isActive=!1;},disconnected:function(){this.isFixed&&(this.hide(),Ce(this.selTarget,this.clsInactive)),ve(this.placeholder),this.placeholder=null,this.widthElement=null;},events:[{name:"load hashchange popstate",el:window,handler:function(){var i=this;if(!1!==this.targetOffset&&location.hash&&0<window.pageYOffset){var r=Se(location.hash);r&&xn.read(function(){var t=en(r).top,e=en(i.$el).top,n=i.$el.offsetHeight;i.isFixed&&t<=e+n&&e<=t+r.offsetHeight&&mn(window,t-n-(z(i.targetOffset)?i.targetOffset:0)-i.offset);});}}}],update:[{read:function(t,e){var n=t.height;this.isActive&&"update"!==e&&(this.hide(),n=this.$el.offsetHeight,this.show()),n=this.isActive?n:this.$el.offsetHeight,this.topOffset=en(this.isFixed?this.placeholder:this.$el).top,this.bottomOffset=this.topOffset+n;var i=fr("bottom",this);return this.top=Math.max(j(fr("top",this)),this.topOffset)-this.offset,this.bottom=i&&i-n,this.inactive=!this.matchMedia,{lastScroll:!1,height:n,margins:He(this.$el,["marginTop","marginBottom","marginLeft","marginRight"])}},write:function(t){var e=t.height,n=t.margins,i=this.placeholder;He(i,X({height:e},n)),_t(i,document)||(me(this.$el,i),it(i,"hidden","")),this.isActive=this.isActive;},events:["resize"]},{read:function(t){var e=t.scroll;return void 0===e&&(e=0),this.width=(Et(this.widthElement)?this.widthElement:this.$el).offsetWidth,this.scroll=window.pageYOffset,{dir:e<=this.scroll?"down":"up",scroll:this.scroll,visible:Et(this.$el),top:gn(this.placeholder)[0]}},write:function(t,e){var n=this,i=t.initTimestamp;void 0===i&&(i=0);var r=t.dir,o=t.lastDir,s=t.lastScroll,a=t.scroll,h=t.top,c=t.visible,u=performance.now();if(!((t.lastScroll=a)<0||a===s||!c||this.disabled||this.showOnUp&&"scroll"!==e||((300<u-i||r!==o)&&(t.initScroll=a,t.initTimestamp=u),t.lastDir=r,this.showOnUp&&Math.abs(t.initScroll-a)<=30&&Math.abs(s-a)<=10)))if(this.inactive||a<this.top||this.showOnUp&&(a<=this.top||"down"===r||"up"===r&&!this.isFixed&&a<=this.bottomOffset)){if(!this.isFixed)return void(Ze.inProgress(this.$el)&&a<h&&(Ze.cancel(this.$el),this.hide()));this.isFixed=!1,this.animation&&a>this.topOffset?(Ze.cancel(this.$el),Ze.out(this.$el,this.animation).then(function(){return n.hide()},Q)):this.hide();}else this.isFixed?this.update():this.animation?(Ze.cancel(this.$el),this.show(),Ze.in(this.$el,this.animation).catch(Q)):this.show();},events:["resize","scroll"]}],methods:{show:function(){this.isFixed=!0,this.update(),it(this.placeholder,"hidden",null);},hide:function(){this.isActive=!1,Ce(this.$el,this.clsFixed,this.clsBelow),He(this.$el,{position:"",top:"",width:""}),it(this.placeholder,"hidden","");},update:function(){var t=0!==this.top||this.scroll>this.top,e=Math.max(0,this.offset);this.bottom&&this.scroll>this.bottom-this.offset&&(e=this.bottom-this.scroll),He(this.$el,{position:"fixed",top:e+"px",width:this.width}),this.isActive=t,Oe(this.$el,this.clsBelow,this.scroll>this.bottomOffset),Ae(this.$el,this.clsFixed);}}};function fr(t,e){var n=e.$props,i=e.$el,r=e[t+"Offset"],o=n[t];if(o){if(z(o))return r+j(o);if(D(o)&&o.match(/^-?\d+vh$/))return on(window)*j(o)/100;var s=!0===o?i.parentNode:at(o,i);return s?en(s).top+s.offsetHeight:void 0}}var pr,mr={mixins:[ei],args:"connect",props:{connect:String,toggle:String,active:Number,swiping:Boolean},data:{connect:"~.uk-switcher",toggle:"> * > :first-child",active:0,swiping:!0,cls:"uk-active",clsContainer:"uk-switcher",attrItem:"uk-switcher-item",queued:!0},computed:{connects:function(t,e){return ht(t.connect,e)},toggles:function(t,e){return Te(t.toggle,e)}},events:[{name:"click",delegate:function(){return this.toggle+":not(.uk-disabled)"},handler:function(e){e.preventDefault(),this.show(V(this.$el.children).filter(function(t){return _t(e.current,t)})[0]);}},{name:"click",el:function(){return this.connects},delegate:function(){return "["+this.attrItem+"],[data-"+this.attrItem+"]"},handler:function(t){t.preventDefault(),this.show(st(t.current,this.attrItem));}},{name:"swipeRight swipeLeft",filter:function(){return this.swiping},el:function(){return this.connects},handler:function(t){var e=t.type;this.show(u(e,"Left")?"next":"previous");}}],update:function(){var e=this;this.connects.forEach(function(t){return e.updateAria(t.children)});var t=this.$el.children;this.show(Nt(t,"."+this.cls)[0]||t[this.active]||t[0]);},methods:{index:function(){return !P(this.connects)&&ce(Nt(this.connects[0].children,"."+this.cls)[0])},show:function(t){for(var e,n,i=this,r=this.$el.children,o=r.length,s=this.index(),a=0<=s,h="previous"===t?-1:1,c=ue(t,r,s),u=0;u<o;u++,c=(c+h+o)%o)if(!bt(this.toggles[c],".uk-disabled *, .uk-disabled, [disabled]")){e=this.toggles[c],n=r[c];break}!n||0<=s&&Me(n,this.cls)||s===c||(Ce(r,this.cls),Ae(n,this.cls),it(this.toggles,"aria-expanded",!1),it(e,"aria-expanded",!0),this.connects.forEach(function(t){a?i.toggleElement([t.children[s],t.children[c]]):i.toggleNow(t.children[c]);}));}}},gr={mixins:[ti],extends:mr,props:{media:Boolean},data:{media:960,attrItem:"uk-tab-item"},connected:function(){var t=Me(this.$el,"uk-tab-left")?"uk-tab-left":!!Me(this.$el,"uk-tab-right")&&"uk-tab-right";t&&this.$create("toggle",this.$el,{cls:t,mode:"media",media:this.media});}},vr={mixins:[Ki,ei],args:"target",props:{href:String,target:null,mode:"list"},data:{href:!1,target:!1,mode:"click",queued:!0},computed:{target:function(t,e){var n=t.href,i=t.target;return (i=ht(i||n,e)).length&&i||[e]}},connected:function(){Bt(this.target,"updatearia",[this]);},events:[{name:oe+" "+se,filter:function(){return y(this.mode,"hover")},handler:function(t){jt(t)||this.toggle("toggle"+(t.type===oe?"show":"hide"));}},{name:"click",filter:function(){return y(this.mode,"click")||ee&&y(this.mode,"hover")},handler:function(t){var e;(xt(t.target,'a[href="#"], a[href=""]')||(e=xt(t.target,"a[href]"))&&(this.cls||!Et(this.target)||e.hash&&bt(this.target,e.hash)))&&t.preventDefault(),this.toggle();}}],update:{read:function(){return !(!y(this.mode,"media")||!this.media)&&{match:this.matchMedia}},write:function(t){var e=t.match,n=this.isToggled(this.target);(e?!n:n)&&this.toggle();},events:["resize"]},methods:{toggle:function(t){Bt(this.target,t||"toggle",[this])&&this.toggleElement(this.target);}}};Hn.version="3.1.6",(pr=Hn).component("accordion",ni),pr.component("alert",ii),pr.component("cover",hi),pr.component("drop",ui),pr.component("dropdown",li),pr.component("formCustom",di),pr.component("gif",fi),pr.component("grid",vi),pr.component("heightMatch",bi),pr.component("heightViewport",ki),pr.component("icon",Mi),pr.component("img",Hi),pr.component("leader",Zi),pr.component("margin",pi),pr.component("modal",nr),pr.component("nav",ir),pr.component("navbar",rr),pr.component("offcanvas",or),pr.component("overflowAuto",ar),pr.component("responsive",hr),pr.component("scroll",cr),pr.component("scrollspy",ur),pr.component("scrollspyNav",lr),pr.component("sticky",dr),pr.component("svg",Ii),pr.component("switcher",mr),pr.component("tab",gr),pr.component("toggle",vr),pr.component("video",ai),pr.component("close",zi),pr.component("marker",Oi),pr.component("navbarToggleIcon",Oi),pr.component("overlayIcon",Oi),pr.component("paginationNext",Oi),pr.component("paginationPrevious",Oi),pr.component("searchIcon",Bi),pr.component("slidenavNext",Di),pr.component("slidenavPrevious",Di),pr.component("spinner",Pi),pr.component("totop",Oi),pr.use(ri);var wr={mixins:[ti],props:{date:String,clsWrapper:String},data:{date:"",clsWrapper:".uk-countdown-%unit%"},computed:{date:function(t){var e=t.date;return Date.parse(e)},days:function(t,e){return Se(t.clsWrapper.replace("%unit%","days"),e)},hours:function(t,e){return Se(t.clsWrapper.replace("%unit%","hours"),e)},minutes:function(t,e){return Se(t.clsWrapper.replace("%unit%","minutes"),e)},seconds:function(t,e){return Se(t.clsWrapper.replace("%unit%","seconds"),e)},units:function(){var e=this;return ["days","hours","minutes","seconds"].filter(function(t){return e[t]})}},connected:function(){this.start();},disconnected:function(){var e=this;this.stop(),this.units.forEach(function(t){return le(e[t])});},events:[{name:"visibilitychange",el:document,handler:function(){document.hidden?this.stop():this.start();}}],update:{write:function(){var i=this,r=function(t){var e=t-Date.now();return {total:e,seconds:e/1e3%60,minutes:e/1e3/60%60,hours:e/1e3/60/60%24,days:e/1e3/60/60/24}}(this.date);r.total<=0&&(this.stop(),r.days=r.hours=r.minutes=r.seconds=0),this.units.forEach(function(t){var e=String(Math.floor(r[t]));e=e.length<2?"0"+e:e;var n=i[t];n.textContent!==e&&((e=e.split("")).length!==n.children.length&&de(n,e.map(function(){return "<span></span>"}).join("")),e.forEach(function(t,e){return n.children[e].textContent=t}));});}},methods:{start:function(){var t=this;this.stop(),this.date&&this.units.length&&(this.$emit(),this.timer=setInterval(function(){return t.$emit()},1e3));},stop:function(){this.timer&&(clearInterval(this.timer),this.timer=null);}}};var br,yr="uk-animation-target",xr={props:{animation:Number},data:{animation:150},computed:{target:function(){return this.$el}},methods:{animate:function(t){var i=this;!function(){if(br)return;(br=fe(document.head,"<style>").sheet).insertRule("."+yr+" > * {\n            margin-top: 0 !important;\n            transform: none !important;\n        }",0);}();var r=V(this.target.children),o=r.map(function(t){return kr(t,!0)}),e=on(this.target),n=window.pageYOffset;t(),Ue.cancel(this.target),r.forEach(Ue.cancel),$r(this.target),this.$update(this.target),xn.flush();var s=on(this.target),a=(r=r.concat(V(this.target.children).filter(function(t){return !y(r,t)}))).map(function(t,e){return !!(t.parentNode&&e in o)&&(o[e]?Et(t)?Ir(t):{opacity:0}:{opacity:Et(t)?1:0})});return o=a.map(function(t,e){var n=r[e].parentNode===i.target&&(o[e]||kr(r[e]));if(n)if(t){if(!("opacity"in t)){n.opacity%1?t.opacity=1:delete n.opacity;}}else delete n.opacity;return n}),Ae(this.target,yr),r.forEach(function(t,e){return o[e]&&He(t,o[e])}),He(this.target,"height",e),mn(window,n),Yt.all(r.map(function(t,e){return o[e]&&a[e]?Ue.start(t,a[e],i.animation,"ease"):Yt.resolve()}).concat(Ue.start(this.target,{height:s},this.animation,"ease"))).then(function(){r.forEach(function(t,e){return He(t,{display:0===a[e].opacity?"none":"",zIndex:""})}),$r(i.target),i.$update(i.target),xn.flush();},Q)}}};function kr(t,e){var n=He(t,"zIndex");return !!Et(t)&&X({display:"",opacity:e?He(t,"opacity"):"0",pointerEvents:"none",position:"absolute",zIndex:"auto"===n?ce(t):n},Ir(t))}function $r(t){He(t.children,{height:"",left:"",opacity:"",pointerEvents:"",position:"",top:"",width:""}),Ce(t,yr),He(t,"height","");}function Ir(t){var e=t.getBoundingClientRect(),n=e.height,i=e.width,r=rn(t),o=r.top,s=r.left;return {top:o+=j(He(t,"marginTop")),left:s,height:n,width:i}}var Sr={mixins:[xr],args:"target",props:{target:Boolean,selActive:Boolean},data:{target:null,selActive:!1,attrItem:"uk-filter-control",cls:"uk-active",animation:250},computed:{toggles:{get:function(t,e){t.attrItem;return Te("["+this.attrItem+"],[data-"+this.attrItem+"]",e)},watch:function(){this.updateState();}},target:function(t,e){return Se(t.target,e)},children:{get:function(){return V(this.target&&this.target.children)},watch:function(t,e){!function(t,e){return t.length===e.length&&t.every(function(t){return ~e.indexOf(t)})}(t,e)&&this.updateState();}}},events:[{name:"click",delegate:function(){return "["+this.attrItem+"],[data-"+this.attrItem+"]"},handler:function(t){t.preventDefault(),this.apply(t.current);}}],connected:function(){var e=this;if(this.updateState(),!1!==this.selActive){var n=Te(this.selActive,this.$el);this.toggles.forEach(function(t){return Oe(t,e.cls,y(n,t))});}},methods:{apply:function(t){this.setState(Er(t,this.attrItem,this.getState()));},getState:function(){var n=this;return this.toggles.filter(function(t){return Me(t,n.cls)}).reduce(function(t,e){return Er(e,n.attrItem,t)},{filter:{"":""},sort:[]})},setState:function(o,t){var s=this;void 0===t&&(t=!0),o=X({filter:{"":""},sort:[]},o),Bt(this.$el,"beforeFilter",[this,o]);var a=this.children;this.toggles.forEach(function(t){return Oe(t,s.cls,!!function(t,e,n){var i=n.filter;void 0===i&&(i={"":""});var r=n.sort,o=r[0],s=r[1],a=Tr(t,e),h=a.filter;void 0===h&&(h="");var c=a.group;void 0===c&&(c="");var u=a.sort,l=a.order;void 0===l&&(l="asc");return H(u)?c in i&&h===i[c]||!h&&c&&!(c in i)&&!i[""]:o===u&&s===l}(t,s.attrItem,o))});function e(){var e=function(t){var e=t.filter,n="";return K(e,function(t){return n+=t||""}),n}(o);a.forEach(function(t){return He(t,"display",e&&!bt(t,e)?"none":"")});var t=o.sort,n=t[0],i=t[1];if(n){var r=function(t,n,i){return X([],t).sort(function(t,e){return st(t,n).localeCompare(st(e,n),void 0,{numeric:!0})*("asc"===i||-1)})}(a,n,i);q(r,a)||r.forEach(function(t){return fe(s.target,t)});}}t?this.animate(e).then(function(){return Bt(s.$el,"afterFilter",[s])}):(e(),Bt(this.$el,"afterFilter",[this]));},updateState:function(){var t=this;xn.write(function(){return t.setState(t.getState(),!1)});}}};function Tr(t,e){return Mn(st(t,e),["filter"])}function Er(t,e,n){var i=Tr(t,e),r=i.filter,o=i.group,s=i.sort,a=i.order;return void 0===a&&(a="asc"),(r||H(s))&&(o?r?(delete n.filter[""],n.filter[o]=r):(delete n.filter[o],(P(n.filter)||""in n.filter)&&(n.filter={"":r||""})):n.filter={"":r||""}),H(s)||(n.sort=[s,a]),n}var Ar={slide:{show:function(t){return [{transform:Nr(-100*t)},{transform:Nr()}]},percent:function(t){return Cr(t)},translate:function(t,e){return [{transform:Nr(-100*e*t)},{transform:Nr(100*e*(1-t))}]}}};function Cr(t){return Math.abs(He(t,"transform").split(",")[4]/t.offsetWidth)||0}function Nr(t,e){return void 0===t&&(t=0),void 0===e&&(e="%"),t+=t?e:"",Jt?"translateX("+t+")":"translate3d("+t+", 0, 0)"}function _r(t){return "scale3d("+t+", "+t+", 1)"}var Mr=X({},Ar,{fade:{show:function(){return [{opacity:0},{opacity:1}]},percent:function(t){return 1-He(t,"opacity")},translate:function(t){return [{opacity:1-t},{opacity:t}]}},scale:{show:function(){return [{opacity:0,transform:_r(.8)},{opacity:1,transform:_r(1)}]},percent:function(t){return 1-He(t,"opacity")},translate:function(t){return [{opacity:1-t,transform:_r(1-.2*t)},{opacity:t,transform:_r(.8+.2*t)}]}}});function Or(t,e,n){Bt(t,zt(e,!1,!1,n));}var Dr={mixins:[{props:{autoplay:Boolean,autoplayInterval:Number,pauseOnHover:Boolean},data:{autoplay:!1,autoplayInterval:7e3,pauseOnHover:!0},connected:function(){this.autoplay&&this.startAutoplay();},disconnected:function(){this.stopAutoplay();},update:function(){it(this.slides,"tabindex","-1");},events:[{name:"visibilitychange",el:document,filter:function(){return this.autoplay},handler:function(){document.hidden?this.stopAutoplay():this.startAutoplay();}},{name:"mouseenter",filter:function(){return this.autoplay&&this.pauseOnHover},handler:function(){this.isHovering=!0;}},{name:"mouseleave",filter:function(){return this.autoplay&&this.pauseOnHover},handler:function(){this.isHovering=!1;}}],methods:{startAutoplay:function(){var t=this;this.stopAutoplay(),this.interval=setInterval(function(){return !_t(document.activeElement,t.$el)&&!t.isHovering&&!t.stack.length&&t.show("next")},this.autoplayInterval);},stopAutoplay:function(){this.interval&&clearInterval(this.interval);}}},{props:{draggable:Boolean},data:{draggable:!0,threshold:10},created:function(){var i=this;["start","move","end"].forEach(function(t){var n=i[t];i[t]=function(t){var e=Wt(t).x*(Zt?-1:1);i.prevPos=e!==i.pos?i.pos:i.prevPos,i.pos=e,n(t);};});},events:[{name:ne,delegate:function(){return this.selSlides},handler:function(t){!this.draggable||!jt(t)&&function(t){return !t.children.length&&t.childNodes.length}(t.target)||0<t.button||this.length<2||this.start(t);}},{name:"touchmove",passive:!1,handler:"move",delegate:function(){return this.selSlides}},{name:"dragstart",handler:function(t){t.preventDefault();}}],methods:{start:function(){var t=this;this.drag=this.pos,this._transitioner?(this.percent=this._transitioner.percent(),this.drag+=this._transitioner.getDistance()*this.percent*this.dir,this._transitioner.cancel(),this._transitioner.translate(this.percent),this.dragging=!0,this.stack=[]):this.prevIndex=this.index;var e="touchmove"!=ie?Mt(document,ie,this.move,{passive:!1}):Q;this.unbindMove=function(){e(),t.unbindMove=null;},Mt(window,"scroll",this.unbindMove),Mt(document,re,this.end,!0),He(this.list,"userSelect","none");},move:function(t){var e=this;if(this.unbindMove){var n=this.pos-this.drag;if(!(0==n||this.prevPos===this.pos||!this.dragging&&Math.abs(n)<this.threshold)){He(this.list,"pointerEvents","none"),t.cancelable&&t.preventDefault(),this.dragging=!0,this.dir=n<0?1:-1;for(var i=this.slides,r=this.prevIndex,o=Math.abs(n),s=this.getIndex(r+this.dir,r),a=this._getDistance(r,s)||i[r].offsetWidth;s!==r&&a<o;)this.drag-=a*this.dir,r=s,o-=a,s=this.getIndex(r+this.dir,r),a=this._getDistance(r,s)||i[r].offsetWidth;this.percent=o/a;var h,c=i[r],u=i[s],l=this.index!==s,d=r===s;[this.index,this.prevIndex].filter(function(t){return !y([s,r],t)}).forEach(function(t){Bt(i[t],"itemhidden",[e]),d&&(h=!0,e.prevIndex=r);}),(this.index===r&&this.prevIndex!==r||h)&&Bt(i[this.index],"itemshown",[this]),l&&(this.prevIndex=r,this.index=s,d||Bt(c,"beforeitemhide",[this]),Bt(u,"beforeitemshow",[this])),this._transitioner=this._translate(Math.abs(this.percent),c,!d&&u),l&&(d||Bt(c,"itemhide",[this]),Bt(u,"itemshow",[this]));}}},end:function(){if(Ot(window,"scroll",this.unbindMove),this.unbindMove&&this.unbindMove(),Ot(document,re,this.end,!0),this.dragging)if(this.dragging=null,this.index===this.prevIndex)this.percent=1-this.percent,this.dir*=-1,this._show(!1,this.index,!0),this._transitioner=null;else{var t=(Zt?this.dir*(Zt?1:-1):this.dir)<0==this.prevPos>this.pos;this.index=t?this.index:this.prevIndex,t&&(this.percent=1-this.percent),this.show(0<this.dir&&!t||this.dir<0&&t?"next":"previous",!0);}He(this.list,{userSelect:"",pointerEvents:""}),this.drag=this.percent=null;}}},{data:{selNav:!1},computed:{nav:function(t,e){return Se(t.selNav,e)},selNavItem:function(t){var e=t.attrItem;return "["+e+"],[data-"+e+"]"},navItems:function(t,e){return Te(this.selNavItem,e)}},update:{write:function(){var n=this;this.nav&&this.length!==this.nav.children.length&&de(this.nav,this.slides.map(function(t,e){return "<li "+n.attrItem+'="'+e+'"><a href="#"></a></li>'}).join("")),Oe(Te(this.selNavItem,this.$el).concat(this.nav),"uk-hidden",!this.maxIndex),this.updateNav();},events:["resize"]},events:[{name:"click",delegate:function(){return this.selNavItem},handler:function(t){t.preventDefault(),this.show(st(t.current,this.attrItem));}},{name:"itemshow",handler:"updateNav"}],methods:{updateNav:function(){var n=this,i=this.getValidIndex();this.navItems.forEach(function(t){var e=st(t,n.attrItem);Oe(t,n.clsActive,F(e)===i),Oe(t,"uk-invisible",n.finite&&("previous"===e&&0===i||"next"===e&&i>=n.maxIndex));});}}}],props:{clsActivated:Boolean,easing:String,index:Number,finite:Boolean,velocity:Number},data:function(){return {easing:"ease",finite:!1,velocity:1,index:0,stack:[],percent:0,clsActive:"uk-active",clsActivated:!1,Transitioner:!1,transitionOptions:{}}},computed:{duration:function(t,e){var n=t.velocity;return Br(e.offsetWidth/n)},length:function(){return this.slides.length},list:function(t,e){return Se(t.selList,e)},maxIndex:function(){return this.length-1},selSlides:function(t){return t.selList+" > *"},slides:function(){return V(this.list.children)}},events:{itemshown:function(){this.$update(this.list);}},methods:{show:function(t,e){var n=this;if(void 0===e&&(e=!1),!this.dragging&&this.length){var i=this.stack,r=e?0:i.length,o=function(){i.splice(r,1),i.length&&n.show(i.shift(),!0);};if(i[e?"unshift":"push"](t),!e&&1<i.length)2===i.length&&this._transitioner.forward(Math.min(this.duration,200));else{var s=this.index,a=Me(this.slides,this.clsActive)&&this.slides[s],h=this.getIndex(t,this.index),c=this.slides[h];if(a!==c){if(this.dir=function(t,e){return "next"===t?1:"previous"===t?-1:t<e?-1:1}(t,s),this.prevIndex=s,this.index=h,a&&Bt(a,"beforeitemhide",[this]),!Bt(c,"beforeitemshow",[this,a]))return this.index=this.prevIndex,void o();var u=this._show(a,c,e).then(function(){return a&&Bt(a,"itemhidden",[n]),Bt(c,"itemshown",[n]),new Yt(function(t){xn.write(function(){i.shift(),i.length?n.show(i.shift(),!0):n._transitioner=null,t();});})});return a&&Bt(a,"itemhide",[this]),Bt(c,"itemshow",[this]),u}o();}}},getIndex:function(t,e){return void 0===t&&(t=this.index),void 0===e&&(e=this.index),Z(ue(t,this.slides,e,this.finite),0,this.maxIndex)},getValidIndex:function(t,e){return void 0===t&&(t=this.index),void 0===e&&(e=this.prevIndex),this.getIndex(t,e)},_show:function(t,e,n){if(this._transitioner=this._getTransitioner(t,e,this.dir,X({easing:n?e.offsetWidth<600?"cubic-bezier(0.25, 0.46, 0.45, 0.94)":"cubic-bezier(0.165, 0.84, 0.44, 1)":this.easing},this.transitionOptions)),!n&&!t)return this._transitioner.translate(1),Yt.resolve();var i=this.stack.length;return this._transitioner[1<i?"forward":"show"](1<i?Math.min(this.duration,75+75/(i-1)):this.duration,this.percent)},_getDistance:function(t,e){return new this._getTransitioner(t,t!==e&&e).getDistance()},_translate:function(t,e,n){void 0===e&&(e=this.prevIndex),void 0===n&&(n=this.index);var i=this._getTransitioner(e!==n&&e,n);return i.translate(t),i},_getTransitioner:function(t,e,n,i){return void 0===t&&(t=this.prevIndex),void 0===e&&(e=this.index),void 0===n&&(n=this.dir||1),void 0===i&&(i=this.transitionOptions),new this.Transitioner(B(t)?this.slides[t]:t,B(e)?this.slides[e]:e,n*(Zt?-1:1),i)}}};function Br(t){return .5*t+300}var zr={mixins:[Dr],props:{animation:String},data:{animation:"slide",clsActivated:"uk-transition-active",Animations:Ar,Transitioner:function(o,s,a,t){var e=t.animation,h=t.easing,n=e.percent,i=e.translate,r=e.show;void 0===r&&(r=Q);var c=r(a),u=new Vt;return {dir:a,show:function(t,e,n){var i=this;void 0===e&&(e=0);var r=n?"linear":h;return t-=Math.round(t*Z(e,-1,1)),this.translate(e),Or(s,"itemin",{percent:e,duration:t,timing:r,dir:a}),Or(o,"itemout",{percent:1-e,duration:t,timing:r,dir:a}),Yt.all([Ue.start(s,c[1],t,r),Ue.start(o,c[0],t,r)]).then(function(){i.reset(),u.resolve();},Q),u.promise},stop:function(){return Ue.stop([s,o])},cancel:function(){Ue.cancel([s,o]);},reset:function(){for(var t in c[0])He([s,o],t,"");},forward:function(t,e){return void 0===e&&(e=this.percent()),Ue.cancel([s,o]),this.show(t,e,!0)},translate:function(t){this.reset();var e=i(t,a);He(s,e[1]),He(o,e[0]),Or(s,"itemtranslatein",{percent:t,dir:a}),Or(o,"itemtranslateout",{percent:1-t,dir:a});},percent:function(){return n(o||s,s,a)},getDistance:function(){return o&&o.offsetWidth}}}},computed:{animation:function(t){var e=t.animation,n=t.Animations;return X(e in n?n[e]:n.slide,{name:e})},transitionOptions:function(){return {animation:this.animation}}},events:{"itemshow itemhide itemshown itemhidden":function(t){var e=t.target;this.$update(e);},beforeitemshow:function(t){Ae(t.target,this.clsActive);},itemshown:function(t){Ae(t.target,this.clsActivated);},itemhidden:function(t){Ce(t.target,this.clsActive,this.clsActivated);}}},Pr={mixins:[Qi,tr,ei,zr],functional:!0,props:{delayControls:Number,preload:Number,videoAutoplay:Boolean,template:String},data:function(){return {preload:1,videoAutoplay:!1,delayControls:3e3,items:[],cls:"uk-open",clsPage:"uk-lightbox-page",selList:".uk-lightbox-items",attrItem:"uk-lightbox-item",selClose:".uk-close-large",pauseOnHover:!1,velocity:2,Animations:Mr,template:'<div class="uk-lightbox uk-overflow-hidden"> <ul class="uk-lightbox-items"></ul> <div class="uk-lightbox-toolbar uk-position-top uk-text-right uk-transition-slide-top uk-transition-opaque"> <button class="uk-lightbox-toolbar-icon uk-close-large" type="button" uk-close></button> </div> <a class="uk-lightbox-button uk-position-center-left uk-position-medium uk-transition-fade" href="#" uk-slidenav-previous uk-lightbox-item="previous"></a> <a class="uk-lightbox-button uk-position-center-right uk-position-medium uk-transition-fade" href="#" uk-slidenav-next uk-lightbox-item="next"></a> <div class="uk-lightbox-toolbar uk-lightbox-caption uk-position-bottom uk-text-center uk-transition-slide-bottom uk-transition-opaque"></div> </div>'}},created:function(){var t=this;this.$mount(fe(this.container,this.template)),this.caption=Se(".uk-lightbox-caption",this.$el),this.items.forEach(function(){return fe(t.list,"<li></li>")});},events:[{name:ie+" "+ne+" keydown",handler:"showControls"},{name:"click",self:!0,delegate:function(){return this.selSlides},handler:function(t){t.defaultPrevented||this.hide();}},{name:"shown",self:!0,handler:function(){this.showControls();}},{name:"hide",self:!0,handler:function(){this.hideControls(),Ce(this.slides,this.clsActive),Ue.stop(this.slides);}},{name:"hidden",self:!0,handler:function(){this.$destroy(!0);}},{name:"keyup",el:document,handler:function(t){if(this.isToggled(this.$el))switch(t.keyCode){case 37:this.show("previous");break;case 39:this.show("next");}}},{name:"beforeitemshow",handler:function(t){this.isToggled()||(this.draggable=!1,t.preventDefault(),this.toggleNow(this.$el,!0),this.animation=Mr.scale,Ce(t.target,this.clsActive),this.stack.splice(1,0,this.index));}},{name:"itemshow",handler:function(t){var e=ce(t.target),n=this.getItem(e).caption;He(this.caption,"display",n?"":"none"),de(this.caption,n);for(var i=0;i<=this.preload;i++)this.loadItem(this.getIndex(e+i)),this.loadItem(this.getIndex(e-i));}},{name:"itemshown",handler:function(){this.draggable=this.$props.draggable;}},{name:"itemload",handler:function(t,r){var o,s=this,e=r.source,n=r.type,i=r.alt;if(this.setItem(r,"<span uk-spinner></span>"),e)if("image"===n||e.match(/\.(jp(e)?g|png|gif|svg|webp)($|\?)/i))Gt(e).then(function(t){return s.setItem(r,'<img width="'+t.width+'" height="'+t.height+'" src="'+e+'" alt="'+(i||"")+'">')},function(){return s.setError(r)});else if("video"===n||e.match(/\.(mp4|webm|ogv)($|\?)/i)){var a=Se("<video controls playsinline"+(r.poster?' poster="'+r.poster+'"':"")+' uk-video="'+this.videoAutoplay+'"></video>');it(a,"src",e),Dt(a,"error loadedmetadata",function(t){"error"===t?s.setError(r):(it(a,{width:a.videoWidth,height:a.videoHeight}),s.setItem(r,a));});}else if("iframe"===n||e.match(/\.(html|php)($|\?)/i))this.setItem(r,'<iframe class="uk-lightbox-iframe" src="'+e+'" frameborder="0" allowfullscreen></iframe>');else if(o=e.match(/\/\/.*?youtube(-nocookie)?\.[a-z]+\/watch\?v=([^&\s]+)/)||e.match(/()youtu\.be\/(.*)/)){var h=o[2],c=function(t,e){return void 0===t&&(t=640),void 0===e&&(e=450),s.setItem(r,Hr("https://www.youtube"+(o[1]||"")+".com/embed/"+h,t,e,s.videoAutoplay))};Gt("https://img.youtube.com/vi/"+h+"/maxresdefault.jpg").then(function(t){var e=t.width,n=t.height;120===e&&90===n?Gt("https://img.youtube.com/vi/"+h+"/0.jpg").then(function(t){var e=t.width,n=t.height;return c(e,n)},c):c(e,n);},c);}else(o=e.match(/(\/\/.*?)vimeo\.[a-z]+\/([0-9]+).*?/))&&Kt("https://vimeo.com/api/oembed.json?maxwidth=1920&url="+encodeURI(e),{responseType:"json",withCredentials:!1}).then(function(t){var e=t.response,n=e.height,i=e.width;return s.setItem(r,Hr("https://player.vimeo.com/video/"+o[2],i,n,s.videoAutoplay))},function(){return s.setError(r)});}}],methods:{loadItem:function(t){void 0===t&&(t=this.index);var e=this.getItem(t);e.content||Bt(this.$el,"itemload",[e]);},getItem:function(t){return void 0===t&&(t=this.index),this.items[t]||{}},setItem:function(t,e){X(t,{content:e});var n=de(this.slides[this.items.indexOf(t)],e);Bt(this.$el,"itemloaded",[this,n]),this.$update(n);},setError:function(t){this.setItem(t,'<span uk-icon="icon: bolt; ratio: 2"></span>');},showControls:function(){clearTimeout(this.controlsTimer),this.controlsTimer=setTimeout(this.hideControls,this.delayControls),Ae(this.$el,"uk-active","uk-transition-active");},hideControls:function(){Ce(this.$el,"uk-active","uk-transition-active");}}};function Hr(t,e,n,i){return '<iframe src="'+t+'" width="'+e+'" height="'+n+'" style="max-width: 100%; box-sizing: border-box;" frameborder="0" allowfullscreen uk-video="autoplay: '+i+'" uk-responsive></iframe>'}var Lr,Fr={install:function(t,e){t.lightboxPanel||t.component("lightboxPanel",Pr);X(e.props,t.component("lightboxPanel").options.props);},props:{toggle:String},data:{toggle:"a"},computed:{toggles:{get:function(t,e){return Te(t.toggle,e)},watch:function(){this.hide();}},items:function(){return J(this.toggles.map(jr),"source")}},disconnected:function(){this.hide();},events:[{name:"click",delegate:function(){return this.toggle+":not(.uk-disabled)"},handler:function(t){t.preventDefault();var e=st(t.current,"href");this.show(k(this.items,function(t){return t.source===e}));}}],methods:{show:function(t){var e=this;return this.panel=this.panel||this.$create("lightboxPanel",X({},this.$props,{items:this.items})),Mt(this.panel.$el,"hidden",function(){return e.panel=!1}),this.panel.show(t)},hide:function(){return this.panel&&this.panel.hide()}}};function jr(n){return ["href","caption","type","poster","alt"].reduce(function(t,e){return t["href"===e?"source":e]=st(n,e),t},{})}var Wr={},Vr={functional:!0,args:["message","status"],data:{message:"",status:"",timeout:5e3,group:null,pos:"top-center",clsClose:"uk-notification-close",clsMsg:"uk-notification-message"},install:function(r){r.notification.closeAll=function(n,i){Ie(document.body,function(t){var e=r.getComponent(t,"notification");!e||n&&n!==e.group||e.close(i);});};},computed:{marginProp:function(t){return "margin"+(w(t.pos,"top")?"Top":"Bottom")},startProps:function(){var t;return (t={opacity:0})[this.marginProp]=-this.$el.offsetHeight,t}},created:function(){Wr[this.pos]||(Wr[this.pos]=fe(this.$container,'<div class="uk-notification uk-notification-'+this.pos+'"></div>'));var t=He(Wr[this.pos],"display","block");this.$mount(fe(t,'<div class="'+this.clsMsg+(this.status?" "+this.clsMsg+"-"+this.status:"")+'"> <a href="#" class="'+this.clsClose+'" data-uk-close></a> <div>'+this.message+"</div> </div>"));},connected:function(){var t,e=this,n=j(He(this.$el,this.marginProp));Ue.start(He(this.$el,this.startProps),((t={opacity:1})[this.marginProp]=n,t)).then(function(){e.timeout&&(e.timer=setTimeout(e.close,e.timeout));});},events:(Lr={click:function(t){xt(t.target,'a[href="#"],a[href=""]')&&t.preventDefault(),this.close();}},Lr[oe]=function(){this.timer&&clearTimeout(this.timer);},Lr[se]=function(){this.timeout&&(this.timer=setTimeout(this.close,this.timeout));},Lr),methods:{close:function(t){function e(){Bt(n.$el,"close",[n]),ve(n.$el),Wr[n.pos].children.length||He(Wr[n.pos],"display","none");}var n=this;this.timer&&clearTimeout(this.timer),t?e():Ue.start(this.$el,this.startProps).then(e);}}};var Yr=["x","y","bgx","bgy","rotate","scale","color","backgroundColor","borderColor","opacity","blur","hue","grayscale","invert","saturate","sepia","fopacity","stroke"],Rr={mixins:[Ki],props:Yr.reduce(function(t,e){return t[e]="list",t},{}),data:Yr.reduce(function(t,e){return t[e]=void 0,t},{}),computed:{props:function(m,g){var v=this;return Yr.reduce(function(t,e){if(H(m[e]))return t;var n,i,r,o=e.match(/color/i),s=o||"opacity"===e,a=m[e].slice(0);s&&He(g,e,""),a.length<2&&a.unshift(("scale"===e?1:s?He(g,e):0)||0);var h=function(t){return t.reduce(function(t,e){return D(e)&&e.replace(/-|\d/g,"").trim()||t},"")}(a);if(o){var c=g.style.color;a=a.map(function(t){return function(t,e){return He(He(t,"color",e),"color").split(/[(),]/g).slice(1,-1).concat(1).slice(0,4).map(j)}(g,t)}),g.style.color=c;}else if(w(e,"bg")){var u="bgy"===e?"height":"width";if(a=a.map(function(t){return vn(t,u,v.$el)}),He(g,"background-position-"+e[2],""),i=He(g,"backgroundPosition").split(" ")["x"===e[2]?0:1],v.covers){var l=Math.min.apply(Math,a),d=Math.max.apply(Math,a),f=a.indexOf(l)<a.indexOf(d);r=d-l,a=a.map(function(t){return t-(f?l:d)}),n=(f?-r:0)+"px";}else n=i;}else a=a.map(j);if("stroke"===e){if(!a.some(function(t){return t}))return t;var p=Ai(v.$el);He(g,"strokeDasharray",p),"%"===h&&(a=a.map(function(t){return t*p/100})),a=a.reverse(),e="strokeDashoffset";}return t[e]={steps:a,unit:h,pos:n,bgPos:i,diff:r},t},{})},bgProps:function(){var e=this;return ["bgx","bgy"].filter(function(t){return t in e.props})},covers:function(t,e){return function(t){var e=t.style.backgroundSize,n="cover"===He(He(t,"backgroundSize",""),"backgroundSize");return t.style.backgroundSize=e,n}(e)}},disconnected:function(){delete this._image;},update:{read:function(t){var h=this;if(t.active=this.matchMedia,t.active){if(!t.image&&this.covers&&this.bgProps.length){var e=He(this.$el,"backgroundImage").replace(/^none|url\(["']?(.+?)["']?\)$/,"$1");if(e){var n=new Image;n.src=e,(t.image=n).naturalWidth||(n.onload=function(){return h.$emit()});}}var i=t.image;if(i&&i.naturalWidth){var c={width:this.$el.offsetWidth,height:this.$el.offsetHeight},u={width:i.naturalWidth,height:i.naturalHeight},l=nt.cover(u,c);this.bgProps.forEach(function(t){var e=h.props[t],n=e.diff,i=e.bgPos,r=e.steps,o="bgy"===t?"height":"width",s=l[o]-c[o];if(s<n)c[o]=l[o]+n-s;else if(n<s){var a=c[o]/vn(i,o,h.$el);a&&(h.props[t].steps=r.map(function(t){return t-(s-n)/a}));}l=nt.cover(u,c);}),t.dim=l;}}},write:function(t){var e=t.dim;t.active?e&&He(this.$el,{backgroundSize:e.width+"px "+e.height+"px",backgroundRepeat:"no-repeat"}):He(this.$el,{backgroundSize:"",backgroundRepeat:""});},events:["resize"]},methods:{reset:function(){var n=this;K(this.getCss(0),function(t,e){return He(n.$el,e,"")});},getCss:function(l){var d=this.props;return Object.keys(d).reduce(function(t,e){var n=d[e],i=n.steps,r=n.unit,o=n.pos,s=function(t,e,n){void 0===n&&(n=2);var i=qr(t,e),r=i[0],o=i[1],s=i[2];return (B(r)?r+Math.abs(r-o)*s*(r<o?1:-1):+o).toFixed(n)}(i,l);switch(e){case"x":case"y":r=r||"px",t.transform+=" translate"+p(e)+"("+j(s).toFixed("px"===r?0:2)+r+")";break;case"rotate":r=r||"deg",t.transform+=" rotate("+(s+r)+")";break;case"scale":t.transform+=" scale("+s+")";break;case"bgy":case"bgx":t["background-position-"+e[2]]="calc("+o+" + "+s+"px)";break;case"color":case"backgroundColor":case"borderColor":var a=qr(i,l),h=a[0],c=a[1],u=a[2];t[e]="rgba("+h.map(function(t,e){return t+=u*(c[e]-t),3===e?j(t):parseInt(t,10)}).join(",")+")";break;case"blur":r=r||"px",t.filter+=" blur("+(s+r)+")";break;case"hue":r=r||"deg",t.filter+=" hue-rotate("+(s+r)+")";break;case"fopacity":r=r||"%",t.filter+=" opacity("+(s+r)+")";break;case"grayscale":case"invert":case"saturate":case"sepia":r=r||"%",t.filter+=" "+e+"("+(s+r)+")";break;default:t[e]=s;}return t},{transform:"",filter:""})}}};function qr(t,e){var n=t.length-1,i=Math.min(Math.floor(n*e),n-1),r=t.slice(i,i+2);return r.push(1===e?1:e%(1/n)*n),r}var Ur={mixins:[Rr],props:{target:String,viewport:Number,easing:Number},data:{target:!1,viewport:1,easing:1},computed:{target:function(t,e){var n=t.target;return function t(e){return e?"offsetTop"in e?e:t(e.parentNode):document.body}(n&&at(n,e)||e)}},update:{read:function(t,e){var n=t.percent;if("scroll"!==e&&(n=!1),t.active){var i=n;return {percent:n=function(t,e){return Z(t*(1-(e-e*t)))}(pn(this.target)/(this.viewport||1),this.easing),style:i!==n&&this.getCss(n)}}},write:function(t){var e=t.style;t.active?e&&He(this.$el,e):this.reset();},events:["scroll","resize"]}};var Xr={update:{write:function(){if(!this.stack.length&&!this.dragging){var t=this.getValidIndex();delete this.index,Ce(this.slides,this.clsActive,this.clsActivated),this.show(t);}},events:["resize"]}};function Kr(t,e,n){var i=Zr(t,e);return n?i-function(t,e){return Qr(e).width/2-Qr(t).width/2}(t,e):Math.min(i,Gr(e))}function Gr(t){return Math.max(0,Jr(t)-Qr(t).width)}function Jr(t){return eo(t).reduce(function(t,e){return Qr(e).width+t},0)}function Zr(t,e){return (rn(t).left+(Zt?Qr(t).width-Qr(e).width:0))*(Zt?-1:1)}function Qr(t){return t.getBoundingClientRect()}function to(t,e,n){Bt(t,zt(e,!1,!1,n));}function eo(t){return V(t.children)}var no={mixins:[ti,Dr,Xr],props:{center:Boolean,sets:Boolean},data:{center:!1,sets:!1,attrItem:"uk-slider-item",selList:".uk-slider-items",selNav:".uk-slider-nav",clsContainer:"uk-slider-container",Transitioner:function(r,i,o,t){var e=t.center,s=t.easing,a=t.list,h=new Vt,n=r?Kr(r,a,e):Kr(i,a,e)+Qr(i).width*o,c=i?Kr(i,a,e):n+Qr(r).width*o*(Zt?-1:1);return {dir:o,show:function(t,e,n){void 0===e&&(e=0);var i=n?"linear":s;return t-=Math.round(t*Z(e,-1,1)),this.translate(e),r&&this.updateTranslates(),e=r?e:Z(e,0,1),to(this.getItemIn(),"itemin",{percent:e,duration:t,timing:i,dir:o}),r&&to(this.getItemIn(!0),"itemout",{percent:1-e,duration:t,timing:i,dir:o}),Ue.start(a,{transform:Nr(-c*(Zt?-1:1),"px")},t,i).then(h.resolve,Q),h.promise},stop:function(){return Ue.stop(a)},cancel:function(){Ue.cancel(a);},reset:function(){He(a,"transform","");},forward:function(t,e){return void 0===e&&(e=this.percent()),Ue.cancel(a),this.show(t,e,!0)},translate:function(t){var e=this.getDistance()*o*(Zt?-1:1);He(a,"transform",Nr(Z(e-e*t-c,-Jr(a),Qr(a).width)*(Zt?-1:1),"px")),this.updateTranslates(),r&&(t=Z(t,-1,1),to(this.getItemIn(),"itemtranslatein",{percent:t,dir:o}),to(this.getItemIn(!0),"itemtranslateout",{percent:1-t,dir:o}));},percent:function(){return Math.abs((He(a,"transform").split(",")[4]*(Zt?-1:1)+n)/(c-n))},getDistance:function(){return Math.abs(c-n)},getItemIn:function(t){void 0===t&&(t=!1);var e=this.getActives(),n=G(eo(a),"offsetLeft"),i=ce(n,e[0<o*(t?-1:1)?e.length-1:0]);return ~i&&n[i+(r&&!t?o:0)]},getActives:function(){var n=Kr(r||i,a,e);return G(eo(a).filter(function(t){var e=Zr(t,a);return n<=e&&e+Qr(t).width<=Qr(a).width+n}),"offsetLeft")},updateTranslates:function(){var n=this.getActives();eo(a).forEach(function(t){var e=y(n,t);to(t,"itemtranslate"+(e?"in":"out"),{percent:e?1:0,dir:t.offsetLeft<=i.offsetLeft?1:-1});});}}}},computed:{avgWidth:function(){return Jr(this.list)/this.length},finite:function(t){return t.finite||Jr(this.list)<Qr(this.list).width+function(t){return eo(t).reduce(function(t,e){return Math.max(t,Qr(e).width)},0)}(this.list)+this.center},maxIndex:function(){if(!this.finite||this.center&&!this.sets)return this.length-1;if(this.center)return this.sets[this.sets.length-1];He(this.slides,"order","");for(var t=Gr(this.list),e=this.length;e--;)if(Zr(this.list.children[e],this.list)<t)return Math.min(e+1,this.length-1);return 0},sets:function(t){var o=this,e=t.sets,s=Qr(this.list).width/(this.center?2:1),a=0,h=s,c=0;return !P(e=e&&this.slides.reduce(function(t,e,n){var i=Qr(e).width;if(a<c+i&&(!o.center&&n>o.maxIndex&&(n=o.maxIndex),!y(t,n))){var r=o.slides[n+1];o.center&&r&&i<h-Qr(r).width/2?h-=i:(h=s,t.push(n),a=c+s+(o.center?i/2:0));}return c+=i,t},[]))&&e},transitionOptions:function(){return {center:this.center,list:this.list}}},connected:function(){Oe(this.$el,this.clsContainer,!Se("."+this.clsContainer,this.$el));},update:{write:function(){var n=this;Te("["+this.attrItem+"],[data-"+this.attrItem+"]",this.$el).forEach(function(t){var e=st(t,n.attrItem);n.maxIndex&&Oe(t,"uk-hidden",z(e)&&(n.sets&&!y(n.sets,j(e))||e>n.maxIndex));});},events:["resize"]},events:{beforeitemshow:function(t){!this.dragging&&this.sets&&this.stack.length<2&&!y(this.sets,this.index)&&(this.index=this.getValidIndex());var e=Math.abs(this.index-this.prevIndex+(0<this.dir&&this.index<this.prevIndex||this.dir<0&&this.index>this.prevIndex?(this.maxIndex+1)*this.dir:0));if(!this.dragging&&1<e){for(var n=0;n<e;n++)this.stack.splice(1,0,0<this.dir?"next":"previous");t.preventDefault();}else this.duration=Br(this.avgWidth/this.velocity)*(Qr(this.dir<0||!this.slides[this.prevIndex]?this.slides[this.index]:this.slides[this.prevIndex]).width/this.avgWidth),this.reorder();},itemshow:function(){H(this.prevIndex)||Ae(this._getTransitioner().getItemIn(),this.clsActive);},itemshown:function(){var e=this,n=this._getTransitioner(this.index).getActives();this.slides.forEach(function(t){return Oe(t,e.clsActive,y(n,t))}),this.sets&&!y(this.sets,j(this.index))||this.slides.forEach(function(t){return Oe(t,e.clsActivated,y(n,t))});}},methods:{reorder:function(){var n=this;if(He(this.slides,"order",""),!this.finite){var i=0<this.dir&&this.slides[this.prevIndex]?this.prevIndex:this.index;if(this.slides.forEach(function(t,e){return He(t,"order",0<n.dir&&e<i?1:n.dir<0&&e>=n.index?-1:"")}),this.center)for(var t=this.slides[i],e=Qr(this.list).width/2-Qr(t).width/2,r=0;0<e;){var o=this.getIndex(--r+i,i),s=this.slides[o];He(s,"order",i<o?-2:-1),e-=Qr(s).width;}}},getValidIndex:function(t,e){if(void 0===t&&(t=this.index),void 0===e&&(e=this.prevIndex),t=this.getIndex(t,e),!this.sets)return t;var n;do{if(y(this.sets,t))return t;n=t,t=this.getIndex(t+this.dir,e);}while(t!==n);return t}}},io={mixins:[Rr],data:{selItem:"!li"},computed:{item:function(t,e){return at(t.selItem,e)}},events:[{name:"itemshown",self:!0,el:function(){return this.item},handler:function(){He(this.$el,this.getCss(.5));}},{name:"itemin itemout",self:!0,el:function(){return this.item},handler:function(t){var e=t.type,n=t.detail,i=n.percent,r=n.duration,o=n.timing,s=n.dir;Ue.cancel(this.$el),He(this.$el,this.getCss(oo(e,s,i))),Ue.start(this.$el,this.getCss(ro(e)?.5:0<s?1:0),r,o).catch(Q);}},{name:"transitioncanceled transitionend",self:!0,el:function(){return this.item},handler:function(){Ue.cancel(this.$el);}},{name:"itemtranslatein itemtranslateout",self:!0,el:function(){return this.item},handler:function(t){var e=t.type,n=t.detail,i=n.percent,r=n.dir;Ue.cancel(this.$el),He(this.$el,this.getCss(oo(e,r,i)));}}]};function ro(t){return u(t,"in")}function oo(t,e,n){return n/=2,ro(t)?e<0?1-n:n:e<0?n:1-n}var so,ao=X({},Ar,{fade:{show:function(){return [{opacity:0,zIndex:0},{zIndex:-1}]},percent:function(t){return 1-He(t,"opacity")},translate:function(t){return [{opacity:1-t,zIndex:0},{zIndex:-1}]}},scale:{show:function(){return [{opacity:0,transform:_r(1.5),zIndex:0},{zIndex:-1}]},percent:function(t){return 1-He(t,"opacity")},translate:function(t){return [{opacity:1-t,transform:_r(1+.5*t),zIndex:0},{zIndex:-1}]}},pull:{show:function(t){return t<0?[{transform:Nr(30),zIndex:-1},{transform:Nr(),zIndex:0}]:[{transform:Nr(-100),zIndex:0},{transform:Nr(),zIndex:-1}]},percent:function(t,e,n){return n<0?1-Cr(e):Cr(t)},translate:function(t,e){return e<0?[{transform:Nr(30*t),zIndex:-1},{transform:Nr(-100*(1-t)),zIndex:0}]:[{transform:Nr(100*-t),zIndex:0},{transform:Nr(30*(1-t)),zIndex:-1}]}},push:{show:function(t){return t<0?[{transform:Nr(100),zIndex:0},{transform:Nr(),zIndex:-1}]:[{transform:Nr(-30),zIndex:-1},{transform:Nr(),zIndex:0}]},percent:function(t,e,n){return 0<n?1-Cr(e):Cr(t)},translate:function(t,e){return e<0?[{transform:Nr(100*t),zIndex:0},{transform:Nr(-30*(1-t)),zIndex:-1}]:[{transform:Nr(-30*t),zIndex:-1},{transform:Nr(100*(1-t)),zIndex:0}]}}}),ho={mixins:[ti,zr,Xr],props:{ratio:String,minHeight:Number,maxHeight:Number},data:{ratio:"16:9",minHeight:!1,maxHeight:!1,selList:".uk-slideshow-items",attrItem:"uk-slideshow-item",selNav:".uk-slideshow-nav",Animations:ao},update:{read:function(){var t=this.ratio.split(":").map(Number),e=t[0],n=t[1];return n=n*this.list.offsetWidth/e||0,this.minHeight&&(n=Math.max(this.minHeight,n)),this.maxHeight&&(n=Math.min(this.maxHeight,n)),{height:n-hn(this.list,"content-box")}},write:function(t){var e=t.height;He(this.list,"minHeight",e);},events:["resize"]}},co={mixins:[ti,xr],props:{group:String,threshold:Number,clsItem:String,clsPlaceholder:String,clsDrag:String,clsDragState:String,clsBase:String,clsNoDrag:String,clsEmpty:String,clsCustom:String,handle:String},data:{group:!1,threshold:5,clsItem:"uk-sortable-item",clsPlaceholder:"uk-sortable-placeholder",clsDrag:"uk-sortable-drag",clsDragState:"uk-drag",clsBase:"uk-sortable",clsNoDrag:"uk-sortable-nodrag",clsEmpty:"uk-sortable-empty",clsCustom:"",handle:!1},created:function(){var o=this;["init","start","move","end"].forEach(function(t){var r=o[t];o[t]=function(t){o.scrollY=window.pageYOffset;var e=Wt(t,"page"),n=e.x,i=e.y;o.pos={x:n,y:i},r(t);};});},events:{name:ne,passive:!1,handler:"init"},update:{write:function(){if(this.clsEmpty&&Oe(this.$el,this.clsEmpty,P(this.$el.children)),He(this.handle?Te(this.handle,this.$el):this.$el.children,{touchAction:"none",userSelect:"none"}),this.drag){en(this.drag,{top:this.pos.y+this.origin.top,left:this.pos.x+this.origin.left});var t,e=en(this.drag),n=e.top,i=n+e.height;0<n&&n<this.scrollY?t=this.scrollY-5:i<on(document)&&i>on(window)+this.scrollY&&(t=this.scrollY+5),t&&setTimeout(function(){return mn(window,t)},5);}}},methods:{init:function(t){var e=t.target,n=t.button,i=t.defaultPrevented,r=V(this.$el.children).filter(function(t){return _t(e,t)})[0];!r||i||0<n||Ct(e)||_t(e,"."+this.clsNoDrag)||this.handle&&!_t(e,this.handle)||(t.preventDefault(),this.touched=[this],this.placeholder=r,this.origin=X({target:e,index:ce(r)},this.pos),Mt(document,ie,this.move),Mt(document,re,this.end),Mt(window,"scroll",this.scroll),this.threshold||this.start(t));},start:function(t){this.drag=fe(this.$container,this.placeholder.outerHTML.replace(/^<li/i,"<div").replace(/li>$/i,"div>")),He(this.drag,X({boxSizing:"border-box",width:this.placeholder.offsetWidth,height:this.placeholder.offsetHeight},He(this.placeholder,["paddingLeft","paddingRight","paddingTop","paddingBottom"]))),it(this.drag,"uk-no-boot",""),Ae(this.drag,this.clsDrag,this.clsCustom),on(this.drag.firstElementChild,on(this.placeholder.firstElementChild));var e=en(this.placeholder),n=e.left,i=e.top;X(this.origin,{left:n-this.pos.x,top:i-this.pos.y}),Ae(this.placeholder,this.clsPlaceholder),Ae(this.$el.children,this.clsItem),Ae(document.documentElement,this.clsDragState),Bt(this.$el,"start",[this,this.placeholder]),this.move(t);},move:function(t){if(this.drag){this.$emit();var e="mousemove"===t.type?t.target:document.elementFromPoint(this.pos.x-window.pageXOffset,this.pos.y-window.pageYOffset),n=this.getSortable(e),i=this.getSortable(this.placeholder),r=n!==i;if(n&&!_t(e,this.placeholder)&&(!r||n.group&&n.group===i.group)){if(e=n.$el===e.parentNode&&e||V(n.$el.children).filter(function(t){return _t(e,t)})[0],r)i.remove(this.placeholder);else if(!e)return;n.insert(this.placeholder,e),y(this.touched,n)||this.touched.push(n);}}else(Math.abs(this.pos.x-this.origin.x)>this.threshold||Math.abs(this.pos.y-this.origin.y)>this.threshold)&&this.start(t);},end:function(t){if(Ot(document,ie,this.move),Ot(document,re,this.end),Ot(window,"scroll",this.scroll),this.drag){var e=this.getSortable(this.placeholder);this===e?this.origin.index!==ce(this.placeholder)&&Bt(this.$el,"moved",[this,this.placeholder]):(Bt(e.$el,"added",[e,this.placeholder]),Bt(this.$el,"removed",[this,this.placeholder])),Bt(this.$el,"stop",[this,this.placeholder]),ve(this.drag),this.drag=null;var n=this.touched.map(function(t){return t.clsPlaceholder+" "+t.clsItem}).join(" ");this.touched.forEach(function(t){return Ce(t.$el.children,n)}),Ce(document.documentElement,this.clsDragState);}else"touchend"===t.type&&t.target.click();},scroll:function(){var t=window.pageYOffset;t!==this.scrollY&&(this.pos.y+=t-this.scrollY,this.scrollY=t,this.$emit());},insert:function(t,e){var n=this;Ae(this.$el.children,this.clsItem);function i(){e?!_t(t,n.$el)||function(t,e){return t.parentNode===e.parentNode&&ce(t)>ce(e)}(t,e)?pe(e,t):me(e,t):fe(n.$el,t);}this.animation?this.animate(i):i();},remove:function(t){_t(t,this.$el)&&(He(this.handle?Te(this.handle,t):t,{touchAction:"",userSelect:""}),this.animation?this.animate(function(){return ve(t)}):ve(t));},getSortable:function(t){return t&&(this.$getComponent(t,"sortable")||this.getSortable(t.parentNode))}}};var uo,lo,fo,po=[],mo={mixins:[Qi,ei,ci],args:"title",props:{delay:Number,title:String},data:{pos:"top",title:"",delay:0,animation:["uk-animation-scale-up"],duration:100,cls:"uk-active",clsPos:"uk-tooltip"},beforeConnect:function(){this._hasTitle=rt(this.$el,"title"),it(this.$el,{title:"","aria-expanded":!1});},disconnected:function(){this.hide(),it(this.$el,{title:this._hasTitle?this.title:null,"aria-expanded":null});},methods:{show:function(){var e=this;this.isActive()||(po.forEach(function(t){return t.hide()}),po.push(this),this._unbind=Mt(document,re,function(t){return !_t(t.target,e.$el)&&e.hide()}),clearTimeout(this.showTimer),this.showTimer=setTimeout(function(){e._show(),e.hideTimer=setInterval(function(){Et(e.$el)||e.hide();},150);},this.delay));},hide:function(){!this.isActive()||bt(this.$el,"input")&&this.$el===document.activeElement||(po.splice(po.indexOf(this),1),clearTimeout(this.showTimer),clearInterval(this.hideTimer),it(this.$el,"aria-expanded",!1),this.toggleElement(this.tooltip,!1),this.tooltip&&ve(this.tooltip),this.tooltip=!1,this._unbind());},_show:function(){this.tooltip=fe(this.container,'<div class="'+this.clsPos+'" aria-expanded="true" aria-hidden> <div class="'+this.clsPos+'-inner">'+this.title+"</div> </div>"),this.positionAt(this.tooltip,this.$el),this.origin="y"===this.getAxis()?dn(this.dir)+"-"+this.align:this.align+"-"+dn(this.dir),this.toggleElement(this.tooltip,!0);},isActive:function(){return y(po,this)}},events:(so={focus:"show",blur:"hide"},so[oe+" "+se]=function(t){jt(t)||(t.type===oe?this.show():this.hide());},so[ne]=function(t){jt(t)&&(this.isActive()?this.hide():this.show());},so)},go={props:{allow:String,clsDragover:String,concurrent:Number,maxSize:Number,method:String,mime:String,msgInvalidMime:String,msgInvalidName:String,msgInvalidSize:String,multiple:Boolean,name:String,params:Object,type:String,url:String},data:{allow:!1,clsDragover:"uk-dragover",concurrent:1,maxSize:0,method:"POST",mime:!1,msgInvalidMime:"Invalid File Type: %s",msgInvalidName:"Invalid File Name: %s",msgInvalidSize:"Invalid File Size: %s Kilobytes Max",multiple:!1,name:"files[]",params:{},type:"",url:"",abort:Q,beforeAll:Q,beforeSend:Q,complete:Q,completeAll:Q,error:Q,fail:Q,load:Q,loadEnd:Q,loadStart:Q,progress:Q},events:{change:function(t){bt(t.target,'input[type="file"]')&&(t.preventDefault(),t.target.files&&this.upload(t.target.files),t.target.value="");},drop:function(t){wo(t);var e=t.dataTransfer;e&&e.files&&(Ce(this.$el,this.clsDragover),this.upload(e.files));},dragenter:function(t){wo(t);},dragover:function(t){wo(t),Ae(this.$el,this.clsDragover);},dragleave:function(t){wo(t),Ce(this.$el,this.clsDragover);}},methods:{upload:function(t){var i=this;if(t.length){Bt(this.$el,"upload",[t]);for(var e=0;e<t.length;e++){if(this.maxSize&&1e3*this.maxSize<t[e].size)return void this.fail(this.msgInvalidSize.replace("%s",this.maxSize));if(this.allow&&!vo(this.allow,t[e].name))return void this.fail(this.msgInvalidName.replace("%s",this.allow));if(this.mime&&!vo(this.mime,t[e].type))return void this.fail(this.msgInvalidMime.replace("%s",this.mime))}this.multiple||(t=[t[0]]),this.beforeAll(this,t);var r=function(t,e){for(var n=[],i=0;i<t.length;i+=e){for(var r=[],o=0;o<e;o++)r.push(t[i+o]);n.push(r);}return n}(t,this.concurrent),o=function(t){var e=new FormData;for(var n in t.forEach(function(t){return e.append(i.name,t)}),i.params)e.append(n,i.params[n]);Kt(i.url,{data:e,method:i.method,responseType:i.type,beforeSend:function(t){var e=t.xhr;e.upload&&Mt(e.upload,"progress",i.progress),["loadStart","load","loadEnd","abort"].forEach(function(t){return Mt(e,t.toLowerCase(),i[t])}),i.beforeSend(t);}}).then(function(t){i.complete(t),r.length?o(r.shift()):i.completeAll(t);},function(t){return i.error(t)});};o(r.shift());}}}};function vo(t,e){return e.match(new RegExp("^"+t.replace(/\//g,"\\/").replace(/\*\*/g,"(\\/[^\\/]+)*").replace(/\*/g,"[^\\/]+").replace(/((?!\\))\?/g,"$1.")+"$","i"))}function wo(t){t.preventDefault(),t.stopPropagation();}function bo(){xo(document.body,lo),xn.flush(),new MutationObserver(function(t){return t.forEach(yo)}).observe(document,{childList:!0,subtree:!0,characterData:!0,attributes:!0}),uo._initialized=!0;}function yo(t){var e=t.target;("attributes"!==t.type?function(t){for(var e=t.addedNodes,n=t.removedNodes,i=0;i<e.length;i++)xo(e[i],lo);for(var r=0;r<n.length;r++)xo(n[r],fo);return !0}(t):function(t){var e=t.target,n=t.attributeName;if("href"===n)return !0;var i=Pn(n);if(!(i&&i in uo))return;if(rt(e,n))return uo[i](e),!0;var r=uo.getComponent(e,i);if(r)return r.$destroy(),!0}(t))&&uo.update(e);}function xo(t,e){if(1===t.nodeType&&!rt(t,"uk-no-boot"))for(e(t),t=t.firstElementChild;t;){var n=t.nextElementSibling;xo(t,e),t=n;}}return Hn.component("countdown",wr),Hn.component("filter",Sr),Hn.component("lightbox",Fr),Hn.component("lightboxPanel",Pr),Hn.component("notification",Vr),Hn.component("parallax",Ur),Hn.component("slider",no),Hn.component("sliderParallax",io),Hn.component("slideshow",ho),Hn.component("slideshowParallax",io),Hn.component("sortable",co),Hn.component("tooltip",mo),Hn.component("upload",go),lo=(uo=Hn).connect,fo=uo.disconnect,"MutationObserver"in window&&(document.body?bo():new MutationObserver(function(){document.body&&(this.disconnect(),bo());}).observe(document,{childList:!0,subtree:!0})),Hn});
    });

    const app = new App({
    	target: document.getElementById("app")
    });

}(fp, shortid, _, compiler_util, lunr, safe_buffer));
//# sourceMappingURL=bundle.js.map
