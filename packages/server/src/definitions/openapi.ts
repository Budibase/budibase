/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/applications": {
    post: operations["appCreate"];
  };
  "/applications/{appId}": {
    get: operations["appGetById"];
    put: operations["appUpdate"];
    delete: operations["appDestroy"];
  };
  "/applications/{appId}/unpublish": {
    post: operations["appUnpublish"];
  };
  "/applications/{appId}/publish": {
    post: operations["appPublish"];
  };
  "/applications/{appId}/import": {
    /** This endpoint is only available on a business or enterprise license. */
    post: operations["appImport"];
  };
  "/applications/{appId}/export": {
    /** This endpoint is only available on a business or enterprise license. */
    post: operations["appExport"];
  };
  "/applications/search": {
    /** Based on application properties (currently only name) search for applications. */
    post: operations["appSearch"];
  };
  "/metrics": {
    /** Output metrics in OpenMetrics format compatible with Prometheus */
    get: operations["metricsGet"];
  };
  "/queries/{queryId}": {
    /** Queries which have been created within a Budibase app can be executed using this, */
    post: operations["queryExecute"];
  };
  "/queries/search": {
    /** Based on query properties (currently only name) search for queries. */
    post: operations["querySearch"];
  };
  "/roles/assign": {
    /** This is a business/enterprise only endpoint */
    post: operations["roleAssign"];
  };
  "/roles/unassign": {
    /** This is a business/enterprise only endpoint */
    post: operations["roleUnAssign"];
  };
  "/tables/{tableId}/rows": {
    /** Creates a row within the specified table. */
    post: operations["rowCreate"];
  };
  "/tables/{tableId}/rows/{rowId}": {
    /** This gets a single row, it will be enriched with the full related rows, rather than the squashed "primaryDisplay" format returned by the search endpoint. */
    get: operations["rowGetById"];
    /** Updates a row within the specified table. */
    put: operations["rowUpdate"];
    /** Deletes a row within the specified table. */
    delete: operations["rowDestroy"];
  };
  "/tables/{tableId}/rows/search": {
    post: operations["rowSearch"];
  };
  "/views/{viewId}/rows/search": {
    post: operations["rowViewSearch"];
  };
  "/tables": {
    /** Create a table, this could be internal or external. */
    post: operations["tableCreate"];
  };
  "/tables/{tableId}": {
    /** Lookup a table, this could be internal or external. */
    get: operations["tableGetById"];
    /** Update a table, this could be internal or external. */
    put: operations["tableUpdate"];
    /** Delete a table, this could be internal or external. */
    delete: operations["tableDestroy"];
  };
  "/tables/search": {
    /** Based on table properties (currently only name) search for tables. This could be an internal or an external table. */
    post: operations["tableSearch"];
  };
  "/users": {
    post: operations["userCreate"];
  };
  "/users/{userId}": {
    get: operations["userGetById"];
    put: operations["userUpdate"];
    delete: operations["userDestroy"];
  };
  "/users/search": {
    /** Based on user properties (currently only name) search for users. */
    post: operations["userSearch"];
  };
  "/views": {
    /** Create a view, this can be against an internal or external table. */
    post: operations["viewCreate"];
  };
  "/views/{viewId}": {
    /** Lookup a view, this could be internal or external. */
    get: operations["viewGetById"];
    /** Update a view, this can be against an internal or external table. */
    put: operations["viewUpdate"];
    /** Delete a view, this can be against an internal or external table. */
    delete: operations["viewDestroy"];
  };
  "/views/search": {
    /** Based on view properties (currently only name) search for views. */
    post: operations["viewSearch"];
  };
}

export interface components {
  schemas: {
    application: {
      /** @description The name of the app. */
      name: string;
      /** @description The URL by which the app is accessed, this must be URL encoded. */
      url?: string;
    };
    applicationOutput: {
      data: {
        /** @description The name of the app. */
        name: string;
        /** @description The URL by which the app is accessed, this must be URL encoded. */
        url: string;
        /** @description The ID of the app. */
        _id: string;
        /**
         * @description The status of the app, stating it if is the development or published version.
         * @enum {string}
         */
        status: "development" | "published";
        /** @description States when the app was created, will be constant. Stored in ISO format. */
        createdAt: string;
        /** @description States the last time the app was updated - stored in ISO format. */
        updatedAt: string;
        /** @description States the version of the Budibase client this app is currently based on. */
        version: string;
        /** @description In a multi-tenant environment this will state the tenant this app is within. */
        tenantId?: string;
        /** @description The user this app is currently being built by. */
        lockedBy?: { [key: string]: unknown };
      };
    };
    applicationSearch: {
      data: {
        /** @description The name of the app. */
        name: string;
        /** @description The URL by which the app is accessed, this must be URL encoded. */
        url: string;
        /** @description The ID of the app. */
        _id: string;
        /**
         * @description The status of the app, stating it if is the development or published version.
         * @enum {string}
         */
        status: "development" | "published";
        /** @description States when the app was created, will be constant. Stored in ISO format. */
        createdAt: string;
        /** @description States the last time the app was updated - stored in ISO format. */
        updatedAt: string;
        /** @description States the version of the Budibase client this app is currently based on. */
        version: string;
        /** @description In a multi-tenant environment this will state the tenant this app is within. */
        tenantId?: string;
        /** @description The user this app is currently being built by. */
        lockedBy?: { [key: string]: unknown };
      }[];
    };
    deploymentOutput: {
      data: {
        /** @description The ID of the app. */
        _id: string;
        /**
         * @description Status of the deployment, whether it succeeded or failed
         * @enum {string}
         */
        status: "SUCCESS" | "FAILURE";
        /** @description The URL of the published app */
        appUrl: string;
      };
    };
    appExport: {
      /** @description An optional password used to encrypt the export. */
      encryptPassword: string;
      /** @description Set whether the internal table rows should be excluded from the export. */
      excludeRows: boolean;
    };
    /** @description The row to be created/updated, based on the table schema. */
    row: { [key: string]: unknown };
    searchOutput: {
      /** @description An array of rows, these will each contain an _id field which can be used to update or delete them. */
      data: { [key: string]: unknown }[];
      /** @description If pagination in use, this should be provided. */
      bookmark?: string | number;
      /** @description If pagination in use, this will determine if there is another page to fetch. */
      hasNextPage?: boolean;
    };
    rowOutput: {
      /** @description The row to be created/updated, based on the table schema. */
      data: {
        /** @description The ID of the row. */
        _id: string;
        /** @description The ID of the table this row comes from. */
        tableId: string;
      } & { [key: string]: unknown };
    };
    /** @description The table to be created/updated. */
    table: {
      /** @description The name of the table. */
      name: string;
      /** @description The name of the column which should be used in relationship tags when relating to this table. */
      primaryDisplay?: string;
      schema: {
        [key: string]:
          | {
              /**
               * @description A relationship column.
               * @enum {string}
               */
              type?: "link";
              /** @description A constraint can be applied to the column which will be validated against when a row is saved. */
              constraints?: {
                /** @enum {string} */
                type?: "string" | "number" | "object" | "boolean";
                /** @description Defines whether the column is required or not. */
                presence?: boolean;
              };
              /** @description The name of the column. */
              name?: string;
              /** @description Defines whether the column is automatically generated. */
              autocolumn?: boolean;
              /** @description The name of the column which a relationship column is related to in another table. */
              fieldName?: string;
              /** @description The ID of the table which a relationship column is related to. */
              tableId?: string;
              /**
               * @description Defines the type of relationship that this column will be used for.
               * @enum {string}
               */
              relationshipType?: "one-to-many" | "many-to-one" | "many-to-many";
              /** @description When using a SQL table that contains many to many relationships this defines the table the relationships are linked through. */
              through?: string;
              /** @description When using a SQL table that contains a one to many relationship this defines the foreign key. */
              foreignKey?: string;
              /** @description When using a SQL table that utilises a through table, this defines the primary key in the through table for this table. */
              throughFrom?: string;
              /** @description When using a SQL table that utilises a through table, this defines the primary key in the through table for the related table. */
              throughTo?: string;
            }
          | {
              /**
               * @description A formula column.
               * @enum {string}
               */
              type?: "formula";
              /** @description A constraint can be applied to the column which will be validated against when a row is saved. */
              constraints?: {
                /** @enum {string} */
                type?: "string" | "number" | "object" | "boolean";
                /** @description Defines whether the column is required or not. */
                presence?: boolean;
              };
              /** @description The name of the column. */
              name?: string;
              /** @description Defines whether the column is automatically generated. */
              autocolumn?: boolean;
              /** @description Defines a Handlebars or JavaScript formula to use, note that Javascript formulas are expected to be provided in the base64 format. */
              formula?: string;
              /**
               * @description Defines whether this is a static or dynamic formula.
               * @enum {string}
               */
              formulaType?: "static" | "dynamic";
            }
          | {
              /**
               * @description Defines the type of the column, most explain themselves, a link column is a relationship.
               * @enum {string}
               */
              type?:
                | "string"
                | "longform"
                | "options"
                | "number"
                | "boolean"
                | "array"
                | "datetime"
                | "attachment"
                | "attachment_single"
                | "link"
                | "formula"
                | "auto"
                | "ai"
                | "json"
                | "internal"
                | "barcodeqr"
                | "signature_single"
                | "bigint"
                | "bb_reference"
                | "bb_reference_single";
              /** @description A constraint can be applied to the column which will be validated against when a row is saved. */
              constraints?: {
                /** @enum {string} */
                type?: "string" | "number" | "object" | "boolean";
                /** @description Defines whether the column is required or not. */
                presence?: boolean;
              };
              /** @description The name of the column. */
              name?: string;
              /** @description Defines whether the column is automatically generated. */
              autocolumn?: boolean;
            };
      };
    };
    tableOutput: {
      /** @description The table to be created/updated. */
      data: {
        /** @description The name of the table. */
        name: string;
        /** @description The name of the column which should be used in relationship tags when relating to this table. */
        primaryDisplay?: string;
        schema: {
          [key: string]:
            | {
                /**
                 * @description A relationship column.
                 * @enum {string}
                 */
                type?: "link";
                /** @description A constraint can be applied to the column which will be validated against when a row is saved. */
                constraints?: {
                  /** @enum {string} */
                  type?: "string" | "number" | "object" | "boolean";
                  /** @description Defines whether the column is required or not. */
                  presence?: boolean;
                };
                /** @description The name of the column. */
                name?: string;
                /** @description Defines whether the column is automatically generated. */
                autocolumn?: boolean;
                /** @description The name of the column which a relationship column is related to in another table. */
                fieldName?: string;
                /** @description The ID of the table which a relationship column is related to. */
                tableId?: string;
                /**
                 * @description Defines the type of relationship that this column will be used for.
                 * @enum {string}
                 */
                relationshipType?:
                  | "one-to-many"
                  | "many-to-one"
                  | "many-to-many";
                /** @description When using a SQL table that contains many to many relationships this defines the table the relationships are linked through. */
                through?: string;
                /** @description When using a SQL table that contains a one to many relationship this defines the foreign key. */
                foreignKey?: string;
                /** @description When using a SQL table that utilises a through table, this defines the primary key in the through table for this table. */
                throughFrom?: string;
                /** @description When using a SQL table that utilises a through table, this defines the primary key in the through table for the related table. */
                throughTo?: string;
              }
            | {
                /**
                 * @description A formula column.
                 * @enum {string}
                 */
                type?: "formula";
                /** @description A constraint can be applied to the column which will be validated against when a row is saved. */
                constraints?: {
                  /** @enum {string} */
                  type?: "string" | "number" | "object" | "boolean";
                  /** @description Defines whether the column is required or not. */
                  presence?: boolean;
                };
                /** @description The name of the column. */
                name?: string;
                /** @description Defines whether the column is automatically generated. */
                autocolumn?: boolean;
                /** @description Defines a Handlebars or JavaScript formula to use, note that Javascript formulas are expected to be provided in the base64 format. */
                formula?: string;
                /**
                 * @description Defines whether this is a static or dynamic formula.
                 * @enum {string}
                 */
                formulaType?: "static" | "dynamic";
              }
            | {
                /**
                 * @description Defines the type of the column, most explain themselves, a link column is a relationship.
                 * @enum {string}
                 */
                type?:
                  | "string"
                  | "longform"
                  | "options"
                  | "number"
                  | "boolean"
                  | "array"
                  | "datetime"
                  | "attachment"
                  | "attachment_single"
                  | "link"
                  | "formula"
                  | "auto"
                  | "ai"
                  | "json"
                  | "internal"
                  | "barcodeqr"
                  | "signature_single"
                  | "bigint"
                  | "bb_reference"
                  | "bb_reference_single";
                /** @description A constraint can be applied to the column which will be validated against when a row is saved. */
                constraints?: {
                  /** @enum {string} */
                  type?: "string" | "number" | "object" | "boolean";
                  /** @description Defines whether the column is required or not. */
                  presence?: boolean;
                };
                /** @description The name of the column. */
                name?: string;
                /** @description Defines whether the column is automatically generated. */
                autocolumn?: boolean;
              };
        };
        /** @description The ID of the table. */
        _id: string;
      };
    };
    tableSearch: {
      data: {
        /** @description The name of the table. */
        name: string;
        /** @description The name of the column which should be used in relationship tags when relating to this table. */
        primaryDisplay?: string;
        schema: {
          [key: string]:
            | {
                /**
                 * @description A relationship column.
                 * @enum {string}
                 */
                type?: "link";
                /** @description A constraint can be applied to the column which will be validated against when a row is saved. */
                constraints?: {
                  /** @enum {string} */
                  type?: "string" | "number" | "object" | "boolean";
                  /** @description Defines whether the column is required or not. */
                  presence?: boolean;
                };
                /** @description The name of the column. */
                name?: string;
                /** @description Defines whether the column is automatically generated. */
                autocolumn?: boolean;
                /** @description The name of the column which a relationship column is related to in another table. */
                fieldName?: string;
                /** @description The ID of the table which a relationship column is related to. */
                tableId?: string;
                /**
                 * @description Defines the type of relationship that this column will be used for.
                 * @enum {string}
                 */
                relationshipType?:
                  | "one-to-many"
                  | "many-to-one"
                  | "many-to-many";
                /** @description When using a SQL table that contains many to many relationships this defines the table the relationships are linked through. */
                through?: string;
                /** @description When using a SQL table that contains a one to many relationship this defines the foreign key. */
                foreignKey?: string;
                /** @description When using a SQL table that utilises a through table, this defines the primary key in the through table for this table. */
                throughFrom?: string;
                /** @description When using a SQL table that utilises a through table, this defines the primary key in the through table for the related table. */
                throughTo?: string;
              }
            | {
                /**
                 * @description A formula column.
                 * @enum {string}
                 */
                type?: "formula";
                /** @description A constraint can be applied to the column which will be validated against when a row is saved. */
                constraints?: {
                  /** @enum {string} */
                  type?: "string" | "number" | "object" | "boolean";
                  /** @description Defines whether the column is required or not. */
                  presence?: boolean;
                };
                /** @description The name of the column. */
                name?: string;
                /** @description Defines whether the column is automatically generated. */
                autocolumn?: boolean;
                /** @description Defines a Handlebars or JavaScript formula to use, note that Javascript formulas are expected to be provided in the base64 format. */
                formula?: string;
                /**
                 * @description Defines whether this is a static or dynamic formula.
                 * @enum {string}
                 */
                formulaType?: "static" | "dynamic";
              }
            | {
                /**
                 * @description Defines the type of the column, most explain themselves, a link column is a relationship.
                 * @enum {string}
                 */
                type?:
                  | "string"
                  | "longform"
                  | "options"
                  | "number"
                  | "boolean"
                  | "array"
                  | "datetime"
                  | "attachment"
                  | "attachment_single"
                  | "link"
                  | "formula"
                  | "auto"
                  | "ai"
                  | "json"
                  | "internal"
                  | "barcodeqr"
                  | "signature_single"
                  | "bigint"
                  | "bb_reference"
                  | "bb_reference_single";
                /** @description A constraint can be applied to the column which will be validated against when a row is saved. */
                constraints?: {
                  /** @enum {string} */
                  type?: "string" | "number" | "object" | "boolean";
                  /** @description Defines whether the column is required or not. */
                  presence?: boolean;
                };
                /** @description The name of the column. */
                name?: string;
                /** @description Defines whether the column is automatically generated. */
                autocolumn?: boolean;
              };
        };
        /** @description The ID of the table. */
        _id: string;
      }[];
    };
    /** @description The parameters required for executing a query. */
    executeQuery: {
      /** @description This contains the required parameters for the query, this depends on query type, setup and bindings. */
      parameters?: { [key: string]: unknown };
      /** @description For supported query types (currently on REST) pagination can be performed using these properties. */
      pagination?: {
        /** @description The page which has been returned from a previous query. */
        page?: string;
        /** @description The number of rows to return per page. */
        limit?: number;
      };
    };
    executeQueryOutput: {
      /** @description The data response from the query. */
      data: { [key: string]: unknown }[];
      /** @description Extra information that is not part of the main data, e.g. headers. */
      extra?: {
        /** @description If carrying out a REST request, this will contain the response headers. */
        headers?: { [key: string]: unknown };
        /** @description The raw query response, as a string. */
        raw?: string;
      };
      /** @description If pagination is supported, this will contain the bookmark/anchor information for it. */
      pagination?: { [key: string]: unknown };
    };
    query: {
      /** @description The ID of the query. */
      _id: string;
      /** @description The ID of the datasource the query belongs to. */
      datasourceId?: string;
      /** @description The bindings which are required to perform this query. */
      parameters?: string[];
      /** @description The fields that are used to perform this query, e.g. the sql statement */
      fields?: { [key: string]: unknown };
      /**
       * @description The verb that describes this query.
       * @enum {undefined}
       */
      queryVerb?: "create" | "read" | "update" | "delete";
      /** @description The name of the query. */
      name: string;
      /** @description The schema of the data returned when the query is executed. */
      schema: { [key: string]: unknown };
      /** @description The JavaScript transformer function, applied after the query responds with data. */
      transformer?: string;
      /** @description Whether the query has readable data. */
      readable?: boolean;
    };
    querySearch: {
      data: {
        /** @description The ID of the query. */
        _id: string;
        /** @description The ID of the datasource the query belongs to. */
        datasourceId?: string;
        /** @description The bindings which are required to perform this query. */
        parameters?: string[];
        /** @description The fields that are used to perform this query, e.g. the sql statement */
        fields?: { [key: string]: unknown };
        /**
         * @description The verb that describes this query.
         * @enum {undefined}
         */
        queryVerb?: "create" | "read" | "update" | "delete";
        /** @description The name of the query. */
        name: string;
        /** @description The schema of the data returned when the query is executed. */
        schema: { [key: string]: unknown };
        /** @description The JavaScript transformer function, applied after the query responds with data. */
        transformer?: string;
        /** @description Whether the query has readable data. */
        readable?: boolean;
      }[];
    };
    user: {
      /** @description The email address of the user, this must be unique. */
      email: string;
      /** @description The password of the user if using password based login - this will never be returned. This can be left out of subsequent requests (updates) and will be enriched back into the user structure. */
      password?: string;
      /**
       * @description The status of the user, if they are active.
       * @enum {string}
       */
      status?: "active";
      /** @description The first name of the user */
      firstName?: string;
      /** @description The last name of the user */
      lastName?: string;
      /** @description If set to true forces the user to reset their password on first login. */
      forceResetPassword?: boolean;
      /** @description Describes if the user is a builder user or not. This field can only be set on a business or enterprise license. */
      builder?: {
        /** @description If set to true the user will be able to build any app in the system. */
        global?: boolean;
      };
      /** @description Describes if the user is an admin user or not. This field can only be set on a business or enterprise license. */
      admin?: {
        /** @description If set to true the user will be able to administrate the system. */
        global?: boolean;
      };
      /** @description Contains the roles of the user per app (assuming they are not a builder user). This field can only be set on a business or enterprise license. */
      roles?: { [key: string]: string };
    };
    userOutput: {
      data: {
        /** @description The email address of the user, this must be unique. */
        email: string;
        /** @description The password of the user if using password based login - this will never be returned. This can be left out of subsequent requests (updates) and will be enriched back into the user structure. */
        password?: string;
        /**
         * @description The status of the user, if they are active.
         * @enum {string}
         */
        status?: "active";
        /** @description The first name of the user */
        firstName?: string;
        /** @description The last name of the user */
        lastName?: string;
        /** @description If set to true forces the user to reset their password on first login. */
        forceResetPassword?: boolean;
        /** @description Describes if the user is a builder user or not. This field can only be set on a business or enterprise license. */
        builder?: {
          /** @description If set to true the user will be able to build any app in the system. */
          global?: boolean;
        };
        /** @description Describes if the user is an admin user or not. This field can only be set on a business or enterprise license. */
        admin?: {
          /** @description If set to true the user will be able to administrate the system. */
          global?: boolean;
        };
        /** @description Contains the roles of the user per app (assuming they are not a builder user). This field can only be set on a business or enterprise license. */
        roles?: { [key: string]: string };
        /** @description The ID of the user. */
        _id: string;
      };
    };
    userSearch: {
      data: {
        /** @description The email address of the user, this must be unique. */
        email: string;
        /** @description The password of the user if using password based login - this will never be returned. This can be left out of subsequent requests (updates) and will be enriched back into the user structure. */
        password?: string;
        /**
         * @description The status of the user, if they are active.
         * @enum {string}
         */
        status?: "active";
        /** @description The first name of the user */
        firstName?: string;
        /** @description The last name of the user */
        lastName?: string;
        /** @description If set to true forces the user to reset their password on first login. */
        forceResetPassword?: boolean;
        /** @description Describes if the user is a builder user or not. This field can only be set on a business or enterprise license. */
        builder?: {
          /** @description If set to true the user will be able to build any app in the system. */
          global?: boolean;
        };
        /** @description Describes if the user is an admin user or not. This field can only be set on a business or enterprise license. */
        admin?: {
          /** @description If set to true the user will be able to administrate the system. */
          global?: boolean;
        };
        /** @description Contains the roles of the user per app (assuming they are not a builder user). This field can only be set on a business or enterprise license. */
        roles?: { [key: string]: string };
        /** @description The ID of the user. */
        _id: string;
      }[];
    };
    rowSearch: {
      query: {
        /** @description Specifies that a row should be returned if it satisfies any of the specified options, rather than requiring it to fulfill all the search parameters. This defaults to false, meaning AND logic will be used. */
        allOr?: boolean;
        /**
         * @description A map of field name to the string to search for, this will look for rows that have a value starting with the string value.
         * @example [object Object]
         */
        string?: { [key: string]: string };
        /** @description Searches for a sub-string within a string column, e.g. searching for 'dib' will match 'Budibase'. */
        fuzzy?: { [key: string]: unknown };
        /**
         * @description Searches within a range, the format of this must be in the format of an object with a "low" and "high" property.
         * @example [object Object]
         */
        range?: { [key: string]: unknown };
        /** @description Searches for rows that have a column value that is exactly the value set. */
        equal?: { [key: string]: unknown };
        /** @description Searches for any row which does not contain the specified column value. */
        notEqual?: { [key: string]: unknown };
        /**
         * @description Searches for rows which do not contain the specified column. The object should simply contain keys of the column names, these can map to any value.
         * @example [object Object]
         */
        empty?: { [key: string]: unknown };
        /** @description Searches for rows which have the specified column. */
        notEmpty?: { [key: string]: unknown };
        /** @description Searches for rows which have a column value that is any of the specified values. The format of this must be columnName -> [value1, value2]. */
        oneOf?: { [key: string]: unknown };
        /**
         * @description Searches for a value, or set of values in array column types (such as a multi-select). If an array of search options is provided then it must match all.
         * @example [object Object]
         */
        contains?: { [key: string]: unknown };
        /**
         * @description The logical inverse of contains. Only works on array column types. If an array of values is passed, the row must not match any of them to be returned in the response.
         * @example [object Object]
         */
        notContains?: { [key: string]: unknown };
        /**
         * @description As with the contains search, only works on array column types and searches for any of the provided values when given an array.
         * @example [object Object]
         */
        containsAny?: { [key: string]: unknown };
      };
      /** @description Enables pagination, by default this is disabled. */
      paginate?: boolean;
      /** @description If retrieving another page, the bookmark from the previous request must be supplied. */
      bookmark?: string | number;
      /** @description The maximum number of rows to return, useful when paginating, for internal tables this will be limited to 1000, for SQL tables it will be 5000. */
      limit?: number;
      /** @description A set of parameters describing the sort behaviour of the search. */
      sort?: {
        /**
         * @description The order of the sort, by default this is ascending.
         * @enum {string}
         */
        order?: "ascending" | "descending";
        /** @description The name of the column by which the rows will be sorted. */
        column?: string;
        /**
         * @description Defines whether the column should be treated as a string or as numbers when sorting.
         * @enum {string}
         */
        type?: "string" | "number";
      };
    };
    nameSearch: {
      /** @description The name to be used when searching - this will be used in a case insensitive starts with match. */
      name: string;
    };
    rolesAssign: {
      /** @description Allow setting users to builders per app. */
      appBuilder?: {
        /** @description The app that the users should have app builder privileges granted for. */
        appId: string;
      };
      /** @description Add/remove global builder permissions from the list of users. */
      builder?: boolean;
      /** @description Add/remove global admin permissions from the list of users. */
      admin?: boolean;
      /** @description Add/remove a per-app role, such as BASIC, ADMIN etc. */
      role?: {
        /** @description The role ID, such as BASIC, ADMIN or a custom role ID. */
        roleId: string;
        /** @description The app that the role relates to. */
        appId: string;
      };
      /** @description The user IDs to be updated to add/remove the specified roles. */
      userIds: string[];
    };
    rolesUnAssign: {
      /** @description Allow setting users to builders per app. */
      appBuilder?: {
        /** @description The app that the users should have app builder privileges granted for. */
        appId: string;
      };
      /** @description Add/remove global builder permissions from the list of users. */
      builder?: boolean;
      /** @description Add/remove global admin permissions from the list of users. */
      admin?: boolean;
      /** @description Add/remove a per-app role, such as BASIC, ADMIN etc. */
      role?: {
        /** @description The role ID, such as BASIC, ADMIN or a custom role ID. */
        roleId: string;
        /** @description The app that the role relates to. */
        appId: string;
      };
      /** @description The user IDs to be updated to add/remove the specified roles. */
      userIds: string[];
    };
    rolesOutput: {
      data: {
        /** @description The updated users' IDs */
        userIds: string[];
      };
    };
    /** @description The view to be created/updated. */
    view: {
      /** @description The name of the view. */
      name: string;
      /** @description The ID of the table this view is based on. */
      tableId: string;
      /**
       * @description The type of view - standard (empty value) or calculation.
       * @enum {string}
       */
      type?: "calculation";
      /** @description A column used to display rows from this view - usually used when rendered in tables. */
      primaryDisplay?: string;
      /** @description Search parameters for view */
      query?: {
        /**
         * @description When using groups this defines whether all of the filters must match, or only one of them.
         * @enum {string}
         */
        logicalOperator?: "all" | "any";
        /**
         * @description If no filters match, should the view return all rows, or no rows.
         * @enum {string}
         */
        onEmptyFilter?: "all" | "none";
        /** @description A grouping of filters to be applied. */
        groups?: {
          /**
           * @description When using groups this defines whether all of the filters must match, or only one of them.
           * @enum {string}
           */
          logicalOperator?: "all" | "any";
          /** @description A list of filters to apply */
          filters?: {
            /**
             * @description The type of search operation which is being performed.
             * @enum {string}
             */
            operator?:
              | "equal"
              | "notEqual"
              | "empty"
              | "notEmpty"
              | "fuzzy"
              | "string"
              | "contains"
              | "notContains"
              | "containsAny"
              | "oneOf"
              | "range";
            /** @description The field in the view to perform the search on. */
            field?: string;
            /** @description The value to search for - the type will depend on the operator in use. */
            value?:
              | string
              | number
              | boolean
              | { [key: string]: unknown }
              | unknown[];
          }[];
          /** @description A grouping of filters to be applied. */
          groups?: {
            /**
             * @description When using groups this defines whether all of the filters must match, or only one of them.
             * @enum {string}
             */
            logicalOperator?: "all" | "any";
            /** @description A list of filters to apply */
            filters?: {
              /**
               * @description The type of search operation which is being performed.
               * @enum {string}
               */
              operator?:
                | "equal"
                | "notEqual"
                | "empty"
                | "notEmpty"
                | "fuzzy"
                | "string"
                | "contains"
                | "notContains"
                | "containsAny"
                | "oneOf"
                | "range";
              /** @description The field in the view to perform the search on. */
              field?: string;
              /** @description The value to search for - the type will depend on the operator in use. */
              value?:
                | string
                | number
                | boolean
                | { [key: string]: unknown }
                | unknown[];
            }[];
          }[];
        }[];
      };
      sort?: {
        /** @description The field from the table/view schema to sort on. */
        field: string;
        /**
         * @description The order in which to sort.
         * @enum {string}
         */
        order?: "ascending" | "descending";
        /**
         * @description The type of sort to perform (by number, or by alphabetically).
         * @enum {string}
         */
        type?: "string" | "number";
      };
      schema: {
        [key: string]:
          | {
              /** @description Defines whether the column is visible or not - rows retrieved/updated through this view will not be able to access it. */
              visible?: boolean;
              /** @description When used in combination with 'visible: true' the column will be visible in row responses but cannot be updated. */
              readonly?: boolean;
              /** @description A number defining where the column shows up in tables, lowest being first. */
              order?: number;
              /** @description A width for the column, defined in pixels - this affects rendering in tables. */
              width?: number;
              /** @description If this is a relationship column, we can set the columns we wish to include */
              column?: {
                readonly?: boolean;
              }[];
            }
          | {
              /**
               * @description This column should be built from a calculation, specifying a type and field. It is important to note when a calculation is configured all non-calculation columns will be used for grouping.
               * @enum {string}
               */
              calculationType?: "sum" | "avg" | "count" | "min" | "max";
              /** @description The field from the table to perform the calculation on. */
              field?: string;
              /** @description Can be used in tandem with the count calculation type, to count unique entries. */
              distinct?: boolean;
            };
      };
    };
    viewOutput: {
      /** @description The view to be created/updated. */
      data: {
        /** @description The name of the view. */
        name: string;
        /** @description The ID of the table this view is based on. */
        tableId: string;
        /**
         * @description The type of view - standard (empty value) or calculation.
         * @enum {string}
         */
        type?: "calculation";
        /** @description A column used to display rows from this view - usually used when rendered in tables. */
        primaryDisplay?: string;
        /** @description Search parameters for view */
        query?: {
          /**
           * @description When using groups this defines whether all of the filters must match, or only one of them.
           * @enum {string}
           */
          logicalOperator?: "all" | "any";
          /**
           * @description If no filters match, should the view return all rows, or no rows.
           * @enum {string}
           */
          onEmptyFilter?: "all" | "none";
          /** @description A grouping of filters to be applied. */
          groups?: {
            /**
             * @description When using groups this defines whether all of the filters must match, or only one of them.
             * @enum {string}
             */
            logicalOperator?: "all" | "any";
            /** @description A list of filters to apply */
            filters?: {
              /**
               * @description The type of search operation which is being performed.
               * @enum {string}
               */
              operator?:
                | "equal"
                | "notEqual"
                | "empty"
                | "notEmpty"
                | "fuzzy"
                | "string"
                | "contains"
                | "notContains"
                | "containsAny"
                | "oneOf"
                | "range";
              /** @description The field in the view to perform the search on. */
              field?: string;
              /** @description The value to search for - the type will depend on the operator in use. */
              value?:
                | string
                | number
                | boolean
                | { [key: string]: unknown }
                | unknown[];
            }[];
            /** @description A grouping of filters to be applied. */
            groups?: {
              /**
               * @description When using groups this defines whether all of the filters must match, or only one of them.
               * @enum {string}
               */
              logicalOperator?: "all" | "any";
              /** @description A list of filters to apply */
              filters?: {
                /**
                 * @description The type of search operation which is being performed.
                 * @enum {string}
                 */
                operator?:
                  | "equal"
                  | "notEqual"
                  | "empty"
                  | "notEmpty"
                  | "fuzzy"
                  | "string"
                  | "contains"
                  | "notContains"
                  | "containsAny"
                  | "oneOf"
                  | "range";
                /** @description The field in the view to perform the search on. */
                field?: string;
                /** @description The value to search for - the type will depend on the operator in use. */
                value?:
                  | string
                  | number
                  | boolean
                  | { [key: string]: unknown }
                  | unknown[];
              }[];
            }[];
          }[];
        };
        sort?: {
          /** @description The field from the table/view schema to sort on. */
          field: string;
          /**
           * @description The order in which to sort.
           * @enum {string}
           */
          order?: "ascending" | "descending";
          /**
           * @description The type of sort to perform (by number, or by alphabetically).
           * @enum {string}
           */
          type?: "string" | "number";
        };
        schema: {
          [key: string]:
            | {
                /** @description Defines whether the column is visible or not - rows retrieved/updated through this view will not be able to access it. */
                visible?: boolean;
                /** @description When used in combination with 'visible: true' the column will be visible in row responses but cannot be updated. */
                readonly?: boolean;
                /** @description A number defining where the column shows up in tables, lowest being first. */
                order?: number;
                /** @description A width for the column, defined in pixels - this affects rendering in tables. */
                width?: number;
                /** @description If this is a relationship column, we can set the columns we wish to include */
                column?: {
                  readonly?: boolean;
                }[];
              }
            | {
                /**
                 * @description This column should be built from a calculation, specifying a type and field. It is important to note when a calculation is configured all non-calculation columns will be used for grouping.
                 * @enum {string}
                 */
                calculationType?: "sum" | "avg" | "count" | "min" | "max";
                /** @description The field from the table to perform the calculation on. */
                field?: string;
                /** @description Can be used in tandem with the count calculation type, to count unique entries. */
                distinct?: boolean;
              };
        };
        /** @description The ID of the view. */
        id: string;
      };
    };
    viewSearch: {
      data: {
        /** @description The name of the view. */
        name: string;
        /** @description The ID of the table this view is based on. */
        tableId: string;
        /**
         * @description The type of view - standard (empty value) or calculation.
         * @enum {string}
         */
        type?: "calculation";
        /** @description A column used to display rows from this view - usually used when rendered in tables. */
        primaryDisplay?: string;
        /** @description Search parameters for view */
        query?: {
          /**
           * @description When using groups this defines whether all of the filters must match, or only one of them.
           * @enum {string}
           */
          logicalOperator?: "all" | "any";
          /**
           * @description If no filters match, should the view return all rows, or no rows.
           * @enum {string}
           */
          onEmptyFilter?: "all" | "none";
          /** @description A grouping of filters to be applied. */
          groups?: {
            /**
             * @description When using groups this defines whether all of the filters must match, or only one of them.
             * @enum {string}
             */
            logicalOperator?: "all" | "any";
            /** @description A list of filters to apply */
            filters?: {
              /**
               * @description The type of search operation which is being performed.
               * @enum {string}
               */
              operator?:
                | "equal"
                | "notEqual"
                | "empty"
                | "notEmpty"
                | "fuzzy"
                | "string"
                | "contains"
                | "notContains"
                | "containsAny"
                | "oneOf"
                | "range";
              /** @description The field in the view to perform the search on. */
              field?: string;
              /** @description The value to search for - the type will depend on the operator in use. */
              value?:
                | string
                | number
                | boolean
                | { [key: string]: unknown }
                | unknown[];
            }[];
            /** @description A grouping of filters to be applied. */
            groups?: {
              /**
               * @description When using groups this defines whether all of the filters must match, or only one of them.
               * @enum {string}
               */
              logicalOperator?: "all" | "any";
              /** @description A list of filters to apply */
              filters?: {
                /**
                 * @description The type of search operation which is being performed.
                 * @enum {string}
                 */
                operator?:
                  | "equal"
                  | "notEqual"
                  | "empty"
                  | "notEmpty"
                  | "fuzzy"
                  | "string"
                  | "contains"
                  | "notContains"
                  | "containsAny"
                  | "oneOf"
                  | "range";
                /** @description The field in the view to perform the search on. */
                field?: string;
                /** @description The value to search for - the type will depend on the operator in use. */
                value?:
                  | string
                  | number
                  | boolean
                  | { [key: string]: unknown }
                  | unknown[];
              }[];
            }[];
          }[];
        };
        sort?: {
          /** @description The field from the table/view schema to sort on. */
          field: string;
          /**
           * @description The order in which to sort.
           * @enum {string}
           */
          order?: "ascending" | "descending";
          /**
           * @description The type of sort to perform (by number, or by alphabetically).
           * @enum {string}
           */
          type?: "string" | "number";
        };
        schema: {
          [key: string]:
            | {
                /** @description Defines whether the column is visible or not - rows retrieved/updated through this view will not be able to access it. */
                visible?: boolean;
                /** @description When used in combination with 'visible: true' the column will be visible in row responses but cannot be updated. */
                readonly?: boolean;
                /** @description A number defining where the column shows up in tables, lowest being first. */
                order?: number;
                /** @description A width for the column, defined in pixels - this affects rendering in tables. */
                width?: number;
                /** @description If this is a relationship column, we can set the columns we wish to include */
                column?: {
                  readonly?: boolean;
                }[];
              }
            | {
                /**
                 * @description This column should be built from a calculation, specifying a type and field. It is important to note when a calculation is configured all non-calculation columns will be used for grouping.
                 * @enum {string}
                 */
                calculationType?: "sum" | "avg" | "count" | "min" | "max";
                /** @description The field from the table to perform the calculation on. */
                field?: string;
                /** @description Can be used in tandem with the count calculation type, to count unique entries. */
                distinct?: boolean;
              };
        };
        /** @description The ID of the view. */
        id: string;
      }[];
    };
  };
  parameters: {
    /** @description The ID of the table which this request is targeting. */
    tableId: string;
    /** @description The ID of the view which this request is targeting. */
    viewId: string;
    /** @description The ID of the row which this request is targeting. */
    rowId: string;
    /** @description The ID of the app which this request is targeting. */
    appId: string;
    /** @description The ID of the app which this request is targeting. */
    appIdUrl: string;
    /** @description The ID of the query which this request is targeting. */
    queryId: string;
    /** @description The ID of the user which this request is targeting. */
    userId: string;
  };
}

export interface operations {
  appCreate: {
    parameters: {
      header: {
        /** The ID of the app which this request is targeting. */
        "x-budibase-app-id": components["parameters"]["appId"];
      };
    };
    responses: {
      /** Returns the created application. */
      200: {
        content: {
          "application/json": components["schemas"]["applicationOutput"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["application"];
      };
    };
  };
  appGetById: {
    parameters: {
      path: {
        /** The ID of the app which this request is targeting. */
        appId: components["parameters"]["appIdUrl"];
      };
    };
    responses: {
      /** Returns the retrieved application. */
      200: {
        content: {
          "application/json": components["schemas"]["applicationOutput"];
        };
      };
    };
  };
  appUpdate: {
    parameters: {
      path: {
        /** The ID of the app which this request is targeting. */
        appId: components["parameters"]["appIdUrl"];
      };
    };
    responses: {
      /** Returns the updated application. */
      200: {
        content: {
          "application/json": components["schemas"]["applicationOutput"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["application"];
      };
    };
  };
  appDestroy: {
    parameters: {
      path: {
        /** The ID of the app which this request is targeting. */
        appId: components["parameters"]["appIdUrl"];
      };
    };
    responses: {
      /** Returns the deleted application. */
      200: {
        content: {
          "application/json": components["schemas"]["applicationOutput"];
        };
      };
    };
  };
  appUnpublish: {
    parameters: {
      path: {
        /** The ID of the app which this request is targeting. */
        appId: components["parameters"]["appIdUrl"];
      };
    };
    responses: {
      /** The app was published successfully. */
      204: never;
    };
  };
  appPublish: {
    parameters: {
      path: {
        /** The ID of the app which this request is targeting. */
        appId: components["parameters"]["appIdUrl"];
      };
    };
    responses: {
      /** Returns the deployment object. */
      200: {
        content: {
          "application/json": components["schemas"]["deploymentOutput"];
        };
      };
    };
  };
  /** This endpoint is only available on a business or enterprise license. */
  appImport: {
    parameters: {
      path: {
        /** The ID of the app which this request is targeting. */
        appId: components["parameters"]["appIdUrl"];
      };
    };
    responses: {
      /** Application has been updated. */
      204: never;
    };
    requestBody: {
      content: {
        "multipart/form-data": {
          /** @description Password for the export if it is encrypted. */
          encryptedPassword?: string;
          /**
           * Format: binary
           * @description The app export to import.
           */
          appExport: string;
        };
      };
    };
  };
  /** This endpoint is only available on a business or enterprise license. */
  appExport: {
    parameters: {
      path: {
        /** The ID of the app which this request is targeting. */
        appId: components["parameters"]["appIdUrl"];
      };
    };
    responses: {
      /** A gzip tarball containing the app export, encrypted if password provided. */
      200: {
        content: {
          "application/gzip": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["appExport"];
      };
    };
  };
  /** Based on application properties (currently only name) search for applications. */
  appSearch: {
    responses: {
      /** Returns the applications that were found based on the search parameters. */
      200: {
        content: {
          "application/json": components["schemas"]["applicationSearch"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["nameSearch"];
      };
    };
  };
  /** Output metrics in OpenMetrics format compatible with Prometheus */
  metricsGet: {
    responses: {
      /** Returns tenant metrics. */
      200: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  /** Queries which have been created within a Budibase app can be executed using this, */
  queryExecute: {
    parameters: {
      path: {
        /** The ID of the query which this request is targeting. */
        queryId: components["parameters"]["queryId"];
      };
      header: {
        /** The ID of the app which this request is targeting. */
        "x-budibase-app-id": components["parameters"]["appId"];
      };
    };
    responses: {
      /** Returns the result of the query execution. */
      200: {
        content: {
          "application/json": components["schemas"]["executeQueryOutput"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["executeQuery"];
      };
    };
  };
  /** Based on query properties (currently only name) search for queries. */
  querySearch: {
    parameters: {
      header: {
        /** The ID of the app which this request is targeting. */
        "x-budibase-app-id": components["parameters"]["appId"];
      };
    };
    responses: {
      /** Returns the queries found based on the search parameters. */
      200: {
        content: {
          "application/json": components["schemas"]["querySearch"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["nameSearch"];
      };
    };
  };
  /** This is a business/enterprise only endpoint */
  roleAssign: {
    responses: {
      /** Returns a list of updated user IDs */
      200: {
        content: {
          "application/json": components["schemas"]["rolesOutput"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["rolesAssign"];
      };
    };
  };
  /** This is a business/enterprise only endpoint */
  roleUnAssign: {
    responses: {
      /** Returns a list of updated user IDs */
      200: {
        content: {
          "application/json": components["schemas"]["rolesOutput"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["rolesUnAssign"];
      };
    };
  };
  /** Creates a row within the specified table. */
  rowCreate: {
    parameters: {
      path: {
        /** The ID of the table which this request is targeting. */
        tableId: components["parameters"]["tableId"];
      };
      header: {
        /** The ID of the app which this request is targeting. */
        "x-budibase-app-id": components["parameters"]["appId"];
      };
    };
    responses: {
      /** Returns the created row, including the ID which has been generated for it. This can be found in the Budibase portal, viewed under the developer information. */
      200: {
        content: {
          "application/json": components["schemas"]["rowOutput"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["row"];
      };
    };
  };
  /** This gets a single row, it will be enriched with the full related rows, rather than the squashed "primaryDisplay" format returned by the search endpoint. */
  rowGetById: {
    parameters: {
      path: {
        /** The ID of the table which this request is targeting. */
        tableId: components["parameters"]["tableId"];
        /** The ID of the row which this request is targeting. */
        rowId: components["parameters"]["rowId"];
      };
      header: {
        /** The ID of the app which this request is targeting. */
        "x-budibase-app-id": components["parameters"]["appId"];
      };
    };
    responses: {
      /** Returns the retrieved row. */
      200: {
        content: {
          "application/json": components["schemas"]["rowOutput"];
        };
      };
    };
  };
  /** Updates a row within the specified table. */
  rowUpdate: {
    parameters: {
      path: {
        /** The ID of the table which this request is targeting. */
        tableId: components["parameters"]["tableId"];
        /** The ID of the row which this request is targeting. */
        rowId: components["parameters"]["rowId"];
      };
      header: {
        /** The ID of the app which this request is targeting. */
        "x-budibase-app-id": components["parameters"]["appId"];
      };
    };
    responses: {
      /** Returns the created row, including the ID which has been generated for it. */
      200: {
        content: {
          "application/json": components["schemas"]["rowOutput"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["row"];
      };
    };
  };
  /** Deletes a row within the specified table. */
  rowDestroy: {
    parameters: {
      path: {
        /** The ID of the table which this request is targeting. */
        tableId: components["parameters"]["tableId"];
        /** The ID of the row which this request is targeting. */
        rowId: components["parameters"]["rowId"];
      };
      header: {
        /** The ID of the app which this request is targeting. */
        "x-budibase-app-id": components["parameters"]["appId"];
      };
    };
    responses: {
      /** Returns the deleted row, including the ID which has been generated for it. */
      200: {
        content: {
          "application/json": components["schemas"]["rowOutput"];
        };
      };
    };
  };
  rowSearch: {
    parameters: {
      path: {
        /** The ID of the table which this request is targeting. */
        tableId: components["parameters"]["tableId"];
      };
      header: {
        /** The ID of the app which this request is targeting. */
        "x-budibase-app-id": components["parameters"]["appId"];
      };
    };
    responses: {
      /** The response will contain an array of rows that match the search parameters. */
      200: {
        content: {
          "application/json": components["schemas"]["searchOutput"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["rowSearch"];
      };
    };
  };
  rowViewSearch: {
    parameters: {
      path: {
        /** The ID of the view which this request is targeting. */
        viewId: components["parameters"]["viewId"];
      };
      header: {
        /** The ID of the app which this request is targeting. */
        "x-budibase-app-id": components["parameters"]["appId"];
      };
    };
    responses: {
      /** The response will contain an array of rows that match the search parameters. */
      200: {
        content: {
          "application/json": components["schemas"]["searchOutput"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["rowSearch"];
      };
    };
  };
  /** Create a table, this could be internal or external. */
  tableCreate: {
    parameters: {
      header: {
        /** The ID of the app which this request is targeting. */
        "x-budibase-app-id": components["parameters"]["appId"];
      };
    };
    responses: {
      /** Returns the created table, including the ID which has been generated for it. This can be internal or external datasources. */
      200: {
        content: {
          "application/json": components["schemas"]["tableOutput"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["table"];
      };
    };
  };
  /** Lookup a table, this could be internal or external. */
  tableGetById: {
    parameters: {
      path: {
        /** The ID of the table which this request is targeting. */
        tableId: components["parameters"]["tableId"];
      };
      header: {
        /** The ID of the app which this request is targeting. */
        "x-budibase-app-id": components["parameters"]["appId"];
      };
    };
    responses: {
      /** Returns the retrieved table. */
      200: {
        content: {
          "application/json": components["schemas"]["tableOutput"];
        };
      };
    };
  };
  /** Update a table, this could be internal or external. */
  tableUpdate: {
    parameters: {
      path: {
        /** The ID of the table which this request is targeting. */
        tableId: components["parameters"]["tableId"];
      };
      header: {
        /** The ID of the app which this request is targeting. */
        "x-budibase-app-id": components["parameters"]["appId"];
      };
    };
    responses: {
      /** Returns the updated table. */
      200: {
        content: {
          "application/json": components["schemas"]["tableOutput"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["table"];
      };
    };
  };
  /** Delete a table, this could be internal or external. */
  tableDestroy: {
    parameters: {
      path: {
        /** The ID of the table which this request is targeting. */
        tableId: components["parameters"]["tableId"];
      };
      header: {
        /** The ID of the app which this request is targeting. */
        "x-budibase-app-id": components["parameters"]["appId"];
      };
    };
    responses: {
      /** Returns the deleted table. */
      200: {
        content: {
          "application/json": components["schemas"]["tableOutput"];
        };
      };
    };
  };
  /** Based on table properties (currently only name) search for tables. This could be an internal or an external table. */
  tableSearch: {
    parameters: {
      header: {
        /** The ID of the app which this request is targeting. */
        "x-budibase-app-id": components["parameters"]["appId"];
      };
    };
    responses: {
      /** Returns the found tables, based on the search parameters. */
      200: {
        content: {
          "application/json": components["schemas"]["tableSearch"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["nameSearch"];
      };
    };
  };
  userCreate: {
    responses: {
      /** Returns the created user. */
      200: {
        content: {
          "application/json": components["schemas"]["userOutput"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["user"];
      };
    };
  };
  userGetById: {
    parameters: {
      path: {
        /** The ID of the user which this request is targeting. */
        userId: components["parameters"]["userId"];
      };
    };
    responses: {
      /** Returns the retrieved user. */
      200: {
        content: {
          "application/json": components["schemas"]["userOutput"];
        };
      };
    };
  };
  userUpdate: {
    parameters: {
      path: {
        /** The ID of the user which this request is targeting. */
        userId: components["parameters"]["userId"];
      };
    };
    responses: {
      /** Returns the updated user. */
      200: {
        content: {
          "application/json": components["schemas"]["userOutput"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["user"];
      };
    };
  };
  userDestroy: {
    parameters: {
      path: {
        /** The ID of the user which this request is targeting. */
        userId: components["parameters"]["userId"];
      };
    };
    responses: {
      /** Returns the deleted user. */
      200: {
        content: {
          "application/json": components["schemas"]["userOutput"];
        };
      };
    };
  };
  /** Based on user properties (currently only name) search for users. */
  userSearch: {
    responses: {
      /** Returns the found users based on search parameters. */
      200: {
        content: {
          "application/json": components["schemas"]["userSearch"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["nameSearch"];
      };
    };
  };
  /** Create a view, this can be against an internal or external table. */
  viewCreate: {
    parameters: {
      header: {
        /** The ID of the app which this request is targeting. */
        "x-budibase-app-id": components["parameters"]["appId"];
      };
    };
    responses: {
      /** Returns the created view, including the ID which has been generated for it. */
      200: {
        content: {
          "application/json": components["schemas"]["viewOutput"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["view"];
      };
    };
  };
  /** Lookup a view, this could be internal or external. */
  viewGetById: {
    parameters: {
      path: {
        /** The ID of the view which this request is targeting. */
        viewId: components["parameters"]["viewId"];
      };
      header: {
        /** The ID of the app which this request is targeting. */
        "x-budibase-app-id": components["parameters"]["appId"];
      };
    };
    responses: {
      /** Returns the retrieved view. */
      200: {
        content: {
          "application/json": components["schemas"]["viewOutput"];
        };
      };
    };
  };
  /** Update a view, this can be against an internal or external table. */
  viewUpdate: {
    parameters: {
      path: {
        /** The ID of the view which this request is targeting. */
        viewId: components["parameters"]["viewId"];
      };
      header: {
        /** The ID of the app which this request is targeting. */
        "x-budibase-app-id": components["parameters"]["appId"];
      };
    };
    responses: {
      /** Returns the updated view. */
      200: {
        content: {
          "application/json": components["schemas"]["viewOutput"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["view"];
      };
    };
  };
  /** Delete a view, this can be against an internal or external table. */
  viewDestroy: {
    parameters: {
      path: {
        /** The ID of the view which this request is targeting. */
        viewId: components["parameters"]["viewId"];
      };
      header: {
        /** The ID of the app which this request is targeting. */
        "x-budibase-app-id": components["parameters"]["appId"];
      };
    };
    responses: {
      /** Returns the deleted view. */
      200: {
        content: {
          "application/json": components["schemas"]["viewOutput"];
        };
      };
    };
  };
  /** Based on view properties (currently only name) search for views. */
  viewSearch: {
    parameters: {
      header: {
        /** The ID of the app which this request is targeting. */
        "x-budibase-app-id": components["parameters"]["appId"];
      };
    };
    responses: {
      /** Returns the found views, based on the search parameters. */
      200: {
        content: {
          "application/json": components["schemas"]["viewSearch"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["nameSearch"];
      };
    };
  };
}

export interface external {}
