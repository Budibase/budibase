{"version":3,"names":["VALID_CALLEES","INVALID_METHODS","isValidCallee","val","includes","isInvalidMethod","evaluateTruthy","res","evaluate","confident","value","deopt","path","state","deoptPath","evaluateCached","node","seen","has","existing","get","resolved","item","set","_evaluate","isSequenceExpression","exprs","length","isStringLiteral","isNumericLiteral","isBooleanLiteral","isNullLiteral","isTemplateLiteral","evaluateQuasis","quasis","isTaggedTemplateExpression","isMemberExpression","object","name","property","isIdentifier","scope","getBinding","quasi","isConditionalExpression","testResult","isExpressionWrapper","parentPath","isCallExpression","callee","isLiteral","type","isReferencedIdentifier","binding","constantViolations","start","end","hasValue","undefined","Infinity","NaN","resolve","isUnaryExpression","prefix","operator","argument","isFunction","isClass","arg","isArrayExpression","arr","elems","elem","elemValue","push","isObjectExpression","obj","props","prop","isObjectMethod","isSpreadElement","keyPath","key","computed","valuePath","isLogicalExpression","wasConfident","left","leftConfident","right","rightConfident","isBinaryExpression","context","func","global","args","map","apply","raw","str","i","cooked","expr","String","Map"],"sources":["../../src/path/evaluation.ts"],"sourcesContent":["import type NodePath from \"./index\";\nimport type * as t from \"@babel/types\";\n\n// This file contains Babels metainterpreter that can evaluate static code.\n\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"] as const;\nconst INVALID_METHODS = [\"random\"] as const;\n\nfunction isValidCallee(val: string): val is typeof VALID_CALLEES[number] {\n  return VALID_CALLEES.includes(\n    // @ts-expect-error val is a string\n    val,\n  );\n}\n\nfunction isInvalidMethod(val: string): val is typeof INVALID_METHODS[number] {\n  return INVALID_METHODS.includes(\n    // @ts-expect-error val is a string\n    val,\n  );\n}\n\n/**\n * Walk the input `node` and statically evaluate if it's truthy.\n *\n * Returning `true` when we're sure that the expression will evaluate to a\n * truthy value, `false` if we're sure that it will evaluate to a falsy\n * value and `undefined` if we aren't sure. Because of this please do not\n * rely on coercion when using this method and check with === if it's false.\n *\n * For example do:\n *\n *   if (t.evaluateTruthy(node) === false) falsyLogic();\n *\n * **AND NOT**\n *\n *   if (!t.evaluateTruthy(node)) falsyLogic();\n *\n */\n\nexport function evaluateTruthy(this: NodePath): boolean {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\ntype State = {\n  confident: boolean;\n  deoptPath: NodePath | null;\n  seen: Map<t.Node, Result>;\n};\n\ntype Result = {\n  resolved: boolean;\n  value?: any;\n};\n/**\n * Deopts the evaluation\n */\nfunction deopt(path: NodePath, state: State) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\n/**\n * We wrap the _evaluate method so we can track `seen` nodes, we push an item\n * to the map before we actually evaluate it so we can deopt on self recursive\n * nodes such as:\n *\n *   var g = a ? 1 : 2,\n *       a = g * this.foo\n */\nfunction evaluateCached(path: NodePath, state: State): any {\n  const { node } = path;\n  const { seen } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item: Result = { resolved: false };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n    return val;\n  }\n}\n\nfunction _evaluate(path: NodePath, state: State): any {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (\n    path.isStringLiteral() ||\n    path.isNumericLiteral() ||\n    path.isBooleanLiteral()\n  ) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (\n    path.isTaggedTemplateExpression() &&\n    path.get(\"tag\").isMemberExpression()\n  ) {\n    const object = path.get(\"tag.object\") as NodePath;\n    const {\n      // @ts-expect-error todo(flow->ts): possible bug, object is can be any expression and so name might be undefined\n      node: { name },\n    } = object;\n    const property = path.get(\"tag.property\") as NodePath;\n\n    if (\n      object.isIdentifier() &&\n      name === \"String\" &&\n      // todo(flow->ts): was changed from getBinding(name, true)\n      //  should this be hasBinding(name, true) as the binding is never used later?\n      !path.scope.getBinding(name) &&\n      property.isIdentifier() &&\n      property.node.name === \"raw\"\n    ) {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    // TypeCastExpression, ExpressionStatement etc\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  // \"foo\".length\n  if (\n    path.isMemberExpression() &&\n    !path.parentPath.isCallExpression({ callee: path.node })\n  ) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      // @ts-expect-error todo(flow->ts): instead of typeof - would it be better to check type of ast node?\n      const value = object.node.value;\n      const type = typeof value;\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding?.hasValue) {\n      return binding.value;\n    } else {\n      if (path.node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (path.node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (path.node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({ prefix: true })) {\n    if (path.node.operator === \"void\") {\n      // we don't need to evaluate the argument to know what this will return\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n    if (\n      path.node.operator === \"typeof\" &&\n      (argument.isFunction() || argument.isClass())\n    ) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n      case \"+\":\n        return +arg;\n      case \"-\":\n        return -arg;\n      case \"~\":\n        return ~arg;\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems: Array<NodePath> = path.get(\"elements\");\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n      const keyPath = (prop as NodePath<t.ObjectProperty>).get(\"key\");\n      let key;\n      // @ts-expect-error todo(flow->ts): type refinement issues ObjectMethod and SpreadElement somehow not excluded\n      if (prop.node.computed) {\n        key = keyPath.evaluate();\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n        key = key.value;\n      } else if (keyPath.isIdentifier()) {\n        key = keyPath.node.name;\n      } else {\n        key = (\n          keyPath.node as t.StringLiteral | t.NumericLiteral | t.BigIntLiteral\n        ).value;\n      }\n      const valuePath = (prop as NodePath<t.ObjectProperty>).get(\"value\");\n      let value = valuePath.evaluate();\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n      value = value.value;\n      // @ts-expect-error key is any type\n      obj[key] = value;\n    }\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    // If we are confident that the left side of an && is false, or the left\n    // side of an || is true, we can be confident about the entire expression\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        // TODO consider having a \"truthy type\" that doesn't bail on\n        // left uncertainty but can still evaluate to truthy.\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n\n        return left || right;\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n\n        return left && right;\n      case \"??\":\n        state.confident = leftConfident && (left != null || rightConfident);\n        if (!state.confident) return;\n\n        return left ?? right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n      case \"+\":\n        return left + right;\n      case \"/\":\n        return left / right;\n      case \"*\":\n        return left * right;\n      case \"%\":\n        return left % right;\n      case \"**\":\n        return left ** right;\n      case \"<\":\n        return left < right;\n      case \">\":\n        return left > right;\n      case \"<=\":\n        return left <= right;\n      case \">=\":\n        return left >= right;\n      case \"==\":\n        return left == right; // eslint-disable-line eqeqeq\n      case \"!=\":\n        return left != right;\n      case \"===\":\n        return left === right;\n      case \"!==\":\n        return left !== right;\n      case \"|\":\n        return left | right;\n      case \"&\":\n        return left & right;\n      case \"^\":\n        return left ^ right;\n      case \"<<\":\n        return left << right;\n      case \">>\":\n        return left >> right;\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    // Number(1);\n    if (\n      callee.isIdentifier() &&\n      !path.scope.getBinding(callee.node.name) &&\n      isValidCallee(callee.node.name)\n    ) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      // Math.min(1, 2)\n      if (\n        object.isIdentifier() &&\n        property.isIdentifier() &&\n        isValidCallee(object.node.name) &&\n        !isInvalidMethod(property.node.name)\n      ) {\n        context = global[object.node.name];\n        // @ts-expect-error property may not exist in context object\n        func = context[property.node.name];\n      }\n\n      // \"abc\".charCodeAt(4)\n      if (object.isLiteral() && property.isIdentifier()) {\n        // @ts-expect-error todo(flow->ts): consider checking ast node type instead of value type (StringLiteral and NumberLiteral)\n        const type = typeof object.node.value;\n        if (type === \"string\" || type === \"number\") {\n          // @ts-expect-error todo(flow->ts): consider checking ast node type instead of value type\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(\n  path: NodePath<t.TaggedTemplateExpression | t.TemplateLiteral>,\n  quasis: Array<any>,\n  state: State,\n  raw = false,\n) {\n  let str = \"\";\n\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    // not confident, evaluated an expression we don't like\n    if (!state.confident) break;\n\n    // add on element\n    str += raw ? elem.value.raw : elem.value.cooked;\n\n    // add on interpolated expression if it's present\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\n/**\n * Walk the input `node` and statically evaluate it.\n *\n * Returns an object in the form `{ confident, value, deopt }`. `confident`\n * indicates whether or not we had to drop out of evaluating the expression\n * because of hitting an unknown node that we couldn't confidently find the\n * value of, in which case `deopt` is the path of said node.\n *\n * Example:\n *\n *   t.evaluate(parse(\"5 + 5\")) // { confident: true, value: 10 }\n *   t.evaluate(parse(\"!true\")) // { confident: true, value: false }\n *   t.evaluate(parse(\"foo + foo\")) // { confident: false, value: undefined, deopt: NodePath }\n *\n */\n\nexport function evaluate(this: NodePath): {\n  confident: boolean;\n  value: any;\n  deopt?: NodePath;\n} {\n  const state: State = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map(),\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value,\n  };\n}\n"],"mappings":"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"}