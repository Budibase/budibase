{"version":3,"names":["renameVisitor","ReferencedIdentifier","node","state","name","oldName","newName","Scope","path","scope","bindingIdentifierEquals","binding","identifier","skip","isMethod","requeueComputedKeyAndDecorators","isVariableDeclaration","ids","getOuterBindingIdentifiers","Renamer","constructor","maybeConvertFromExportDeclaration","parentDeclar","maybeExportDeclar","parentPath","isExportDeclaration","isExportDefaultDeclaration","declaration","t","isDeclaration","id","isExportAllDeclaration","splitExportDeclaration","maybeConvertFromClassFunctionDeclaration","maybeConvertFromClassFunctionExpression","rename","block","find","isFunctionExpression","isClassExpression","bindingIds","blockToTraverse","type","cases","forEach","c","traverse","removeOwnBinding","bindings"],"sources":["../../../src/scope/lib/renamer.ts"],"sourcesContent":["import type Binding from \"../binding\";\nimport splitExportDeclaration from \"@babel/helper-split-export-declaration\";\nimport * as t from \"@babel/types\";\nimport type { NodePath, Visitor } from \"../..\";\nimport { requeueComputedKeyAndDecorators } from \"@babel/helper-environment-visitor\";\n\nconst renameVisitor: Visitor<Renamer> = {\n  ReferencedIdentifier({ node }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (\n      !path.scope.bindingIdentifierEquals(\n        state.oldName,\n        state.binding.identifier,\n      )\n    ) {\n      path.skip();\n      if (path.isMethod()) {\n        requeueComputedKeyAndDecorators(path);\n      }\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(\n    path: NodePath<t.AssignmentPattern | t.Declaration | t.VariableDeclarator>,\n    state,\n  ) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  },\n};\n\nexport default class Renamer {\n  constructor(binding: Binding, oldName: string, newName: string) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  declare oldName: string;\n  declare newName: string;\n  declare binding: Binding;\n\n  maybeConvertFromExportDeclaration(parentDeclar: NodePath) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration()) {\n      const { declaration } = maybeExportDeclar.node;\n      if (t.isDeclaration(declaration) && !declaration.id) {\n        return;\n      }\n    }\n\n    if (maybeExportDeclar.isExportAllDeclaration()) {\n      return;\n    }\n\n    splitExportDeclaration(\n      maybeExportDeclar as NodePath<\n        Exclude<t.ExportDeclaration, t.ExportAllDeclaration>\n      >,\n    );\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path: NodePath) {\n    return path; // TODO\n\n    // // retain the `name` of a class/function declaration\n\n    // if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    // if (this.binding.kind !== \"hoisted\") return;\n\n    // path.node.id = identifier(this.oldName);\n    // path.node._blockHoist = 3;\n\n    // path.replaceWith(\n    //   variableDeclaration(\"let\", [\n    //     variableDeclarator(identifier(this.newName), toExpression(path.node)),\n    //   ]),\n    // );\n  }\n\n  maybeConvertFromClassFunctionExpression(path: NodePath) {\n    return path; // TODO\n\n    // // retain the `name` of a class/function expression\n\n    // if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    // if (this.binding.kind !== \"local\") return;\n\n    // path.node.id = identifier(this.oldName);\n\n    // this.binding.scope.parent.push({\n    //   id: identifier(this.newName),\n    // });\n\n    // path.replaceWith(\n    //   assignmentExpression(\"=\", identifier(this.newName), path.node),\n    // );\n  }\n\n  rename(block?: t.Pattern | t.Scopable) {\n    const { binding, oldName, newName } = this;\n    const { scope, path } = binding;\n\n    const parentDeclar = path.find(\n      path =>\n        path.isDeclaration() ||\n        path.isFunctionExpression() ||\n        path.isClassExpression(),\n    );\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n      if (bindingIds[oldName] === binding.identifier) {\n        // When we are renaming an exported identifier, we need to ensure that\n        // the exported binding keeps the old name.\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    const blockToTraverse = block || scope.block;\n    if (blockToTraverse?.type === \"SwitchStatement\") {\n      // discriminant is not part of current scope, should be skipped.\n      blockToTraverse.cases.forEach(c => {\n        scope.traverse(c, renameVisitor, this);\n      });\n    } else {\n      scope.traverse(blockToTraverse, renameVisitor, this);\n    }\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(path);\n      this.maybeConvertFromClassFunctionExpression(path);\n    }\n  }\n}\n"],"mappings":"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"}