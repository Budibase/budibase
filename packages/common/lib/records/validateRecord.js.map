{"version":3,"sources":["../../src/records/validateRecord.js"],"names":["fieldParseError","fieldName","value","fields","message","validateAllFieldParse","record","model","f","name","parseResult","errors","success","push","validateAllTypeConstraints","field","isNonEmptyString","m","e","runRecordValidationRules","runValidationRule","rule","isValid","expressionWhenValid","expressionContext","valid","invalidFields","messageWhenInvalid","validationRules","flatten","r","validateRecord","schema","findModel","_modelId","fieldParseFails","recordValidationRuleFails","typeContraintFails"],"mappings":"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","sourcesContent":["import { map, reduce, filter, isEmpty, flatten, each, union } from \"lodash/fp\";\nimport { compileCode } from \"../common/compileCode\";\nimport {\n  validateFieldParse,\n  validateTypeConstraints,\n} from \"../schema/types/index.js\"\nimport { $, isNonEmptyString } from \"../common/index.js\"\n\nconst fieldParseError = (fieldName, value) => ({\n  fields: [fieldName],\n  message: `Could not parse field ${fieldName}:${value}`,\n})\n\nconst validateAllFieldParse = (record, model) =>\n  $(model.fields, [\n    map(f => ({ name: f.name, parseResult: validateFieldParse(f, record) })),\n    reduce((errors, f) => {\n      if (f.parseResult.success) return errors\n      errors.push(fieldParseError(f.name, f.parseResult.value))\n      return errors\n    }, []),\n  ])\n\nconst validateAllTypeConstraints = (record, model) => {\n  const errors = []\n  for (const field of model.fields) {\n    $(validateTypeConstraints(field, record), [\n      filter(isNonEmptyString),\n      map(m => ({ message: m, fields: [field.name] })),\n      each(e => errors.push(e)),\n    ])\n  }\n  return errors\n}\n\nconst runRecordValidationRules = (record, model) => {\n  const runValidationRule = rule => {\n    const isValid = compileCode(rule.expressionWhenValid)\n    const expressionContext = { record }\n    return isValid(expressionContext)\n      ? { valid: true }\n      : {\n          valid: false,\n          fields: rule.invalidFields,\n          message: rule.messageWhenInvalid,\n        }\n  }\n\n  return $(model.validationRules, [\n    map(runValidationRule),\n    flatten,\n    filter(r => r.valid === false),\n    map(r => ({ fields: r.fields, message: r.message })),\n  ])\n}\n\nexport const validateRecord = (schema, record) => {\n  const model = schema.findModel(record._modelId)\n  const fieldParseFails = validateAllFieldParse(record, model)\n\n  // non parsing would cause further issues - exit here\n  if (!isEmpty(fieldParseFails)) {\n    return { isValid: false, errors: fieldParseFails }\n  }\n\n  const recordValidationRuleFails = runRecordValidationRules(record, model)\n  const typeContraintFails = validateAllTypeConstraints(record, model)\n\n  if (\n    isEmpty(fieldParseFails) &&\n    isEmpty(recordValidationRuleFails) &&\n    isEmpty(typeContraintFails)\n  ) {\n    return { isValid: true, errors: [] }\n  }\n\n  return {\n    isValid: false,\n    errors: union(\n      fieldParseFails,\n      typeContraintFails,\n      recordValidationRuleFails\n    ),\n  }\n}\n"],"file":"validateRecord.js"}